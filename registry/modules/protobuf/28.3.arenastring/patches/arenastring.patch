diff --git a/MODULE.bazel b/MODULE.bazel
index 1e626f91d..3d7978758 100644
--- a/MODULE.bazel
+++ b/MODULE.bazel
@@ -3,7 +3,7 @@
 
 module(
     name = "protobuf",
-    version = "28.3",  # Automatically updated on release
+    version = "28.3.arenastring",  # Automatically updated on release
     compatibility_level = 1,
     repo_name = "com_google_protobuf",
 )
@@ -70,3 +70,14 @@ crate.spec(
 )
 crate.from_specs()
 use_repo(crate, crate_index = "crates")
+
+bazel_dep(name = "googletest", version = "1.15.2", repo_name = "com_google_googletest", dev_dependency = True)
+bazel_dep(name = "rules_ruby", dev_dependency = True)
+archive_override(
+    module_name = "rules_ruby",
+    urls = ["https://github.com/protocolbuffers/rules_ruby/archive/b7f3e9756f3c45527be27bc38840d5a1ba690436.tar.gz"],
+    strip_prefix = "rules_ruby-b7f3e9756f3c45527be27bc38840d5a1ba690436",
+    integrity = "sha256-RNo21X/p9slOdF912FLprLnxvZHMXBTxaUDGFmm2bx8=",
+    patches = ["third_party/rules_ruby.patch"],
+    patch_strip = 1,
+)
diff --git a/WORKSPACE.bzlmod b/WORKSPACE.bzlmod
new file mode 100644
index 000000000..8d1c8b69c
--- /dev/null
+++ b/WORKSPACE.bzlmod
@@ -0,0 +1 @@
+ 
diff --git a/src/file_lists.cmake b/src/file_lists.cmake
index 07152d92d..200c67cf6 100644
--- a/src/file_lists.cmake
+++ b/src/file_lists.cmake
@@ -243,6 +243,8 @@ set(libprotobuf_lite_hdrs
   ${protobuf_SOURCE_DIR}/src/google/protobuf/arena_allocation_policy.h
   ${protobuf_SOURCE_DIR}/src/google/protobuf/arena_cleanup.h
   ${protobuf_SOURCE_DIR}/src/google/protobuf/arenastring.h
+  # ARENASTRING PATCH: add new file
+  ${protobuf_SOURCE_DIR}/src/google/protobuf/arenastring_impl.h
   ${protobuf_SOURCE_DIR}/src/google/protobuf/arenaz_sampler.h
   ${protobuf_SOURCE_DIR}/src/google/protobuf/descriptor_lite.h
   ${protobuf_SOURCE_DIR}/src/google/protobuf/endian.h
diff --git a/src/google/protobuf/BUILD.bazel b/src/google/protobuf/BUILD.bazel
index 381e0e24e..d56a5836c 100644
--- a/src/google/protobuf/BUILD.bazel
+++ b/src/google/protobuf/BUILD.bazel
@@ -483,6 +483,8 @@ cc_library(
         "any.h",
         "arena.h",
         "arenastring.h",
+        # ARENASTRING PATCH: add new file
+        "arenastring_impl.h",
         "arenaz_sampler.h",
         "descriptor_lite.h",
         "endian.h",
@@ -823,6 +825,9 @@ filegroup(
         "map_proto2_unittest.proto",
         "map_unittest.proto",
         "unittest.proto",
+        # ARENASTRING PATCH: add new file
+        "unittest_arenastring.proto",
+        "unittest_arenastring_mutable.proto",
         "unittest_custom_options.proto",
         "unittest_embed_optimize_for.proto",
         "unittest_empty.proto",
@@ -838,6 +843,9 @@ filegroup(
         "unittest_optimize_for.proto",
         "unittest_proto3.proto",
         "unittest_proto3_arena.proto",
+        # ARENASTRING PATCH: add new file
+        "unittest_proto3_arenastring.proto",
+        "unittest_proto3_arenastring_mutable.proto",
         "unittest_proto3_arena_lite.proto",
         "unittest_proto3_bad_macros.proto",
         "unittest_proto3_extensions.proto",
@@ -1225,6 +1233,7 @@ cc_test(
     ],
 )
 
+# ARENASTRING PATCH: add new unittest
 cc_test(
     name = "arenastring_unittest",
     srcs = ["arenastring_unittest.cc"],
@@ -1241,6 +1250,23 @@ cc_test(
     ],
 )
 
+cc_test(
+    name = "arenastring_impl_unittest",
+    srcs = ["arenastring_impl_unittest.cc"],
+    deps = [
+        ":port",
+        ":protobuf",
+        ":protobuf_lite",
+        ":cc_test_protos",
+        "//src/google/protobuf/io",
+        "//src/google/protobuf/stubs",
+        "@com_google_absl//absl/log:absl_check",
+        "@com_google_absl//absl/strings",
+        "@com_google_googletest//:gtest",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
 cc_test(
     name = "arenaz_sampler_test",
     srcs = ["arenaz_sampler_test.cc"],
diff --git a/src/google/protobuf/any.pb.h b/src/google/protobuf/any.pb.h
index 97855e7df..c074ea582 100644
--- a/src/google/protobuf/any.pb.h
+++ b/src/google/protobuf/any.pb.h
@@ -271,6 +271,7 @@ class PROTOBUF_EXPORT Any final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_url(
       const std::string& value);
   std::string* _internal_mutable_type_url();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_type_url_accessor();
 
   public:
   // bytes value = 2;
@@ -287,6 +288,7 @@ class PROTOBUF_EXPORT Any final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
       const std::string& value);
   std::string* _internal_mutable_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_value_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.Any)
@@ -357,7 +359,7 @@ inline PROTOBUF_ALWAYS_INLINE void Any::set_type_url(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Any.type_url)
 }
 inline std::string* Any::mutable_type_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_type_url();
+  auto _s = _internal_mutable_type_url();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Any.type_url)
   return _s;
 }
@@ -373,10 +375,18 @@ inline std::string* Any::_internal_mutable_type_url() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.type_url_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Any::_internal_mutable_type_url_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.type_url_.MutableAccessor( GetArena());
+}
 inline std::string* Any::release_type_url() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Any.type_url)
-  return _impl_.type_url_.Release();
+  auto* released = _impl_.type_url_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.type_url_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Any::set_allocated_type_url(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -407,7 +417,7 @@ inline PROTOBUF_ALWAYS_INLINE void Any::set_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Any.value)
 }
 inline std::string* Any::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_value();
+  auto _s = _internal_mutable_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Any.value)
   return _s;
 }
@@ -423,10 +433,18 @@ inline std::string* Any::_internal_mutable_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Any::_internal_mutable_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.value_.MutableAccessor( GetArena());
+}
 inline std::string* Any::release_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Any.value)
-  return _impl_.value_.Release();
+  auto* released = _impl_.value_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.value_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Any::set_allocated_value(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
diff --git a/src/google/protobuf/api.pb.h b/src/google/protobuf/api.pb.h
index fb730a416..8f2bc8e1d 100644
--- a/src/google/protobuf/api.pb.h
+++ b/src/google/protobuf/api.pb.h
@@ -231,6 +231,7 @@ class PROTOBUF_EXPORT Mixin final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string root = 2;
@@ -247,6 +248,7 @@ class PROTOBUF_EXPORT Mixin final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(
       const std::string& value);
   std::string* _internal_mutable_root();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_root_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.Mixin)
@@ -463,6 +465,7 @@ class PROTOBUF_EXPORT Method final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string request_type_url = 2;
@@ -479,6 +482,7 @@ class PROTOBUF_EXPORT Method final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_type_url(
       const std::string& value);
   std::string* _internal_mutable_request_type_url();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_request_type_url_accessor();
 
   public:
   // string response_type_url = 4;
@@ -495,6 +499,7 @@ class PROTOBUF_EXPORT Method final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_type_url(
       const std::string& value);
   std::string* _internal_mutable_response_type_url();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_response_type_url_accessor();
 
   public:
   // bool request_streaming = 3;
@@ -780,6 +785,7 @@ class PROTOBUF_EXPORT Api final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string version = 4;
@@ -796,6 +802,7 @@ class PROTOBUF_EXPORT Api final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
       const std::string& value);
   std::string* _internal_mutable_version();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_version_accessor();
 
   public:
   // .google.protobuf.SourceContext source_context = 5;
@@ -896,7 +903,7 @@ inline PROTOBUF_ALWAYS_INLINE void Api::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Api.name)
 }
 inline std::string* Api::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Api.name)
   return _s;
 }
@@ -912,10 +919,18 @@ inline std::string* Api::_internal_mutable_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Api::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Api::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Api.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Api::set_allocated_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -1040,7 +1055,7 @@ inline PROTOBUF_ALWAYS_INLINE void Api::set_version(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Api.version)
 }
 inline std::string* Api::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_version();
+  auto _s = _internal_mutable_version();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Api.version)
   return _s;
 }
@@ -1056,10 +1071,18 @@ inline std::string* Api::_internal_mutable_version() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.version_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Api::_internal_mutable_version_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.version_.MutableAccessor( GetArena());
+}
 inline std::string* Api::release_version() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Api.version)
-  return _impl_.version_.Release();
+  auto* released = _impl_.version_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.version_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Api::set_allocated_version(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -1256,7 +1279,7 @@ inline PROTOBUF_ALWAYS_INLINE void Method::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Method.name)
 }
 inline std::string* Method::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Method.name)
   return _s;
 }
@@ -1272,10 +1295,18 @@ inline std::string* Method::_internal_mutable_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Method::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Method::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Method.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Method::set_allocated_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -1306,7 +1337,7 @@ inline PROTOBUF_ALWAYS_INLINE void Method::set_request_type_url(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Method.request_type_url)
 }
 inline std::string* Method::mutable_request_type_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_request_type_url();
+  auto _s = _internal_mutable_request_type_url();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Method.request_type_url)
   return _s;
 }
@@ -1322,10 +1353,18 @@ inline std::string* Method::_internal_mutable_request_type_url() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.request_type_url_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Method::_internal_mutable_request_type_url_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.request_type_url_.MutableAccessor( GetArena());
+}
 inline std::string* Method::release_request_type_url() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Method.request_type_url)
-  return _impl_.request_type_url_.Release();
+  auto* released = _impl_.request_type_url_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.request_type_url_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Method::set_allocated_request_type_url(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -1378,7 +1417,7 @@ inline PROTOBUF_ALWAYS_INLINE void Method::set_response_type_url(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Method.response_type_url)
 }
 inline std::string* Method::mutable_response_type_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_response_type_url();
+  auto _s = _internal_mutable_response_type_url();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Method.response_type_url)
   return _s;
 }
@@ -1394,10 +1433,18 @@ inline std::string* Method::_internal_mutable_response_type_url() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.response_type_url_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Method::_internal_mutable_response_type_url_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.response_type_url_.MutableAccessor( GetArena());
+}
 inline std::string* Method::release_response_type_url() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Method.response_type_url)
-  return _impl_.response_type_url_.Release();
+  auto* released = _impl_.response_type_url_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.response_type_url_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Method::set_allocated_response_type_url(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -1521,7 +1568,7 @@ inline PROTOBUF_ALWAYS_INLINE void Mixin::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Mixin.name)
 }
 inline std::string* Mixin::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Mixin.name)
   return _s;
 }
@@ -1537,10 +1584,18 @@ inline std::string* Mixin::_internal_mutable_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Mixin::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Mixin::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Mixin.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Mixin::set_allocated_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -1571,7 +1626,7 @@ inline PROTOBUF_ALWAYS_INLINE void Mixin::set_root(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Mixin.root)
 }
 inline std::string* Mixin::mutable_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_root();
+  auto _s = _internal_mutable_root();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Mixin.root)
   return _s;
 }
@@ -1587,10 +1642,18 @@ inline std::string* Mixin::_internal_mutable_root() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.root_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Mixin::_internal_mutable_root_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.root_.MutableAccessor( GetArena());
+}
 inline std::string* Mixin::release_root() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Mixin.root)
-  return _impl_.root_.Release();
+  auto* released = _impl_.root_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.root_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Mixin::set_allocated_root(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
diff --git a/src/google/protobuf/arena_align_test.cc b/src/google/protobuf/arena_align_test.cc
index 7e0347f10..fa95d47ac 100644
--- a/src/google/protobuf/arena_align_test.cc
+++ b/src/google/protobuf/arena_align_test.cc
@@ -147,7 +147,11 @@ TEST(ArenaAlign, Padded) {
 }
 
 TEST(ArenaAlign, CeilPtr) {
-  alignas(64) char p[129] = {0};
+  struct alignas(64) S {
+    char p[129] = {0};
+  };
+  auto s = ::std::make_unique<S>();
+  auto p = s->p;
   auto align_64 = ArenaAlignAs(64);
   EXPECT_THAT(align_64.Ceil(p + 0), Eq(p));
   EXPECT_THAT(align_64.Ceil(p + 1), Eq(p + 64));
@@ -159,7 +163,11 @@ TEST(ArenaAlign, CeilPtr) {
 }
 
 TEST(ArenaAlign, CheckAligned) {
-  alignas(128) char p[129] = {0};
+  struct alignas(64) S {
+    char p[129] = {0};
+  };
+  auto s = ::std::make_unique<S>();
+  auto p = s->p;
   auto align_64 = ArenaAlignAs(64);
   EXPECT_THAT(align_64.CheckAligned(p + 0), Eq(p));
   EXPECT_THAT(align_64.CheckAligned(p + 64), Eq(p + 64));
@@ -178,7 +186,11 @@ TEST(ArenaAlign, CheckAligned) {
 }
 
 TEST(ArenaAlign, CeilDefaultAligned) {
-  alignas(128) char p[129] = {0};
+  struct alignas(64) S {
+    char p[129] = {0};
+  };
+  auto s = ::std::make_unique<S>();
+  auto p = s->p;
   auto align_64 = ArenaAlignAs(64);
   EXPECT_THAT(align_64.CeilDefaultAligned(p + 0), Eq(p));
   EXPECT_THAT(align_64.CeilDefaultAligned(p + 8), Eq(p + 64));
diff --git a/src/google/protobuf/arena_unittest.cc b/src/google/protobuf/arena_unittest.cc
index 857abf057..9500344e3 100644
--- a/src/google/protobuf/arena_unittest.cc
+++ b/src/google/protobuf/arena_unittest.cc
@@ -1173,11 +1173,15 @@ TEST(ArenaTest, UnsafeArenaAddAllocatedToRepeatedField) {
   arena1_message->Clear();
   {
     std::string* s = new std::string("Test");
-    arena1_message->mutable_repeated_string()->UnsafeArenaAddAllocated(s);
+    // ARENASTRING PATCH: wrap to StringHandlerType
+    arena1_message->mutable_repeated_string()->UnsafeArenaAddAllocated(
+        internal::StringHandlerType::ToUnTagged(s));
     // Should not copy.
     EXPECT_EQ(s, &arena1_message->repeated_string(0));
     EXPECT_EQ("Test", arena1_message->repeated_string(0));
-    delete arena1_message->mutable_repeated_string()->UnsafeArenaReleaseLast();
+    // ARENASTRING PATCH: unwrap StringHandlerType
+    delete arena1_message->mutable_repeated_string()
+        ->UnsafeArenaReleaseLast()->ToStringPtr();
   }
 }
 
@@ -1296,7 +1300,9 @@ TEST(ArenaTest, UnsafeArenaAddAllocated) {
   TestAllTypes* message = Arena::Create<TestAllTypes>(&arena);
   for (int i = 0; i < 10; i++) {
     std::string* arena_string = Arena::Create<std::string>(&arena);
-    message->mutable_repeated_string()->UnsafeArenaAddAllocated(arena_string);
+    // ARENASTRING PATCH: wrap to StringHandlerType
+    message->mutable_repeated_string()->UnsafeArenaAddAllocated(
+        internal::StringHandlerType::ToUnTagged(arena_string));
     EXPECT_EQ(arena_string, message->mutable_repeated_string(i));
   }
 }
@@ -1538,13 +1544,7 @@ TEST(ArenaTest, ClearOneofMessageOnArena) {
   child->set_moo_int(100);
   message->clear_foo_message();
 
-#ifndef PROTOBUF_ASAN
   EXPECT_NE(child->moo_int(), 100);
-#else
-#if GTEST_HAS_DEATH_TEST && defined(__cpp_if_constexpr)
-  EXPECT_DEATH(EXPECT_EQ(child->moo_int(), 0), "use-after-poison");
-#endif
-#endif
 }
 
 TEST(ArenaTest, CopyValuesWithinOneof) {
diff --git a/src/google/protobuf/arenastring.cc b/src/google/protobuf/arenastring.cc
index bf9d0bb7c..d46858eb7 100644
--- a/src/google/protobuf/arenastring.cc
+++ b/src/google/protobuf/arenastring.cc
@@ -84,7 +84,8 @@ inline TaggedStringPtr CreateString(absl::string_view value) {
 // Creates an arena allocated std::string value.
 TaggedStringPtr CreateArenaString(Arena& arena, absl::string_view s) {
   TaggedStringPtr res;
-  res.SetMutableArena(Arena::Create<std::string>(&arena, s.data(), s.length()));
+  // Initialize to FixedSizeArena state
+  res.SetFixedSizeArena(ArenaStringAccessor::create(&arena, s).underlying());
   return res;
 }
 
@@ -116,7 +117,7 @@ void ArenaStringPtr::Set(absl::string_view value, Arena* arena) {
       old->assign("garbagedata");
     }
 #else   // PROTOBUF_FORCE_COPY_DEFAULT_STRING
-    UnsafeMutablePointer()->assign(value.data(), value.length());
+    Accessor(arena) = value;
 #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
   }
 }
@@ -127,8 +128,7 @@ void ArenaStringPtr::Set(const std::string& value, Arena* arena) {
   if (IsDefault()) {
     // If we're not on an arena, skip straight to a true string to avoid
     // possible copy cost later.
-    tagged_ptr_ = arena != nullptr ? CreateArenaString(*arena, value)
-                                   : CreateString(value);
+    NewString(arena, value);
   } else {
 #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
     if (arena == nullptr) {
@@ -141,7 +141,7 @@ void ArenaStringPtr::Set(const std::string& value, Arena* arena) {
       old->assign("garbagedata");
     }
 #else   // PROTOBUF_FORCE_COPY_DEFAULT_STRING
-    UnsafeMutablePointer()->assign(value);
+    Accessor(arena) = value;
 #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
   }
 }
@@ -150,13 +150,8 @@ void ArenaStringPtr::Set(std::string&& value, Arena* arena) {
   ScopedCheckPtrInvariants check(&tagged_ptr_);
   if (IsDefault()) {
     NewString(arena, std::move(value));
-  } else if (IsFixedSizeArena()) {
-    std::string* current = tagged_ptr_.Get();
-    auto* s = new (current) std::string(std::move(value));
-    arena->OwnDestructor(s);
-    tagged_ptr_.SetMutableArena(s);
-  } else /* !IsFixedSizeArena() */ {
-    *UnsafeMutablePointer() = std::move(value);
+  } else {
+    Accessor(arena) = std::move(value);
   }
 }
 
@@ -179,6 +174,42 @@ std::string* ArenaStringPtr::Mutable(const LazyString& default_value,
   }
 }
 
+MaybeArenaStringAccessor ArenaStringPtr::MutableAccessor(Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) {
+    std::string* string;
+    if (arena != nullptr) {
+      string = ArenaStringAccessor::create(arena).underlying();
+      tagged_ptr_.SetFixedSizeArena(string);
+    } else {
+      string = new std::string;
+      tagged_ptr_.SetAllocated(string);
+    }
+    return MaybeArenaStringAccessor(arena, string);
+  } else {
+    return Accessor(arena);
+  }
+}
+
+MaybeArenaStringAccessor ArenaStringPtr::MutableAccessor(
+    const LazyString& default_value, Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) {
+    std::string* string;
+    if (arena != nullptr) {
+      string =
+          ArenaStringAccessor::create(arena, default_value.get()).underlying();
+      tagged_ptr_.SetFixedSizeArena(string);
+    } else {
+      string = new std::string(default_value.get());
+      tagged_ptr_.SetAllocated(string);
+    }
+    return MaybeArenaStringAccessor(arena, string);
+  } else {
+    return Accessor(arena);
+  }
+}
+
 std::string* ArenaStringPtr::MutableNoCopy(Arena* arena) {
   ScopedCheckPtrInvariants check(&tagged_ptr_);
   if (tagged_ptr_.IsMutable()) {
@@ -193,12 +224,29 @@ std::string* ArenaStringPtr::MutableNoCopy(Arena* arena) {
 template <typename... Lazy>
 std::string* ArenaStringPtr::MutableSlow(::google::protobuf::Arena* arena,
                                          const Lazy&... lazy_default) {
+  // Turn state from FixedSizeArena to MutableArena
+  if (IsFixedSizeArena()) {
+    auto ptr = Arena::Create<std::string>(arena, *tagged_ptr_.Get());
+    tagged_ptr_.SetMutableArena(ptr);
+    return ptr;
+  }
+
   ABSL_DCHECK(IsDefault());
 
   // For empty defaults, this ends up calling the default constructor which is
   // more efficient than a copy construction from
   // GetEmptyStringAlreadyInited().
-  return NewString(arena, lazy_default.get()...);
+  if (arena == nullptr) {
+    // Turn state from Default to Allocated
+    auto ptr = new std::string(lazy_default.get()...);
+    tagged_ptr_.SetAllocated(ptr);
+    return ptr;
+  } else {
+    // Turn state from Default to MutableArena
+    auto ptr = Arena::Create<std::string>(arena, lazy_default.get()...);
+    tagged_ptr_.SetMutableArena(ptr);
+    return ptr;
+  }
 }
 
 std::string* ArenaStringPtr::Release() {
@@ -248,7 +296,7 @@ void ArenaStringPtr::ClearToEmpty() {
     // UpdateArenaString uses assign when capacity is larger than the new
     // value, which is trivially true in the donated string case.
     // const_cast<std::string*>(PtrValue<std::string>())->clear();
-    tagged_ptr_.Get()->clear();
+    ClearNonDefaultToEmpty();
   }
 }
 
@@ -259,23 +307,43 @@ void ArenaStringPtr::ClearToDefault(const LazyString& default_value,
   if (IsDefault()) {
     // Already set to default -- do nothing.
   } else {
-    UnsafeMutablePointer()->assign(default_value.get());
+    Accessor(arena) = default_value.get();
   }
 }
 
-const char* EpsCopyInputStream::ReadArenaString(const char* ptr,
-                                                ArenaStringPtr* s,
-                                                Arena* arena) {
-  ScopedCheckPtrInvariants check(&s->tagged_ptr_);
-  ABSL_DCHECK(arena != nullptr);
+// FixedSizeArena implement
+const char* EpsCopyInputStream::ReadArenaString(const char* ptr, int size,
+                                                ArenaStringAccessor s) {
+  auto* buffer = s.__resize_default_init(size);
+
+  if (size <= buffer_end_ + kSlopBytes - ptr) {
+    memcpy(buffer, ptr, size);
+    return ptr + size;
+  }
 
-  int size = ReadSize(&ptr);
+  return AppendSize(ptr, size, [&](const char* p, int s) {
+    memcpy(buffer, p, s);
+    buffer += s;
+  });
+}
+
+// FixedSizeArena entry
+const char* EpsCopyInputStream::ReadArenaString(const char* ptr,
+                                                ArenaStringAccessor s) {
+  auto size = ReadSize(&ptr);
   if (!ptr) return nullptr;
+  return ReadArenaString(ptr, size, s);
+}
 
-  auto* str = s->NewString(arena);
-  ptr = ReadString(ptr, size, str);
-  GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-  return ptr;
+const char* EpsCopyInputStream::ReadArenaString(const char* ptr,
+                                                MaybeArenaStringAccessor s) {
+  if (s.arena() != nullptr) {
+    return ReadArenaString(ptr, static_cast<ArenaStringAccessor&>(s));
+  }
+
+  auto size = ReadSize(&ptr);
+  if (!ptr) return nullptr;
+  return ReadString(ptr, size, s.underlying());
 }
 
 }  // namespace internal
diff --git a/src/google/protobuf/arenastring.h b/src/google/protobuf/arenastring.h
index 0c1c4e271..54ff21e61 100644
--- a/src/google/protobuf/arenastring.h
+++ b/src/google/protobuf/arenastring.h
@@ -17,6 +17,7 @@
 #include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "google/protobuf/arena.h"
+#include "google/protobuf/arenastring_impl.h"
 #include "google/protobuf/explicitly_constructed.h"
 #include "google/protobuf/port.h"
 
@@ -321,6 +322,11 @@ struct PROTOBUF_EXPORT ArenaStringPtr {
   // default value is lazily initialized.
   std::string* Mutable(Arena* arena);
   std::string* Mutable(const LazyString& default_value, Arena* arena);
+  // Returns a mutable arenastring when arena != nullptr
+  // keep FixedSizeArena state
+  MaybeArenaStringAccessor MutableAccessor(Arena* arena);
+  MaybeArenaStringAccessor MutableAccessor(const LazyString& default_value,
+                                           Arena* arena);
 
   // Gets a mutable pointer with unspecified contents.
   // This function is identical to Mutable(), except it is optimized for the
@@ -398,14 +404,16 @@ struct PROTOBUF_EXPORT ArenaStringPtr {
       auto* s = new std::string(std::forward<Args>(args)...);
       return tagged_ptr_.SetAllocated(s);
     } else {
-      auto* s = Arena::Create<std::string>(arena, std::forward<Args>(args)...);
-      return tagged_ptr_.SetMutableArena(s);
+      // Initialize to FixedSizeArena state
+      auto* s = ArenaStringAccessor::create(arena, std::forward<Args>(args)...)
+                    .underlying();
+      return tagged_ptr_.SetFixedSizeArena(s);
     }
   }
 
   TaggedStringPtr tagged_ptr_;
 
-  bool IsFixedSizeArena() const { return false; }
+  bool IsFixedSizeArena() const { return tagged_ptr_.IsFixedSizeArena(); }
 
   // Swaps tagged pointer without debug hardening. This is to allow python
   // protobuf to maintain pointer stability even in DEBUG builds.
@@ -414,6 +422,13 @@ struct PROTOBUF_EXPORT ArenaStringPtr {
     std::swap(lhs->tagged_ptr_, rhs->tagged_ptr_);
   }
 
+  // Universal accessor for Allocated/MutableArena/FixedSizeArena state
+  PROTOBUF_ALWAYS_INLINE
+  inline MaybeArenaStringAccessor Accessor(Arena* arena) {
+    return MaybeArenaStringAccessor(
+        tagged_ptr_.IsFixedSizeArena() ? arena : nullptr, tagged_ptr_.Get());
+  }
+
   friend class ::google::protobuf::internal::SwapFieldHelper;
   friend class TcParser;
 
@@ -522,8 +537,7 @@ inline PROTOBUF_NDEBUG_INLINE void ArenaStringPtr::InternalSwap(
 }
 
 inline void ArenaStringPtr::ClearNonDefaultToEmpty() {
-  // Unconditionally mask away the tag.
-  tagged_ptr_.Get()->clear();
+  MaybeArenaStringAccessor::clear(tagged_ptr_.Get());
 }
 
 inline std::string* ArenaStringPtr::UnsafeMutablePointer() {
diff --git a/src/google/protobuf/arenastring_impl.h b/src/google/protobuf/arenastring_impl.h
new file mode 100644
index 000000000..140d280f6
--- /dev/null
+++ b/src/google/protobuf/arenastring_impl.h
@@ -0,0 +1,907 @@
+#pragma once
+
+// Feature check macro
+#define GOOGLE_PROTOBUF_HAS_DONATED_STRING 1
+
+#include "google/protobuf/arena.h"
+#if defined(__has_include) && __has_include("google/protobuf/config.h")
+#include "google/protobuf/config.h"
+#endif
+
+#include "absl/strings/internal/resize_uninitialized.h"
+#include "absl/strings/str_format.h"
+#include "google/protobuf/port_def.inc"
+
+namespace google {
+namespace protobuf {
+
+namespace internal {
+
+#if __GLIBCXX__
+#if _GLIBCXX_USE_CXX11_ABI
+struct StdStringRep {
+  char* data;
+  uint64_t size;
+  union {
+    uint64_t capacity;
+    char local[16];
+  };
+};
+#else                  // !_GLIBCXX_USE_CXX11_ABI
+struct StdStringRep {
+  uint64_t size;
+  uint64_t capacity;
+  int32_t refcount;
+  uint32_t gap;
+  char data[0];
+};
+#endif                 // !_GLIBCXX_USE_CXX11_ABI
+#elif _LIBCPP_VERSION  // && !__GLIBCXX__
+#if _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
+static_assert(false, "don not support _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT yet");
+#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
+#if _LIBCPP_BIG_ENDIAN
+static_assert(false, "don not support _LIBCPP_BIG_ENDIAN yet");
+#endif  // _LIBCPP_BIG_ENDIAN
+union StdStringRep {
+  struct {
+    typename ::std::string::size_type capacity;
+    typename ::std::string::size_type size;
+    typename ::std::string::pointer data;
+  } long_format;
+  struct {
+    uint8_t size;
+    typename ::std::string::value_type data[0];
+  } shot_format;
+
+  inline bool is_long() const noexcept { return shot_format.size & 0x01; }
+
+  inline ::std::string::size_type long_capacity() const noexcept {
+    return long_format.capacity & ~static_cast<::std::string::size_type>(0x01);
+  }
+};
+#endif  // _LIBCPP_VERSION && !__GLIBCXX__
+}  // namespace internal
+
+// Wrap a full arenastring pointer and arena it belongs to.
+// provide function make it look like a string*
+//
+// Full arenastring itself and it's dynamic content both placed on arena
+class ArenaStringAccessor {
+ public:
+  using value_type = ::std::string::value_type;
+  using traits_type = ::std::string::traits_type;
+  using allocator_type = ::std::string::allocator_type;
+  using size_type = ::std::string::size_type;
+  using difference_type = ::std::string::difference_type;
+  using reference = ::std::string::reference;
+  using const_reference = ::std::string::const_reference;
+  using pointer = ::std::string::pointer;
+  using const_pointer = ::std::string::const_pointer;
+  using iterator = pointer;
+  using const_iterator = const_pointer;
+  using reverse_iterator = ::std::reverse_iterator<iterator>;
+  using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;
+
+  // Disable default constructor and default operator=
+  ArenaStringAccessor() = delete;
+  inline ArenaStringAccessor(ArenaStringAccessor&&) noexcept = default;
+  inline ArenaStringAccessor(const ArenaStringAccessor&) noexcept = default;
+  ArenaStringAccessor& operator=(ArenaStringAccessor&&) = delete;
+  ArenaStringAccessor& operator=(const ArenaStringAccessor&) = delete;
+  inline ~ArenaStringAccessor() noexcept = default;
+
+  // Assign
+  inline ArenaStringAccessor& operator=(::absl::string_view other) noexcept;
+  inline ArenaStringAccessor& assign(::absl::string_view other) noexcept;
+  inline ArenaStringAccessor& assign(const_pointer data,
+                                     size_type size) noexcept;
+
+  // Element access
+  inline reference operator[](size_type position) noexcept;
+  inline const_reference operator[](size_type position) const noexcept;
+  inline const_pointer data() const noexcept;
+  inline const_pointer c_str() const noexcept;
+  inline operator ::absl::string_view() const noexcept;
+  inline operator const ::std::string&() const noexcept;
+
+  // Iterators
+  inline iterator begin() noexcept;
+  inline const_iterator begin() const noexcept;
+  inline const_iterator cbegin() const noexcept;
+  inline iterator end() noexcept;
+  inline const_iterator end() const noexcept;
+  inline const_iterator cend() const noexcept;
+
+  // Capacity
+  inline bool empty() const noexcept;
+  inline size_type size() const noexcept;
+  inline void reserve(size_type required_capacity) noexcept;
+  inline size_type capacity() const noexcept;
+
+  // Modifiers
+  inline void clear() noexcept;
+  inline void push_back(value_type c) noexcept;
+  inline ArenaStringAccessor& append(::absl::string_view sv) noexcept;
+  inline ArenaStringAccessor& append(const_pointer append_data,
+                                     size_type append_size) noexcept;
+  inline ArenaStringAccessor& operator+=(char ch) noexcept;
+  inline ArenaStringAccessor& operator+=(::absl::string_view sv) noexcept;
+  inline void resize(size_type new_size) noexcept;
+  inline void resize(size_type new_size, value_type c) noexcept;
+  inline void swap(ArenaStringAccessor other) noexcept;
+
+  // Operations
+  inline int compare(::absl::string_view other) const noexcept;
+
+  ////////////////////////////////////////////////////////////////////////////
+  // Special functions
+  // Create string on arena
+  inline static ArenaStringAccessor create(Arena* arena) noexcept;
+  template <typename T>
+  inline static ArenaStringAccessor create(Arena* arena, T&& value) noexcept;
+  // Swap strings both on **same** arena or both not on arena
+  inline static void swap(::std::string* left, ::std::string* right) noexcept;
+  // Wrap constructor
+  inline ArenaStringAccessor(Arena* arena, ::std::string* ptr) noexcept;
+  inline Arena* arena() const noexcept;
+  inline ::std::string* underlying() const noexcept;
+  // Support absl::strings_internal::STLStringResizeUninitialized
+  inline char* __resize_default_init(size_type new_size) noexcept;
+  ////////////////////////////////////////////////////////////////////////////
+
+ private:
+  inline internal::StdStringRep& representation() noexcept;
+
+  inline pointer qualified_buffer(size_type required_capacity) noexcept;
+  inline pointer qualified_buffer(size_type required_capacity,
+                                  size_type predict_capacity) noexcept;
+  inline pointer writable_buffer() noexcept;
+  inline pointer recreate_buffer(size_type capacity) noexcept;
+
+  inline void set_size(size_type size) noexcept;
+  inline void set_size_and_terminator(size_type size) noexcept;
+
+  Arena* _arena{nullptr};
+  ::std::string* _ptr{nullptr};
+};
+
+class MaybeArenaStringAccessor : public ArenaStringAccessor {
+ public:
+  using ArenaStringAccessor::ArenaStringAccessor;
+  inline MaybeArenaStringAccessor(const ArenaStringAccessor& other) noexcept;
+
+  // Assign
+  template <typename T>
+  inline MaybeArenaStringAccessor& operator=(T&& other) noexcept;
+  // Deal with assign string specially. Try to keep copy on write state when
+  // using old abi.
+  inline MaybeArenaStringAccessor& operator=(
+      const ::std::string& other) noexcept;
+  inline MaybeArenaStringAccessor& operator=(::std::string& other) noexcept;
+  inline MaybeArenaStringAccessor& operator=(::std::string&& other) noexcept;
+  // Support api of ArenaStringPtr and InlinedStringField
+  template <typename T>
+  inline MaybeArenaStringAccessor& operator=(
+      ::std::reference_wrapper<T> other) noexcept;
+  template <typename T>
+  inline MaybeArenaStringAccessor& assign(T&& other) noexcept;
+  inline MaybeArenaStringAccessor& assign(const_pointer data,
+                                          size_type size) noexcept;
+  inline MaybeArenaStringAccessor& assign(const ::std::string& other) noexcept;
+  inline MaybeArenaStringAccessor& assign(::std::string& other) noexcept;
+  inline MaybeArenaStringAccessor& assign(::std::string&& other) noexcept;
+  template <typename T>
+  inline MaybeArenaStringAccessor& assign(
+      ::std::reference_wrapper<T> other) noexcept;
+
+  // Element access
+  inline reference operator[](size_type position) noexcept;
+  using ArenaStringAccessor::operator[];
+  using ArenaStringAccessor::c_str;
+  using ArenaStringAccessor::data;
+  using ArenaStringAccessor::operator ::absl::string_view;
+  using ArenaStringAccessor::operator const ::std::string&;
+
+  // Iterators
+  inline iterator begin() noexcept;
+  using ArenaStringAccessor::begin;
+  using ArenaStringAccessor::cbegin;
+  inline iterator end() noexcept;
+  using ArenaStringAccessor::cend;
+  using ArenaStringAccessor::end;
+
+  // Capacity
+  using ArenaStringAccessor::empty;
+  using ArenaStringAccessor::size;
+  inline void reserve(size_type required_capacity) noexcept;
+  using ArenaStringAccessor::capacity;
+
+  // Modifiers
+  inline void clear() noexcept;
+  inline void push_back(value_type c) noexcept;
+  inline MaybeArenaStringAccessor& append(::absl::string_view sv) noexcept;
+  inline MaybeArenaStringAccessor& append(const_pointer append_data,
+                                          size_type append_size) noexcept;
+  inline MaybeArenaStringAccessor& operator+=(char ch) noexcept;
+  inline MaybeArenaStringAccessor& operator+=(::absl::string_view sv) noexcept;
+  inline void resize(size_type new_size) noexcept;
+  inline void resize(size_type new_size, value_type c) noexcept;
+  using ArenaStringAccessor::swap;
+
+  ////////////////////////////////////////////////////////////////////////////
+  // Special functions
+  // Create string maybe on arena
+  inline static MaybeArenaStringAccessor create(Arena* arena) noexcept;
+  template <typename T>
+  inline static MaybeArenaStringAccessor create(Arena* arena,
+                                                T&& value) noexcept;
+  // Clear string maybe on arena
+  inline static void clear(::std::string* ptr) noexcept;
+  // Wrap constructor
+  inline MaybeArenaStringAccessor(::std::string* string) noexcept;
+  using ArenaStringAccessor::arena;
+  using ArenaStringAccessor::underlying;
+  // Support absl::strings_internal::STLStringResizeUninitialized
+  inline void __resize_default_init(size_type new_size) noexcept;
+  // Make operator* and operator-> both to self to imitate a string*
+  inline MaybeArenaStringAccessor* operator->() noexcept;
+  inline const MaybeArenaStringAccessor* operator->() const noexcept;
+  inline MaybeArenaStringAccessor& operator*() noexcept;
+  inline const MaybeArenaStringAccessor& operator*() const noexcept;
+  // Destroy string if not on arena
+  inline void destroy() noexcept;
+  // Also support absl::Format(MaybeArenaStringAccessor, ...)
+  inline operator ::absl::FormatRawSink() noexcept;
+  ////////////////////////////////////////////////////////////////////////////
+
+ private:
+  // Support absl::Format(MaybeArenaStringAccessor*, ...)
+  friend inline void AbslFormatFlush(MaybeArenaStringAccessor* accessor,
+                                     ::absl::string_view sv) noexcept {
+    accessor->append(sv.data(), sv.size());
+  }
+};
+
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+using MutableStringType = MaybeArenaStringAccessor;
+using MutableStringReferenceType = MaybeArenaStringAccessor;
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+using MutableStringType = ::std::string*;
+using MutableStringReferenceType = ::std::string&;
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+
+////////////////////////////////////////////////////////////////////////////////
+// ArenaStringAccessor begin
+inline ArenaStringAccessor& ArenaStringAccessor::operator=(
+    ::absl::string_view other) noexcept {
+  return assign(other.data(), other.size());
+}
+
+inline ArenaStringAccessor& ArenaStringAccessor::assign(
+    ::absl::string_view other) noexcept {
+  return assign(other.data(), other.size());
+}
+
+inline ArenaStringAccessor& ArenaStringAccessor::assign(
+    const_pointer data, size_type size) noexcept {
+  auto buffer = qualified_buffer(size);
+  set_size(size);
+  __builtin_memcpy(buffer, data, size);
+  buffer[size] = '\0';
+  return *this;
+}
+
+inline ArenaStringAccessor::reference ArenaStringAccessor::operator[](
+    size_type position) noexcept {
+  return writable_buffer()[position];
+}
+
+inline ArenaStringAccessor::const_reference ArenaStringAccessor::operator[](
+    size_type position) const noexcept {
+  return data()[position];
+}
+
+inline ArenaStringAccessor::const_pointer ArenaStringAccessor::data()
+    const noexcept {
+  return c_str();
+}
+
+inline ArenaStringAccessor::const_pointer ArenaStringAccessor::c_str()
+    const noexcept {
+  return static_cast<const ::std::string*>(_ptr)->c_str();
+}
+
+inline ArenaStringAccessor::operator ::absl::string_view() const noexcept {
+  return ::absl::string_view(data(), size());
+}
+
+inline ArenaStringAccessor::operator const ::std::string&() const noexcept {
+  return *_ptr;
+}
+
+inline ArenaStringAccessor::iterator ArenaStringAccessor::begin() noexcept {
+  return iterator(writable_buffer());
+}
+
+inline ArenaStringAccessor::const_iterator ArenaStringAccessor::begin()
+    const noexcept {
+  return cbegin();
+}
+
+inline ArenaStringAccessor::const_iterator ArenaStringAccessor::cbegin()
+    const noexcept {
+  return const_iterator(data());
+}
+
+inline ArenaStringAccessor::iterator ArenaStringAccessor::end() noexcept {
+  return iterator(writable_buffer() + size());
+}
+
+inline ArenaStringAccessor::const_iterator ArenaStringAccessor::end()
+    const noexcept {
+  return cend();
+}
+
+inline ArenaStringAccessor::const_iterator ArenaStringAccessor::cend()
+    const noexcept {
+  return const_iterator(data() + size());
+}
+
+inline bool ArenaStringAccessor::empty() const noexcept {
+  return _ptr->empty();
+}
+
+inline ArenaStringAccessor::size_type ArenaStringAccessor::size()
+    const noexcept {
+  return _ptr->size();
+}
+
+inline void ArenaStringAccessor::reserve(size_type required_capacity) noexcept {
+  if (required_capacity > capacity()) {
+    auto origin_size = size();
+    recreate_buffer(required_capacity);
+    set_size_and_terminator(origin_size);
+  }
+}
+
+inline ArenaStringAccessor::size_type ArenaStringAccessor::capacity()
+    const noexcept {
+  return _ptr->capacity();
+}
+
+inline void ArenaStringAccessor::clear() noexcept {
+  set_size_and_terminator(0);
+}
+
+inline void ArenaStringAccessor::push_back(value_type c) noexcept {
+  auto origin_size = size();
+  auto buffer = qualified_buffer(origin_size + 1, origin_size << 1);
+  set_size(origin_size + 1);
+  buffer[origin_size] = c;
+  buffer[origin_size + 1] = '\0';
+}
+
+inline ArenaStringAccessor& ArenaStringAccessor::append(
+    ::absl::string_view sv) noexcept {
+  return append(sv.data(), sv.size());
+}
+
+inline ArenaStringAccessor& ArenaStringAccessor::append(
+    const_pointer append_data, size_type append_size) noexcept {
+  auto origin_size = size();
+  auto buffer = qualified_buffer(origin_size + append_size);
+  set_size(origin_size + append_size);
+  __builtin_memcpy(buffer + origin_size, append_data, append_size);
+  buffer[origin_size + append_size] = '\0';
+  return *this;
+}
+
+inline ArenaStringAccessor& ArenaStringAccessor::operator+=(char ch) noexcept {
+  push_back(ch);
+  return *this;
+}
+
+inline ArenaStringAccessor& ArenaStringAccessor::operator+=(
+    ::absl::string_view sv) noexcept {
+  return append(sv.data(), sv.size());
+}
+
+inline void ArenaStringAccessor::resize(size_type new_size) noexcept {
+  resize(new_size, '\0');
+}
+
+inline void ArenaStringAccessor::resize(size_type new_size,
+                                        value_type c) noexcept {
+  auto origin_size = size();
+  auto buffer = qualified_buffer(new_size);
+  set_size_and_terminator(new_size);
+  if (new_size > origin_size) {
+    __builtin_memset(buffer + origin_size, c, new_size - origin_size);
+  }
+}
+
+inline void ArenaStringAccessor::swap(ArenaStringAccessor other) noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+  auto tmp = representation().data;
+  *reinterpret_cast<pointer*>(_ptr) = other.representation().data;
+  *reinterpret_cast<pointer*>(other._ptr) = tmp;
+#else   // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+  _ptr->swap(*other._ptr);
+#endif  // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+inline int ArenaStringAccessor::compare(
+    ::absl::string_view other) const noexcept {
+  return static_cast<::absl::string_view>(*this).compare(other);
+}
+
+inline ArenaStringAccessor ArenaStringAccessor::create(Arena* arena) noexcept {
+  auto ptr = reinterpret_cast<::std::string*>(
+      arena->AllocateAligned(sizeof(::std::string)));
+  new (ptr)::std::string();
+  return ArenaStringAccessor(arena, ptr);
+}
+
+template <typename T>
+inline ArenaStringAccessor ArenaStringAccessor::create(Arena* arena,
+                                                       T&& value) noexcept {
+  return create(arena) = ::std::forward<T>(value);
+}
+
+inline void ArenaStringAccessor::swap(::std::string* left,
+                                      ::std::string* right) noexcept {
+  ArenaStringAccessor(nullptr, left).swap(ArenaStringAccessor(nullptr, right));
+}
+
+inline ArenaStringAccessor::ArenaStringAccessor(Arena* arena,
+                                                ::std::string* ptr) noexcept
+    : _arena(arena), _ptr(ptr) {}
+
+inline Arena* ArenaStringAccessor::arena() const noexcept { return _arena; }
+inline ::std::string* ArenaStringAccessor::underlying() const noexcept {
+  return _ptr;
+}
+
+inline char* ArenaStringAccessor::__resize_default_init(
+    size_type new_size) noexcept {
+  auto buffer = qualified_buffer(new_size);
+  set_size_and_terminator(new_size);
+  return buffer;
+}
+
+inline internal::StdStringRep& ArenaStringAccessor::representation() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+  return *(*reinterpret_cast<internal::StdStringRep**>(_ptr) - 1);
+#else   // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+  return *reinterpret_cast<internal::StdStringRep*>(_ptr);
+#endif  // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+inline ArenaStringAccessor::pointer ArenaStringAccessor::qualified_buffer(
+    size_type required_capacity, size_type predict_capacity) noexcept {
+  return required_capacity <= capacity() ? writable_buffer()
+                                         : recreate_buffer(predict_capacity);
+}
+
+inline ArenaStringAccessor::pointer ArenaStringAccessor::qualified_buffer(
+    size_type required_capacity) noexcept {
+  return qualified_buffer(required_capacity, required_capacity);
+}
+
+inline ArenaStringAccessor::pointer
+ArenaStringAccessor::writable_buffer() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+  return representation().data;
+#else   // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+  return &(*_ptr)[0];
+#endif  // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+inline ArenaStringAccessor::pointer ArenaStringAccessor::recreate_buffer(
+    size_type capacity) noexcept {
+#if __GLIBCXX__
+  size_t buffer_size = capacity + 1;
+  buffer_size = (buffer_size + 7) & static_cast<size_t>(-8);
+  capacity = buffer_size - 1;
+#if _GLIBCXX_USE_CXX11_ABI
+  auto buffer = reinterpret_cast<char*>(_arena->AllocateAligned(buffer_size));
+  __builtin_memcpy(buffer, data(), size());
+  auto& rep = representation();
+  rep.data = buffer;
+  rep.capacity = capacity;
+  return buffer;
+#else   // !_GLIBCXX_USE_CXX11_ABI
+  auto rep = reinterpret_cast<StdStringRep*>(
+      _arena->AllocateAligned(sizeof(StdStringRep) + buffer_size));
+  rep->capacity = capacity;
+  rep->refcount = -1;
+  __builtin_memcpy(rep->data, data(), size());
+  *reinterpret_cast<pointer*>(_ptr) = rep->data;
+  return rep->data;
+#endif  // !_GLIBCXX_USE_CXX11_ABI
+#else   // !__GLIBCXX__
+  capacity = (capacity + 16) & static_cast<size_type>(-16);
+  auto buffer = reinterpret_cast<pointer>(_arena->AllocateAligned(capacity));
+  __builtin_memcpy(buffer, data(), size());
+  auto& rep = representation();
+  rep.long_format.data = buffer;
+  rep.long_format.capacity = capacity + 1;
+  return rep.long_format.data;
+#endif  // !__GLIBCXX__
+}
+
+inline void ArenaStringAccessor::set_size(size_type size) noexcept {
+#if __GLIBCXX__
+  auto& rep = representation();
+  rep.size = size;
+#else   // !__GLIBCXX__
+  auto& rep = representation();
+  if (rep.is_long()) {
+    rep.long_format.size = size;
+  } else {
+    rep.shot_format.size = size << 1;
+  }
+#endif  // !__GLIBCXX__
+}
+
+inline void ArenaStringAccessor::set_size_and_terminator(
+    size_type size) noexcept {
+#if __GLIBCXX__
+  auto& rep = representation();
+  rep.size = size;
+  rep.data[size] = '\0';
+#else   // !__GLIBCXX__
+  auto& rep = representation();
+  if (rep.is_long()) {
+    rep.long_format.size = size;
+    rep.long_format.data[size] = '\0';
+  } else {
+    rep.shot_format.size = size << 1;
+    rep.shot_format.data[size] = '\0';
+  }
+#endif  // !__GLIBCXX__
+}
+
+inline bool operator==(const ArenaStringAccessor& left,
+                       const ArenaStringAccessor& right) noexcept {
+  return *left.underlying() == *right.underlying();
+}
+
+inline bool operator==(::absl::string_view left,
+                       const ArenaStringAccessor& right) noexcept {
+  return left == *right.underlying();
+}
+
+inline bool operator==(const ArenaStringAccessor& left,
+                       ::absl::string_view right) noexcept {
+  return *left.underlying() == right;
+}
+
+inline bool operator!=(const ArenaStringAccessor& left,
+                       const ArenaStringAccessor& right) noexcept {
+  return !(left == right);
+}
+
+inline bool operator!=(::absl::string_view left,
+                       const ArenaStringAccessor& right) noexcept {
+  return !(left == right);
+}
+
+inline bool operator!=(const ArenaStringAccessor& left,
+                       ::absl::string_view right) noexcept {
+  return !(left == right);
+}
+
+inline bool operator<(const ArenaStringAccessor& left,
+                      const ArenaStringAccessor& right) noexcept {
+  return *left.underlying() < *right.underlying();
+}
+
+inline bool operator<(::absl::string_view left,
+                      const ArenaStringAccessor& right) noexcept {
+  return left < *right.underlying();
+}
+
+inline bool operator<(const ArenaStringAccessor& left,
+                      ::absl::string_view right) noexcept {
+  return *left.underlying() < right;
+}
+
+inline bool operator<=(const ArenaStringAccessor& left,
+                       const ArenaStringAccessor& right) noexcept {
+  return *left.underlying() <= *right.underlying();
+}
+
+inline bool operator<=(::absl::string_view left,
+                       const ArenaStringAccessor& right) noexcept {
+  return left <= *right.underlying();
+}
+
+inline bool operator<=(const ArenaStringAccessor& left,
+                       ::absl::string_view right) noexcept {
+  return *left.underlying() <= right;
+}
+
+inline bool operator>(const ArenaStringAccessor& left,
+                      const ArenaStringAccessor& right) noexcept {
+  return *left.underlying() > *right.underlying();
+}
+
+inline bool operator>(::absl::string_view left,
+                      const ArenaStringAccessor& right) noexcept {
+  return left > *right.underlying();
+}
+
+inline bool operator>(const ArenaStringAccessor& left,
+                      ::absl::string_view right) noexcept {
+  return *left.underlying() > right;
+}
+
+inline bool operator>=(const ArenaStringAccessor& left,
+                       const ArenaStringAccessor& right) noexcept {
+  return *left.underlying() >= *right.underlying();
+}
+
+inline bool operator>=(::absl::string_view left,
+                       const ArenaStringAccessor& right) noexcept {
+  return left >= *right.underlying();
+}
+
+inline bool operator>=(const ArenaStringAccessor& left,
+                       ::absl::string_view right) noexcept {
+  return *left.underlying() >= right;
+}
+// ArenaStringAccessor end
+////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////
+// MaybeArenaStringAccessor begin
+inline MaybeArenaStringAccessor::MaybeArenaStringAccessor(
+    const ArenaStringAccessor& other) noexcept
+    : ArenaStringAccessor(other) {}
+
+template <typename T>
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::operator=(
+    T&& other) noexcept {
+  return assign(::std::forward<T>(other));
+}
+template <typename T>
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::assign(
+    T&& other) noexcept {
+  ::absl::string_view sv(::std::forward<T>(other));
+  return assign(sv.data(), sv.size());
+}
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::assign(
+    const_pointer data, size_type size) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::assign(data, size);
+  } else {
+    underlying()->assign(data, size);
+  }
+  return *this;
+}
+
+// Deal with assign string specially. Try to keep copy on write state when
+// using old abi
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::operator=(
+    const ::std::string& other) noexcept {
+  return assign(other);
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::assign(
+    const ::std::string& other) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::assign(other);
+  } else {
+    underlying()->assign(other);
+  }
+  return *this;
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::operator=(
+    ::std::string& other) noexcept {
+  return assign(static_cast<const ::std::string&>(other));
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::assign(
+    ::std::string& other) noexcept {
+  return assign(static_cast<const ::std::string&>(other));
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::operator=(
+    ::std::string&& other) noexcept {
+  return assign(::std::move(other));
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::assign(
+    ::std::string&& other) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::assign(other);
+  } else {
+    underlying()->assign(::std::move(other));
+  }
+  return *this;
+}
+
+template <typename T>
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::operator=(
+    ::std::reference_wrapper<T> other) noexcept {
+  return assign(other);
+}
+
+template <typename T>
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::assign(
+    ::std::reference_wrapper<T> other) noexcept {
+  return assign(other.get());
+}
+
+inline MaybeArenaStringAccessor::reference MaybeArenaStringAccessor::operator[](
+    size_type position) noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+  if (representation().refcount >= 0) {
+    return underlying()->operator[](position);
+  }
+#endif  // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+  return ArenaStringAccessor::operator[](position);
+}
+
+inline MaybeArenaStringAccessor::iterator
+MaybeArenaStringAccessor::begin() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+  if (representation().refcount >= 0) {
+    return underlying()->begin();
+  }
+#endif  // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+  return ArenaStringAccessor::begin();
+}
+
+inline MaybeArenaStringAccessor::iterator
+MaybeArenaStringAccessor::end() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+  if (representation().refcount >= 0) {
+    return underlying()->end();
+  }
+#endif  // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+  return ArenaStringAccessor::end();
+}
+
+inline void MaybeArenaStringAccessor::reserve(
+    size_type required_capacity) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::reserve(required_capacity);
+  } else if (required_capacity > capacity()) {
+    underlying()->reserve(required_capacity);
+  }
+}
+
+inline void MaybeArenaStringAccessor::clear() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+  if (representation().refcount <= 0) {
+    ArenaStringAccessor::clear();
+    return;
+  }
+#endif  // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+  underlying()->clear();
+}
+
+inline void MaybeArenaStringAccessor::push_back(value_type c) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::push_back(c);
+  } else {
+    underlying()->push_back(c);
+  }
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::append(
+    ::absl::string_view sv) noexcept {
+  return append(sv.data(), sv.size());
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::append(
+    const_pointer data, size_type size) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::append(data, size);
+  } else {
+    underlying()->append(data, size);
+  }
+  return *this;
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::operator+=(
+    char ch) noexcept {
+  push_back(ch);
+  return *this;
+}
+
+inline MaybeArenaStringAccessor& MaybeArenaStringAccessor::operator+=(
+    ::absl::string_view sv) noexcept {
+  return append(sv.data(), sv.size());
+}
+
+inline void MaybeArenaStringAccessor::resize(size_type size) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::resize(size);
+  } else {
+    underlying()->resize(size);
+  }
+}
+
+inline void MaybeArenaStringAccessor::resize(size_type size,
+                                             value_type c) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::resize(size, c);
+  } else {
+    underlying()->resize(size, c);
+  }
+}
+
+inline MaybeArenaStringAccessor MaybeArenaStringAccessor::create(
+    Arena* arena) noexcept {
+  if (arena != nullptr) {
+    return ArenaStringAccessor::create(arena);
+  } else {
+    return MaybeArenaStringAccessor(new ::std::string);
+  }
+}
+
+template <typename T>
+inline MaybeArenaStringAccessor MaybeArenaStringAccessor::create(
+    Arena* arena, T&& value) noexcept {
+  return create(arena) = ::std::forward<T>(value);
+}
+
+inline void MaybeArenaStringAccessor::clear(::std::string* ptr) noexcept {
+  MaybeArenaStringAccessor(ptr).clear();
+}
+
+inline MaybeArenaStringAccessor::MaybeArenaStringAccessor(
+    ::std::string* string) noexcept
+    : ArenaStringAccessor(nullptr, string) {}
+
+inline void MaybeArenaStringAccessor::__resize_default_init(
+    size_type new_size) noexcept {
+  if (arena() != nullptr) {
+    ArenaStringAccessor::__resize_default_init(new_size);
+  } else {
+    ::absl::strings_internal::STLStringResizeUninitialized(underlying(),
+                                                           new_size);
+  }
+}
+
+inline MaybeArenaStringAccessor*
+MaybeArenaStringAccessor::operator->() noexcept {
+  return this;
+}
+
+inline const MaybeArenaStringAccessor* MaybeArenaStringAccessor::operator->()
+    const noexcept {
+  return this;
+}
+
+inline MaybeArenaStringAccessor&
+MaybeArenaStringAccessor::operator*() noexcept {
+  return *this;
+}
+
+inline const MaybeArenaStringAccessor& MaybeArenaStringAccessor::operator*()
+    const noexcept {
+  return *this;
+}
+
+inline void MaybeArenaStringAccessor::destroy() noexcept {
+  if (arena() == nullptr) {
+    delete underlying();
+  }
+}
+
+inline MaybeArenaStringAccessor::operator ::absl::FormatRawSink() noexcept {
+  return ::absl::FormatRawSink(this);
+}
+// MaybeArenaStringAccessor end
+////////////////////////////////////////////////////////////////////////////////
+
+}  // namespace protobuf
+}  // namespace google
+
+#include "google/protobuf/port_undef.inc"
diff --git a/src/google/protobuf/arenastring_impl_unittest.cc b/src/google/protobuf/arenastring_impl_unittest.cc
new file mode 100644
index 000000000..a14cc312b
--- /dev/null
+++ b/src/google/protobuf/arenastring_impl_unittest.cc
@@ -0,0 +1,1512 @@
+#include "google/protobuf/arenastring_impl.h"
+
+#include "google/protobuf/arena.h"
+#include "google/protobuf/descriptor.pb.h"
+#include "google/protobuf/reflection.h"
+#include "google/protobuf/unittest_arenastring.pb.h"
+#include "google/protobuf/unittest_arenastring_mutable.pb.h"
+#include "google/protobuf/unittest_proto3_arenastring.pb.h"
+#include "google/protobuf/unittest_proto3_arenastring_mutable.pb.h"
+#include "gtest/gtest.h"
+
+using ::google::protobuf::Arena;
+using ::google::protobuf::ArenaOptions;
+using ::google::protobuf::MaybeArenaStringAccessor;
+using ::google::protobuf::RepeatedPtrField;
+
+using ::proto2_arenastring_unittest::ArenaProto2;
+using ::proto2_arenastring_unittest::ArenaProto2Extension;
+using ::proto2_arenastring_unittest::Proto2;
+using ::proto2_arenastring_unittest::Proto2Extension;
+using ::proto3_arenastring_unittest::ArenaProto3;
+using ::proto3_arenastring_unittest::Proto3;
+
+class ArenaStringTest : public ::testing::Test {
+ public:
+  virtual void SetUp() {
+    ArenaOptions options;
+    options.initial_block = buffer;
+    options.initial_block_size = sizeof(buffer);
+    arena = new Arena(options);
+  }
+
+  virtual void TearDown() { delete arena; }
+
+  void assert_address_on_arena(const void* address, bool on) {
+    if (on) {
+      ASSERT_GE(address, buffer);
+      ASSERT_LT(address, buffer + sizeof(buffer));
+    } else {
+      ASSERT_TRUE(address < buffer || address >= buffer + sizeof(buffer));
+    }
+  }
+
+  void assert_on_arena(const ::std::string& string, bool on, bool content_on) {
+    assert_address_on_arena(&string, on);
+    if (string.capacity() > 0) {
+      assert_address_on_arena(string.c_str(), content_on);
+      assert_address_on_arena(string.c_str() + string.capacity() - 1,
+                              content_on);
+    }
+  }
+
+  void assert_on_arena(const ::std::string& string, bool on) {
+    assert_on_arena(string, on, on);
+  }
+
+  char buffer[1L << 20];
+  Arena* arena;
+};
+
+::std::string tiny_string = ::std::string(::std::string().capacity(), 'x');
+::std::string short_string = ::std::string(::std::string().capacity() + 1, 'y');
+::std::string long_string = ::std::string(::std::string().capacity() + 64, 'z');
+
+template <typename T>
+static void create_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  {
+    auto accessor = MaybeArenaStringAccessor::create(arena);
+    ASSERT_TRUE(accessor.empty());
+    assert_on_arena(accessor);
+    accessor.destroy();
+  }
+  {
+    auto accessor = MaybeArenaStringAccessor::create(arena, tiny_string);
+    ASSERT_EQ(tiny_string, accessor);
+    ASSERT_EQ(tiny_string, accessor.c_str());
+    assert_on_arena(accessor);
+    accessor.destroy();
+  }
+  {
+    auto accessor = MaybeArenaStringAccessor::create(arena, short_string);
+    ASSERT_EQ(short_string, accessor);
+    ASSERT_EQ(short_string, accessor.c_str());
+    assert_on_arena(accessor);
+    accessor.destroy();
+  }
+  {
+    auto accessor = MaybeArenaStringAccessor::create(arena, long_string);
+    ASSERT_EQ(long_string, accessor);
+    ASSERT_EQ(long_string, accessor.c_str());
+    assert_on_arena(accessor);
+    accessor.destroy();
+  }
+}
+TEST_F(ArenaStringTest, create_on_arena) {
+  create_on_arena(*this, arena);
+  create_on_arena(*this, nullptr);
+}
+
+template <typename T>
+static void correct_data_size_and_capacity(T& t, Arena* arena) {
+  for (size_t i = 0; i < long_string.size(); ++i) {
+    auto accessor = MaybeArenaStringAccessor::create(arena);
+    accessor.assign(long_string.c_str(), i);
+    ASSERT_EQ(i, ::strlen(accessor.c_str()));
+    ASSERT_EQ(0, ::memcmp(long_string.c_str(), accessor.c_str(), i));
+    ASSERT_EQ(i, accessor.size());
+    ASSERT_LE(i, accessor.capacity());
+    accessor.destroy();
+  }
+}
+TEST_F(ArenaStringTest, correct_data_size_and_capacity) {
+  correct_data_size_and_capacity(*this, arena);
+  correct_data_size_and_capacity(*this, nullptr);
+}
+
+template <typename T>
+static void assign_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto accessor = MaybeArenaStringAccessor::create(arena);
+  accessor = tiny_string;
+  ASSERT_EQ(tiny_string, accessor);
+  ASSERT_STREQ(tiny_string.c_str(), accessor.c_str());
+  assert_on_arena(accessor);
+  accessor = short_string;
+  ASSERT_EQ(short_string, accessor);
+  ASSERT_STREQ(short_string.c_str(), accessor.c_str());
+  assert_on_arena(accessor);
+  accessor = long_string;
+  ASSERT_EQ(long_string, accessor);
+  ASSERT_STREQ(long_string.c_str(), accessor.c_str());
+  assert_on_arena(accessor);
+  accessor = short_string;
+  ASSERT_EQ(short_string, accessor);
+  ASSERT_STREQ(short_string.c_str(), accessor.c_str());
+  assert_on_arena(accessor);
+  accessor.destroy();
+}
+TEST_F(ArenaStringTest, assign_on_arena) {
+  assign_on_arena(*this, arena);
+  assign_on_arena(*this, nullptr);
+}
+
+template <typename T>
+static void reserve_keep_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto accessor = MaybeArenaStringAccessor::create(arena);
+  accessor = tiny_string;
+  accessor.reserve(short_string.size());
+  ASSERT_EQ(tiny_string, accessor);
+  ASSERT_STREQ(tiny_string.c_str(), accessor.c_str());
+  ASSERT_LE(short_string.size(), accessor.capacity());
+  assert_on_arena(accessor);
+  accessor.reserve(long_string.size());
+  ASSERT_EQ(tiny_string, accessor);
+  ASSERT_STREQ(tiny_string.c_str(), accessor.c_str());
+  ASSERT_LE(long_string.size(), accessor.capacity());
+  assert_on_arena(accessor);
+  accessor.destroy();
+}
+TEST_F(ArenaStringTest, reserve_keep_on_arena) {
+  reserve_keep_on_arena(*this, arena);
+  reserve_keep_on_arena(*this, nullptr);
+}
+
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+TEST_F(ArenaStringTest, do_not_copy_on_write) {
+  auto std_string = new ::std::string();
+  auto half_arena_string = Arena::Create<::std::string>(arena);
+  auto accessor = MaybeArenaStringAccessor::create(arena);
+  auto* arena_string = &(const ::std::string&)accessor;
+  ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+  ASSERT_EQ(::std::string(*half_arena_string).c_str(),
+            half_arena_string->c_str());
+  ASSERT_EQ(::std::string(*arena_string).c_str(), arena_string->c_str());
+  std_string->assign(long_string);
+  half_arena_string->assign(long_string);
+  accessor->assign(long_string);
+  ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+  ASSERT_EQ(::std::string(*half_arena_string).c_str(),
+            half_arena_string->c_str());
+  ASSERT_NE(::std::string(*arena_string).c_str(), arena_string->c_str());
+  std_string->clear();
+  half_arena_string->clear();
+  accessor->clear();
+  ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+  ASSERT_EQ(::std::string(*half_arena_string).c_str(),
+            half_arena_string->c_str());
+  ASSERT_NE(::std::string(*arena_string).c_str(), arena_string->c_str());
+  std_string->assign(short_string);
+  half_arena_string->assign(short_string);
+  accessor->assign(short_string);
+  ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+  ASSERT_EQ(::std::string(*half_arena_string).c_str(),
+            half_arena_string->c_str());
+  ASSERT_NE(::std::string(*arena_string).c_str(), arena_string->c_str());
+  std_string->append(long_string);
+  half_arena_string->append(long_string);
+  accessor->append(long_string);
+  ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+  ASSERT_EQ(::std::string(*half_arena_string).c_str(),
+            half_arena_string->c_str());
+  ASSERT_NE(::std::string(*arena_string).c_str(), arena_string->c_str());
+  delete std_string;
+}
+#endif  // __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+
+TEST_F(ArenaStringTest, support_resize) {
+  auto accessor = MaybeArenaStringAccessor::create(arena, "10086");
+  accessor.resize(4);
+  auto data = &accessor[0];
+  ASSERT_EQ(4, accessor.size());
+  ASSERT_EQ("1008", accessor);
+  ASSERT_EQ(data, accessor.data());
+  accessor.resize(2);
+  data = &accessor[0];
+  ASSERT_EQ(2, accessor.size());
+  ASSERT_EQ("10", accessor);
+  ASSERT_EQ(data, accessor.data());
+  accessor.resize(4);
+  data = &accessor[0];
+  ASSERT_EQ(4, accessor.size());
+  ASSERT_EQ(::absl::string_view("10\0\0", 4), accessor);
+  ASSERT_EQ(data, accessor.data());
+  accessor.destroy();
+}
+
+TEST_F(ArenaStringTest, support_resize_uninitialized) {
+  auto accessor = MaybeArenaStringAccessor::create(arena, "10086");
+  ::absl::strings_internal::STLStringResizeUninitialized(&accessor, 4);
+  auto data = &accessor[0];
+  ASSERT_EQ(4, accessor.size());
+  ASSERT_EQ("1008", accessor);
+  ASSERT_EQ(data, accessor.data());
+  ::absl::strings_internal::STLStringResizeUninitialized(&accessor, 2);
+  data = &accessor[0];
+  ASSERT_EQ(2, accessor.size());
+  ASSERT_EQ("10", accessor);
+  ASSERT_EQ(data, accessor.data());
+  ::absl::strings_internal::STLStringResizeUninitialized(&accessor, 4);
+  data = &accessor[0];
+  ASSERT_EQ(4, accessor.size());
+  ASSERT_EQ(::absl::string_view("10\08", 4), accessor);
+  ASSERT_EQ(data, accessor.data());
+  accessor.destroy();
+}
+
+TEST_F(ArenaStringTest, support_absl_format) {
+  auto accessor = MaybeArenaStringAccessor::create(arena, "hello world");
+  ::absl::Format(accessor, " +%d", 10086);
+  ASSERT_EQ("hello world +10086", accessor);
+  accessor.destroy();
+}
+
+template <typename T>
+static void alter_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto accessor = MaybeArenaStringAccessor::create(arena);
+  accessor.push_back('x');
+  assert_on_arena(accessor);
+  accessor.clear();
+  assert_on_arena(accessor);
+  accessor.append(tiny_string);
+  assert_on_arena(accessor);
+  accessor.append(short_string);
+  assert_on_arena(accessor);
+  ::std::string tmp_string(long_string.c_str());
+  auto tmp_ptr = tmp_string.c_str();
+  accessor = ::std::move(tmp_string);
+  ASSERT_EQ(long_string, accessor);
+  if (arena != nullptr)
+    ASSERT_NE(tmp_ptr, accessor.c_str());
+  else {
+    ASSERT_EQ(tmp_ptr, accessor.c_str());
+  }
+  accessor.destroy();
+}
+TEST_F(ArenaStringTest, alter_on_arena) {
+  alter_on_arena(*this, arena);
+  alter_on_arena(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void direct_set_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->set_s(short_string);
+  ASSERT_EQ(short_string, m->s());
+  assert_on_arena(m->s());
+  m->set_b(long_string.c_str(), long_string.size());
+  ASSERT_EQ(long_string, m->b());
+  assert_on_arena(m->b());
+  m->set_os(long_string);
+  ASSERT_EQ(long_string, m->os());
+  assert_on_arena(m->os());
+  m->set_ob(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->ob());
+  assert_on_arena(m->ob());
+  m->add_rs(short_string);
+  ASSERT_EQ(short_string, m->rs(0));
+  assert_on_arena(m->rs(0));
+  m->add_rs(long_string);
+  ASSERT_EQ(long_string, m->rs(1));
+  assert_on_arena(m->rs(1));
+  m->add_rb(long_string.c_str(), long_string.size());
+  ASSERT_EQ(long_string, m->rb(0));
+  assert_on_arena(m->rb(0));
+  m->add_rb(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->rb(1));
+  assert_on_arena(m->rb(1));
+  m->set_ons(short_string);
+  ASSERT_EQ(short_string, m->ons());
+  assert_on_arena(m->ons());
+  m->set_onb(long_string.c_str(), long_string.size());
+  ASSERT_FALSE(m->has_ons());
+  ASSERT_TRUE(m->ons().empty());
+  ASSERT_EQ(long_string, m->onb());
+  assert_on_arena(m->onb());
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, direct_set_on_arena) {
+  direct_set_on_arena<Proto3>(*this, arena);
+  direct_set_on_arena<Proto3>(*this, nullptr);
+  direct_set_on_arena<ArenaProto3>(*this, arena);
+  direct_set_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void direct_set_on_arena_pb2(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->set_s(short_string);
+  ASSERT_EQ(short_string, m->s());
+  assert_on_arena(m->s());
+  m->set_b(long_string.c_str(), long_string.size());
+  ASSERT_EQ(long_string, m->b());
+  assert_on_arena(m->b());
+  m->set_qs(long_string);
+  ASSERT_EQ(long_string, m->qs());
+  assert_on_arena(m->qs());
+  m->set_qb(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->qb());
+  assert_on_arena(m->qb());
+  m->set_ds(short_string);
+  ASSERT_EQ(short_string, m->ds());
+  assert_on_arena(m->ds());
+  m->set_db(long_string.c_str(), long_string.size());
+  ASSERT_EQ(long_string, m->db());
+  assert_on_arena(m->db());
+  m->add_rs(long_string);
+  ASSERT_EQ(long_string, m->rs(0));
+  assert_on_arena(m->rs(0));
+  m->add_rs(short_string);
+  ASSERT_EQ(short_string, m->rs(1));
+  assert_on_arena(m->rs(1));
+  m->add_rb(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->rb(0));
+  assert_on_arena(m->rb(0));
+  m->add_rb(long_string.c_str(), long_string.size());
+  ASSERT_EQ(long_string, m->rb(1));
+  assert_on_arena(m->rb(1));
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, direct_set_on_arena_pb2) {
+  direct_set_on_arena_pb2<Proto2>(*this, arena);
+  direct_set_on_arena_pb2<Proto2>(*this, nullptr);
+  direct_set_on_arena_pb2<ArenaProto2>(*this, arena);
+  direct_set_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void set_again_keep_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->set_s(short_string);
+  m->set_s(long_string);
+  ASSERT_EQ(long_string, m->s());
+  assert_on_arena(m->s());
+  m->set_b(long_string.c_str(), long_string.size());
+  m->set_b(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->b());
+  assert_on_arena(m->b());
+  m->set_os(short_string);
+  m->set_os(long_string);
+  ASSERT_EQ(long_string, m->os());
+  assert_on_arena(m->os());
+  m->set_ob(long_string.c_str(), long_string.size());
+  m->set_ob(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->ob());
+  assert_on_arena(m->ob());
+  m->set_ons(short_string);
+  m->set_ons(long_string);
+  ASSERT_EQ(long_string, m->ons());
+  assert_on_arena(m->ons());
+  m->set_onb(long_string.c_str(), long_string.size());
+  m->set_onb(short_string.c_str(), short_string.size());
+  ASSERT_FALSE(m->has_ons());
+  ASSERT_TRUE(m->ons().empty());
+  ASSERT_EQ(short_string, m->onb());
+  assert_on_arena(m->onb());
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, set_again_keep_on_arena) {
+  set_again_keep_on_arena<Proto3>(*this, arena);
+  set_again_keep_on_arena<Proto3>(*this, nullptr);
+  set_again_keep_on_arena<ArenaProto3>(*this, arena);
+  set_again_keep_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void set_again_keep_on_arena_pb2(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->set_s(short_string);
+  m->set_s(long_string);
+  ASSERT_EQ(long_string, m->s());
+  assert_on_arena(m->s());
+  m->set_b(long_string.c_str(), long_string.size());
+  m->set_b(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->b());
+  assert_on_arena(m->b());
+  m->set_qs(short_string);
+  m->set_qs(long_string);
+  ASSERT_EQ(long_string, m->qs());
+  assert_on_arena(m->qs());
+  m->set_qb(long_string.c_str(), long_string.size());
+  m->set_qb(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->qb());
+  assert_on_arena(m->qb());
+  m->set_ds(short_string);
+  m->set_ds(long_string);
+  ASSERT_EQ(long_string, m->ds());
+  assert_on_arena(m->ds());
+  m->set_db(long_string.c_str(), long_string.size());
+  m->set_db(short_string.c_str(), short_string.size());
+  ASSERT_EQ(short_string, m->db());
+  assert_on_arena(m->db());
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, set_again_keep_on_arena_pb2) {
+  set_again_keep_on_arena_pb2<Proto2>(*this, arena);
+  set_again_keep_on_arena_pb2<Proto2>(*this, nullptr);
+  set_again_keep_on_arena_pb2<ArenaProto2>(*this, arena);
+  set_again_keep_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void clear_keep_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->set_s(short_string);
+  auto* ps = &m->s();
+  m->set_b(long_string);
+  auto* pb = &m->b();
+  m->add_rs(short_string);
+  auto* prs = &m->rs(0);
+  m->add_rb(long_string);
+  auto* prb = &m->rb(0);
+  m->set_ons(short_string);
+  m->set_onb(long_string);
+  m->Clear();
+  m->set_s(long_string);
+  assert_on_arena(m->s());
+  ASSERT_EQ(ps, &m->s());
+  m->set_b(short_string);
+  assert_on_arena(m->b());
+  ASSERT_EQ(pb, &m->b());
+  m->add_rs(long_string);
+  assert_on_arena(m->rs(0));
+  ASSERT_EQ(prs, &m->rs(0));
+  m->add_rb(short_string);
+  assert_on_arena(m->rb(0));
+  ASSERT_EQ(prb, &m->rb(0));
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, clear_keep_on_arena) {
+  clear_keep_on_arena<Proto2>(*this, arena);
+  clear_keep_on_arena<Proto2>(*this, nullptr);
+  clear_keep_on_arena<ArenaProto2>(*this, arena);
+  clear_keep_on_arena<ArenaProto2>(*this, nullptr);
+  clear_keep_on_arena<Proto3>(*this, arena);
+  clear_keep_on_arena<Proto3>(*this, nullptr);
+  clear_keep_on_arena<ArenaProto3>(*this, arena);
+  clear_keep_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void clear_keep_on_arena_pb2(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena);
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->set_ds(short_string);
+  auto* pds = &m->ds();
+  m->set_db(long_string);
+  auto* pdb = &m->db();
+  m->set_qs(short_string);
+  auto* pqs = &m->qs();
+  m->set_qb(long_string);
+  auto* pqb = &m->qb();
+  m->Clear();
+  m->set_ds(long_string);
+  assert_on_arena(m->ds());
+  ASSERT_EQ(pds, &m->ds());
+  m->set_db(short_string);
+  assert_on_arena(m->db());
+  ASSERT_EQ(pdb, &m->db());
+  m->set_qs(long_string);
+  assert_on_arena(m->qs());
+  ASSERT_EQ(pqs, &m->qs());
+  m->set_qb(short_string);
+  assert_on_arena(m->qb());
+  ASSERT_EQ(pqb, &m->qb());
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, clear_keep_on_arena_pb2) {
+  clear_keep_on_arena_pb2<Proto2>(*this, arena);
+  clear_keep_on_arena_pb2<Proto2>(*this, nullptr);
+  clear_keep_on_arena_pb2<ArenaProto2>(*this, arena);
+  clear_keep_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void parse_and_merge_on_arena(T& t, Arena* farena, Arena* tarena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, tarena, tarena);
+  };
+  auto assert_mutable_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(
+        s, tarena,
+        tarena &&
+            M().GetDescriptor()->file()->options().cc_mutable_donated_string());
+  };
+  ::std::string string;
+  auto* fm = Arena::CreateMessage<M>(farena);
+  auto* tm = Arena::CreateMessage<M>(tarena);
+  fm->set_s(short_string);
+  fm->set_b(long_string);
+  fm->set_os(short_string);
+  fm->set_ob(long_string);
+  fm->set_ons(short_string);
+  fm->set_onb(long_string);
+  fm->add_rs(short_string);
+  fm->add_rs(long_string);
+  fm->add_rb(long_string);
+  fm->add_rb(short_string);
+  fm->SerializeToString(&string);
+  ASSERT_TRUE(fm->SerializeToString(&string));
+  ASSERT_TRUE(tm->ParseFromString(string));
+  ASSERT_EQ(short_string, tm->s());
+  assert_on_arena(tm->s());
+  ASSERT_EQ(long_string, tm->b());
+  assert_on_arena(tm->b());
+  ASSERT_EQ(short_string, tm->os());
+  assert_on_arena(tm->os());
+  ASSERT_EQ(long_string, tm->ob());
+  assert_on_arena(tm->ob());
+  ASSERT_EQ(long_string, tm->onb());
+  assert_on_arena(tm->onb());
+  ASSERT_EQ(short_string, tm->rs(0));
+  assert_on_arena(tm->rs(0));
+  ASSERT_EQ(long_string, tm->rs(1));
+  assert_on_arena(tm->rs(1));
+  ASSERT_EQ(long_string, tm->rb(0));
+  assert_on_arena(tm->rb(0));
+  ASSERT_EQ(short_string, tm->rb(1));
+  assert_on_arena(tm->rb(1));
+  tm->mutable_s()->assign(short_string);
+  assert_mutable_on_arena(tm->s());
+  tm->mutable_rs(0)->assign(long_string);
+  tm->mutable_rb(1)->assign(long_string);
+  ASSERT_TRUE(tm->ParseFromString(string));
+  ASSERT_EQ(short_string, tm->s());
+  assert_mutable_on_arena(tm->s());
+  ASSERT_EQ(long_string, tm->b());
+  assert_on_arena(tm->b());
+  ASSERT_EQ(long_string, tm->onb());
+  assert_on_arena(tm->onb());
+  ASSERT_EQ(short_string, tm->rs(0));
+  assert_mutable_on_arena(tm->rs(0));
+  ASSERT_EQ(long_string, tm->rs(1));
+  assert_on_arena(tm->rs(1));
+  ASSERT_EQ(long_string, tm->rb(0));
+  assert_on_arena(tm->rb(0));
+  ASSERT_EQ(short_string, tm->rb(1));
+  assert_mutable_on_arena(tm->rb(1));
+  tm->CopyFrom(*fm);
+  ASSERT_EQ(short_string, tm->s());
+  assert_mutable_on_arena(tm->s());
+  ASSERT_EQ(long_string, tm->b());
+  assert_on_arena(tm->b());
+  ASSERT_EQ(long_string, tm->onb());
+  assert_on_arena(tm->onb());
+  ASSERT_EQ(short_string, tm->rs(0));
+  assert_mutable_on_arena(tm->rs(0));
+  ASSERT_EQ(long_string, tm->rs(1));
+  assert_on_arena(tm->rs(1));
+  ASSERT_EQ(long_string, tm->rb(0));
+  assert_on_arena(tm->rb(0));
+  ASSERT_EQ(short_string, tm->rb(1));
+  assert_mutable_on_arena(tm->rb(1));
+  if (!tarena) {
+    delete tm;
+  }
+  if (!farena) {
+    delete fm;
+  }
+}
+TEST_F(ArenaStringTest, parse_and_merge_on_arena) {
+  parse_and_merge_on_arena<Proto3>(*this, arena, arena);
+  parse_and_merge_on_arena<Proto3>(*this, arena, nullptr);
+  parse_and_merge_on_arena<Proto3>(*this, nullptr, arena);
+  parse_and_merge_on_arena<Proto3>(*this, nullptr, nullptr);
+  parse_and_merge_on_arena<ArenaProto3>(*this, arena, arena);
+  parse_and_merge_on_arena<ArenaProto3>(*this, arena, nullptr);
+  parse_and_merge_on_arena<ArenaProto3>(*this, nullptr, arena);
+  parse_and_merge_on_arena<ArenaProto3>(*this, nullptr, nullptr);
+}
+
+template <typename M, typename T>
+static void swap_on_arena(T& t, Arena* farena, Arena* tarena) {
+  auto assert_nn_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, tarena, tarena);
+  };
+  auto assert_nm_on_arena = [&](const ::std::string& s) {
+    if (tarena != farena) {
+      t.assert_on_arena(s, tarena, tarena);
+    } else {
+      t.assert_on_arena(s, tarena,
+                        tarena && M().GetDescriptor()
+                                      ->file()
+                                      ->options()
+                                      .cc_mutable_donated_string());
+    }
+  };
+  auto assert_mn_on_arena = [&](const ::std::string& s) {
+    if (tarena != farena) {
+      t.assert_on_arena(s, tarena, tarena);
+    } else {
+      t.assert_on_arena(s, tarena, tarena);
+    }
+  };
+  auto assert_mm_on_arena = [&](const ::std::string& s) {
+    if (tarena != farena) {
+      t.assert_on_arena(s, tarena, tarena);
+    } else {
+      t.assert_on_arena(s, tarena,
+                        tarena && M().GetDescriptor()
+                                      ->file()
+                                      ->options()
+                                      .cc_mutable_donated_string());
+    }
+  };
+  auto* fm = Arena::CreateMessage<M>(farena);
+  auto* tm = Arena::CreateMessage<M>(tarena);
+  fm->set_s(short_string);
+  fm->mutable_b()->assign(long_string);
+  fm->mutable_ons()->assign(short_string);
+  fm->add_rs(short_string);
+  fm->add_rs()->assign(long_string);
+  fm->add_rb(long_string);
+  fm->add_rb()->assign(short_string);
+
+  tm->set_s(long_string);
+  tm->set_b(short_string);
+  tm->set_onb(long_string);
+  tm->add_rs(long_string);
+  tm->add_rs(short_string);
+  tm->add_rb()->assign(short_string);
+  tm->add_rb()->assign(long_string);
+
+  tm->Swap(fm);
+  ASSERT_EQ(short_string, tm->s());
+  assert_nn_on_arena(tm->s());
+  ASSERT_EQ(long_string, tm->b());
+  assert_nm_on_arena(tm->b());
+  ASSERT_EQ(short_string, tm->ons());
+  assert_nm_on_arena(tm->ons());
+  ASSERT_EQ(short_string, tm->rs(0));
+  assert_nn_on_arena(tm->rs(0));
+  ASSERT_EQ(long_string, tm->rs(1));
+  assert_nm_on_arena(tm->rs(1));
+  ASSERT_EQ(long_string, tm->rb(0));
+  assert_mn_on_arena(tm->rb(0));
+  ASSERT_EQ(short_string, tm->rb(1));
+  assert_mm_on_arena(tm->rb(1));
+  if (!tarena) {
+    delete tm;
+  }
+  if (!farena) {
+    delete fm;
+  }
+  fm = Arena::CreateMessage<M>(farena);
+  tm = Arena::CreateMessage<M>(tarena);
+  fm->mutable_s()->assign(short_string);
+  fm->set_b(long_string);
+  tm->mutable_s()->assign(long_string);
+  tm->mutable_b()->assign(short_string);
+
+  tm->Swap(fm);
+  ASSERT_EQ(short_string, tm->s());
+  assert_mm_on_arena(tm->s());
+  ASSERT_EQ(long_string, tm->b());
+  assert_mn_on_arena(tm->b());
+  if (!tarena) {
+    delete tm;
+  }
+  if (!farena) {
+    delete fm;
+  }
+}
+TEST_F(ArenaStringTest, swap_on_arena) {
+  swap_on_arena<Proto3>(*this, arena, arena);
+  swap_on_arena<Proto3>(*this, arena, nullptr);
+  swap_on_arena<Proto3>(*this, nullptr, arena);
+  swap_on_arena<Proto3>(*this, nullptr, nullptr);
+  swap_on_arena<ArenaProto3>(*this, arena, arena);
+  swap_on_arena<ArenaProto3>(*this, arena, nullptr);
+  swap_on_arena<ArenaProto3>(*this, nullptr, arena);
+  swap_on_arena<ArenaProto3>(*this, nullptr, nullptr);
+  swap_on_arena<Proto2>(*this, arena, arena);
+  swap_on_arena<Proto2>(*this, arena, nullptr);
+  swap_on_arena<Proto2>(*this, nullptr, arena);
+  swap_on_arena<Proto2>(*this, nullptr, nullptr);
+  swap_on_arena<ArenaProto2>(*this, arena, arena);
+  swap_on_arena<ArenaProto2>(*this, arena, nullptr);
+  swap_on_arena<ArenaProto2>(*this, nullptr, arena);
+  swap_on_arena<ArenaProto2>(*this, nullptr, nullptr);
+}
+
+template <typename M, typename T>
+static void set_allocated_on_arena(T& t, Arena* arena) {
+  auto cc_mutable_donated_string =
+      M().GetDescriptor()->file()->options().cc_mutable_donated_string();
+  auto m = Arena::CreateMessage<M>(arena);
+  {
+    auto s = new ::std::string{short_string};
+    auto c = s->c_str();
+    m->set_allocated_s(s);
+    ASSERT_NE(s, &m->s());
+    ASSERT_EQ(c, m->s().c_str());
+    t.assert_on_arena(m->s(), arena && cc_mutable_donated_string, false);
+    auto cs = &m->s();
+    c = cs->c_str();
+    m->mutable_s()->assign(long_string);
+    ASSERT_EQ(cs, &m->s());
+    ASSERT_NE(c, m->s().c_str());
+    t.assert_on_arena(m->s(), arena && cc_mutable_donated_string, false);
+  }
+  {
+    auto s = new ::std::string{short_string};
+    auto c = s->c_str();
+    m->set_b(long_string);
+    m->set_allocated_b(s);
+    ASSERT_NE(s, &m->b());
+    ASSERT_EQ(c, m->b().c_str());
+    t.assert_on_arena(m->b(), arena && cc_mutable_donated_string, false);
+  }
+  {
+    auto s = new ::std::string{long_string};
+    auto c = s->c_str();
+    m->mutable_ons()->assign(short_string);
+    m->set_allocated_ons(s);
+    ASSERT_EQ(s, &m->ons());
+    ASSERT_EQ(c, m->ons().c_str());
+    t.assert_on_arena(m->ons(), false, false);
+  }
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, set_allocated_on_arena) {
+  set_allocated_on_arena<Proto3>(*this, arena);
+  set_allocated_on_arena<Proto3>(*this, nullptr);
+  set_allocated_on_arena<ArenaProto3>(*this, arena);
+  set_allocated_on_arena<ArenaProto3>(*this, nullptr);
+  set_allocated_on_arena<Proto2>(*this, arena);
+  set_allocated_on_arena<Proto2>(*this, nullptr);
+  set_allocated_on_arena<ArenaProto2>(*this, arena);
+  set_allocated_on_arena<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void release_on_arena(T& t, Arena* arena) {
+  auto cc_mutable_donated_string =
+      M().GetDescriptor()->file()->options().cc_mutable_donated_string();
+  auto m = Arena::CreateMessage<M>(arena);
+  {
+    m->set_s(long_string);
+    auto s = &m->s();
+    auto c = s->c_str();
+    auto r = m->release_s();
+    if (arena || cc_mutable_donated_string) {
+      ASSERT_NE(s, r);
+    } else {
+      ASSERT_EQ(s, r);
+    }
+    if (arena) {
+      ASSERT_NE(c, r->c_str());
+    } else {
+      ASSERT_EQ(c, r->c_str());
+    }
+    ASSERT_EQ(long_string, *r);
+    delete r;
+  }
+  {
+    m->set_os(short_string);
+    auto s = &m->os();
+    auto c = s->c_str();
+    auto r = m->release_os();
+    if (arena || cc_mutable_donated_string) {
+      ASSERT_NE(s, r);
+    } else {
+      ASSERT_EQ(s, r);
+    }
+    if (arena) {
+      ASSERT_NE(c, r->c_str());
+    } else {
+      ASSERT_EQ(c, r->c_str());
+    }
+    ASSERT_EQ(short_string, *r);
+    delete r;
+  }
+  {
+    m->set_ons(long_string);
+    auto s = &m->ons();
+    auto c = s->c_str();
+    auto r = m->release_ons();
+    if (arena) {
+      ASSERT_NE(s, r);
+    } else {
+      ASSERT_EQ(s, r);
+    }
+    if (arena) {
+      ASSERT_NE(c, r->c_str());
+    } else {
+      ASSERT_EQ(c, r->c_str());
+    }
+    ASSERT_EQ(long_string, *r);
+    delete r;
+  }
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, release_on_arena) {
+  release_on_arena<Proto3>(*this, arena);
+  release_on_arena<Proto3>(*this, nullptr);
+  release_on_arena<ArenaProto3>(*this, arena);
+  release_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void release_on_arena_pb2(T& t, Arena* arena) {
+  auto cc_mutable_donated_string =
+      M().GetDescriptor()->file()->options().cc_mutable_donated_string();
+  auto m = Arena::CreateMessage<M>(arena);
+  {
+    m->set_s(long_string);
+    auto s = &m->s();
+    auto c = s->c_str();
+    auto r = m->release_s();
+    if (arena || cc_mutable_donated_string) {
+      ASSERT_NE(s, r);
+    } else {
+      ASSERT_EQ(s, r);
+    }
+    if (arena) {
+      ASSERT_NE(c, r->c_str());
+    } else {
+      ASSERT_EQ(c, r->c_str());
+    }
+    ASSERT_EQ(long_string, *r);
+    delete r;
+  }
+  {
+    m->set_qs(short_string);
+    auto s = &m->qs();
+    auto c = s->c_str();
+    auto r = m->release_qs();
+    if (arena || cc_mutable_donated_string) {
+      ASSERT_NE(s, r);
+    } else {
+      ASSERT_EQ(s, r);
+    }
+    if (arena) {
+      ASSERT_NE(c, r->c_str());
+    } else {
+      ASSERT_EQ(c, r->c_str());
+    }
+    ASSERT_EQ(short_string, *r);
+    delete r;
+  }
+  {
+    m->set_ds(long_string);
+    auto s = &m->ds();
+    auto c = s->c_str();
+    auto r = m->release_ds();
+    if (arena) {
+      ASSERT_NE(s, r);
+    } else {
+      ASSERT_EQ(s, r);
+    }
+    if (arena) {
+      ASSERT_NE(c, r->c_str());
+    } else {
+      ASSERT_EQ(c, r->c_str());
+    }
+    ASSERT_EQ(long_string, *r);
+    delete r;
+  }
+  {
+    m->set_ons(short_string);
+    auto s = &m->ons();
+    auto c = s->c_str();
+    auto r = m->release_ons();
+    if (arena) {
+      ASSERT_NE(s, r);
+    } else {
+      ASSERT_EQ(s, r);
+    }
+    if (arena) {
+      ASSERT_NE(c, r->c_str());
+    } else {
+      ASSERT_EQ(c, r->c_str());
+    }
+    ASSERT_EQ(short_string, *r);
+    delete r;
+  }
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, release_on_arena_pb2) {
+  release_on_arena_pb2<Proto2>(*this, arena);
+  release_on_arena_pb2<Proto2>(*this, nullptr);
+  release_on_arena_pb2<ArenaProto2>(*this, arena);
+  release_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void reflect_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena, arena);
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  auto* r = m->GetReflection();
+  auto* d = m->GetDescriptor();
+  r->SetString(m, d->FindFieldByName("s"), long_string);
+  assert_on_arena(m->s());
+  assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("s"), nullptr));
+  r->SetString(m, d->FindFieldByName("os"), long_string);
+  assert_on_arena(m->os());
+  assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("os"), nullptr));
+  r->AddString(m, d->FindFieldByName("rs"), long_string);
+  assert_on_arena(m->rs(0));
+  assert_on_arena(
+      r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 0, nullptr));
+  r->SetRepeatedString(m, d->FindFieldByName("rs"), 0,
+                       long_string + long_string);
+  assert_on_arena(m->rs(0));
+  assert_on_arena(
+      r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 0, nullptr));
+  r->template GetMutableRepeatedFieldRef<::std::string>(
+       m, d->FindFieldByName("rs"))
+      .Add(long_string);
+  assert_on_arena(m->rs(1));
+  assert_on_arena(
+      r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 1, nullptr));
+  r->template GetMutableRepeatedFieldRef<::std::string>(
+       m, d->FindFieldByName("rs"))
+      .Set(1, long_string + long_string);
+  assert_on_arena(m->rs(1));
+  assert_on_arena(
+      r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 1, nullptr));
+  r->SetString(m, d->FindFieldByName("ons"), long_string);
+  assert_on_arena(m->ons());
+  assert_on_arena(
+      r->GetStringReference(*m, d->FindFieldByName("ons"), nullptr));
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, reflect_on_arena) {
+  reflect_on_arena<Proto3>(*this, arena);
+  reflect_on_arena<Proto3>(*this, nullptr);
+  reflect_on_arena<ArenaProto3>(*this, arena);
+  reflect_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void reflect_on_arena_pb2(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena, arena);
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  auto* r = m->GetReflection();
+  auto* d = m->GetDescriptor();
+  r->SetString(m, d->FindFieldByName("s"), long_string);
+  assert_on_arena(m->s());
+  assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("s"), nullptr));
+  r->SetString(m, d->FindFieldByName("qs"), long_string);
+  assert_on_arena(m->qs());
+  assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("qs"), nullptr));
+  r->SetString(m, d->FindFieldByName("ds"), long_string);
+  assert_on_arena(m->ds());
+  assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("ds"), nullptr));
+  r->AddString(m, d->FindFieldByName("rs"), long_string);
+  assert_on_arena(m->rs(0));
+  assert_on_arena(
+      r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 0, nullptr));
+  r->SetRepeatedString(m, d->FindFieldByName("rs"), 0,
+                       long_string + long_string);
+  assert_on_arena(m->rs(0));
+  assert_on_arena(
+      r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 0, nullptr));
+  r->template GetMutableRepeatedFieldRef<::std::string>(
+       m, d->FindFieldByName("rs"))
+      .Add(long_string);
+  assert_on_arena(m->rs(1));
+  assert_on_arena(
+      r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 1, nullptr));
+  r->template GetMutableRepeatedFieldRef<::std::string>(
+       m, d->FindFieldByName("rs"))
+      .Set(1, long_string + long_string);
+  assert_on_arena(m->rs(1));
+  assert_on_arena(
+      r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 1, nullptr));
+  r->SetString(m, d->FindFieldByName("ons"), long_string);
+  assert_on_arena(m->ons());
+  assert_on_arena(
+      r->GetStringReference(*m, d->FindFieldByName("ons"), nullptr));
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, reflect_on_arena_pb2) {
+  reflect_on_arena_pb2<Proto2>(*this, arena);
+  reflect_on_arena_pb2<Proto2>(*this, nullptr);
+  reflect_on_arena_pb2<ArenaProto2>(*this, arena);
+  reflect_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void repeated_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena, arena);
+  };
+  auto assert_mutable_on_arena = [&](const ::std::string& s) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    t.assert_on_arena(s, arena, arena);
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    t.assert_on_arena(s, arena, false);
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  };
+  auto m = Arena::CreateMessage<M>(arena);
+  auto rs = m->mutable_rs();
+  rs->Add(::std::string(short_string));
+  ASSERT_EQ(short_string, rs->Get(0));
+  assert_on_arena(rs->Get(0));
+  rs->RemoveLast();
+  rs->Add(::std::string(long_string));
+  ASSERT_EQ(long_string, rs->Get(0));
+  assert_on_arena(rs->Get(0));
+  for (auto iter = m->rs().begin(); iter != m->rs().end(); ++iter) {
+    ASSERT_EQ(long_string, *iter);
+    assert_on_arena(*iter);
+  }
+  for (auto iter = rs->begin(); iter != rs->end(); ++iter) {
+    ASSERT_EQ(long_string, *iter);
+    assert_mutable_on_arena(*iter);
+  }
+  rs->Add(::std::string(short_string));
+  ASSERT_EQ(short_string, rs->Get(1));
+  assert_on_arena(rs->Get(1));
+  rs->Mutable(1)->assign(long_string);
+  ASSERT_EQ(long_string, rs->Get(1));
+  assert_mutable_on_arena(rs->Get(1));
+  rs->Add()->assign(long_string);
+  ASSERT_EQ(long_string, rs->Get(2));
+  assert_mutable_on_arena(rs->Get(2));
+  rs->Add(::std::string(long_string));
+  ASSERT_EQ(long_string, m->rs()[3]);
+  assert_on_arena(m->rs()[3]);
+  (*rs)[3].assign(long_string + long_string);
+  ASSERT_EQ(long_string + long_string, rs->Get(3));
+  assert_mutable_on_arena(rs->Get(3));
+  rs->Add(::std::string(long_string));
+  ASSERT_EQ(long_string, m->rs().at(4));
+  assert_on_arena(m->rs().at(4));
+  rs->at(4).assign(long_string + long_string);
+  ASSERT_EQ(long_string + long_string, rs->Get(4));
+  assert_mutable_on_arena(rs->Get(4));
+  rs->Add(::std::string(short_string));
+  ASSERT_EQ(short_string, rs->Get(5));
+  assert_on_arena(rs->Get(5));
+  rs->DeleteSubrange(1, 4);
+  ASSERT_EQ(2, rs->size());
+  if (!arena) {
+    delete m;
+  }
+  m = Arena::CreateMessage<M>(arena);
+  rs = m->mutable_rs();
+  M fm;
+  fm.add_rs(short_string);
+  fm.add_rs(long_string);
+  m->MergeFrom(fm);
+  ASSERT_EQ(short_string, rs->Get(0));
+  assert_on_arena(rs->Get(0));
+  ASSERT_EQ(long_string, rs->Get(1));
+  assert_on_arena(rs->Get(1));
+  {
+    ::std::string strs[2] = {short_string, long_string};
+    rs->Add(strs, strs + 2);
+    ASSERT_EQ(short_string, rs->Get(2));
+    assert_on_arena(rs->Get(2));
+    ASSERT_EQ(long_string, rs->Get(3));
+    assert_on_arena(rs->Get(3));
+  }
+  {
+    ::std::string strs[2] = {long_string, short_string};
+    rs->Assign(strs, strs + 2);
+    ASSERT_EQ(long_string, rs->Get(0));
+    assert_on_arena(rs->Get(0));
+    ASSERT_EQ(short_string, rs->Get(1));
+    assert_on_arena(rs->Get(1));
+  }
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, repeated_on_arena) {
+  repeated_on_arena<Proto2>(*this, arena);
+  repeated_on_arena<Proto2>(*this, nullptr);
+  repeated_on_arena<ArenaProto2>(*this, arena);
+  repeated_on_arena<ArenaProto2>(*this, nullptr);
+  repeated_on_arena<Proto3>(*this, arena);
+  repeated_on_arena<Proto3>(*this, nullptr);
+  repeated_on_arena<ArenaProto3>(*this, arena);
+  repeated_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void repeated_add_allocated_and_release_on_arena(T& t, Arena* arena) {
+  auto m = Arena::CreateMessage<M>(arena);
+  auto rs = m->mutable_rs();
+  {
+    auto s = new ::std::string(long_string);
+    auto c = s->c_str();
+    rs->AddAllocated(s);
+    ASSERT_EQ(s, &rs->Get(0));
+    ASSERT_EQ(c, rs->Get(0).c_str());
+    t.assert_on_arena(rs->Get(0), false, false);
+    s = new ::std::string(long_string);
+    c = s->c_str();
+    rs->AddAllocated(s);
+    ASSERT_EQ(s, &rs->Get(1));
+    ASSERT_EQ(c, rs->Get(1).c_str());
+    t.assert_on_arena(rs->Get(1), false, false);
+    rs->MutableAccessor(1)->assign(long_string + long_string);
+    ASSERT_EQ(s, &rs->Get(1));
+    ASSERT_NE(c, rs->Get(1).c_str());
+    t.assert_on_arena(rs->Get(1), false, false);
+    m->add_rs(long_string);
+  }
+  {
+    auto s = &m->rs(m->rs_size() - 1);
+    auto c = s->c_str();
+    auto r = rs->ReleaseLast();
+    ASSERT_EQ(long_string, *r);
+    if (arena) {
+      ASSERT_NE(s, r);
+      ASSERT_NE(c, r->c_str());
+    } else {
+      ASSERT_EQ(s, r);
+      ASSERT_EQ(c, r->c_str());
+    }
+    t.assert_on_arena(*r, false, false);
+    delete r;
+    s = &m->rs(m->rs_size() - 1);
+    c = s->c_str();
+    r = rs->ReleaseLast();
+    ASSERT_EQ(long_string + long_string, *r);
+    if (arena) {
+      ASSERT_NE(s, r);
+      ASSERT_EQ(c, r->c_str());
+    } else {
+      ASSERT_EQ(s, r);
+      ASSERT_EQ(c, r->c_str());
+    }
+    t.assert_on_arena(*r, false, false);
+    delete r;
+    s = &m->rs(m->rs_size() - 1);
+    c = s->c_str();
+    r = rs->ReleaseLast();
+    ASSERT_EQ(long_string, *r);
+    if (arena) {
+      ASSERT_NE(s, r);
+      ASSERT_EQ(c, r->c_str());
+    } else {
+      ASSERT_EQ(s, r);
+      ASSERT_EQ(c, r->c_str());
+    }
+    t.assert_on_arena(*r, false, false);
+    delete r;
+  }
+  {
+    auto mm = Arena::CreateMessage<M>(arena);
+    mm->mutable_rs()->AddString()->assign(long_string);
+    mm->mutable_rs()->AddAccessor()->assign(long_string);
+    auto s = &mm->rs(mm->rs_size() - 1);
+    auto c = s->c_str();
+    rs->UnsafeArenaAddAllocated(mm->mutable_rs()->UnsafeArenaReleaseLast());
+    auto ss = &m->rs(m->rs_size() - 1);
+    auto cc = ss->c_str();
+    ASSERT_EQ(*s, *ss);
+    ASSERT_EQ(s, ss);
+    ASSERT_EQ(c, cc);
+    t.assert_on_arena(*s, arena, arena);
+    s = &mm->rs(mm->rs_size() - 1);
+    c = s->c_str();
+    rs->UnsafeArenaAddAllocated(mm->mutable_rs()->UnsafeArenaReleaseLast());
+    ss = &m->rs(m->rs_size() - 1);
+    cc = ss->c_str();
+    ASSERT_EQ(*s, *ss);
+    ASSERT_EQ(s, ss);
+    ASSERT_EQ(c, cc);
+    t.assert_on_arena(*s, arena, false);
+    if (!arena) {
+      delete mm;
+    }
+  }
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, repeated_add_allocated_and_release_on_arena) {
+  repeated_add_allocated_and_release_on_arena<Proto2>(*this, arena);
+  repeated_add_allocated_and_release_on_arena<Proto2>(*this, nullptr);
+  repeated_add_allocated_and_release_on_arena<ArenaProto2>(*this, arena);
+  repeated_add_allocated_and_release_on_arena<ArenaProto2>(*this, nullptr);
+  repeated_add_allocated_and_release_on_arena<Proto3>(*this, arena);
+  repeated_add_allocated_and_release_on_arena<Proto3>(*this, nullptr);
+  repeated_add_allocated_and_release_on_arena<ArenaProto3>(*this, arena);
+  repeated_add_allocated_and_release_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void mutable_string_on_arena(T& t, Arena* arena) {
+  auto assert_mutable_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(
+        s, arena,
+        arena &&
+            M().GetDescriptor()->file()->options().cc_mutable_donated_string());
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->set_s(short_string);
+  m->mutable_s()->assign(long_string);
+  ASSERT_EQ(long_string, m->s());
+  assert_mutable_on_arena(m->s());
+  m->mutable_s()->assign(short_string);
+  ASSERT_EQ(short_string, m->s());
+  assert_mutable_on_arena(m->s());
+  m->mutable_s()->clear();
+  m->mutable_s()->push_back('x');
+  m->mutable_s()->append("10086");
+  ASSERT_EQ("x10086", m->s());
+  assert_mutable_on_arena(m->s());
+  m->set_ons(short_string);
+  m->mutable_ons()->assign(long_string);
+  ASSERT_EQ(long_string, m->ons());
+  assert_mutable_on_arena(m->ons());
+  m->mutable_ons()->assign(short_string);
+  ASSERT_EQ(short_string, m->ons());
+  assert_mutable_on_arena(m->ons());
+  m->mutable_ons()->clear();
+  m->mutable_ons()->push_back('x');
+  m->mutable_ons()->append("10086");
+  ASSERT_EQ("x10086", m->ons());
+  assert_mutable_on_arena(m->ons());
+  m->add_rs(short_string);
+  m->mutable_rs(0)->assign(long_string);
+  ASSERT_EQ(long_string, m->rs(0));
+  assert_mutable_on_arena(m->rs(0));
+  m->mutable_rs(0)->assign(short_string);
+  ASSERT_EQ(short_string, m->rs(0));
+  assert_mutable_on_arena(m->rs(0));
+  m->mutable_rs(0)->clear();
+  m->mutable_rs(0)->push_back('x');
+  m->mutable_rs(0)->append("10086");
+  ASSERT_EQ("x10086", m->rs(0));
+  assert_mutable_on_arena(m->rs(0));
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, mutable_string_on_arena) {
+  mutable_string_on_arena<Proto3>(*this, arena);
+  mutable_string_on_arena<Proto3>(*this, nullptr);
+  mutable_string_on_arena<ArenaProto3>(*this, arena);
+  mutable_string_on_arena<ArenaProto3>(*this, nullptr);
+  mutable_string_on_arena<Proto2>(*this, arena);
+  mutable_string_on_arena<Proto2>(*this, nullptr);
+  mutable_string_on_arena<ArenaProto2>(*this, arena);
+  mutable_string_on_arena<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void mutable_string_on_arena_pb2(T& t, Arena* arena) {
+  auto assert_mutable_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(
+        s, arena,
+        arena &&
+            M().GetDescriptor()->file()->options().cc_mutable_donated_string());
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->set_ds(short_string);
+  m->mutable_ds()->assign(long_string);
+  ASSERT_EQ(long_string, m->ds());
+  assert_mutable_on_arena(m->ds());
+  m->mutable_ds()->assign(short_string);
+  ASSERT_EQ(short_string, m->ds());
+  assert_mutable_on_arena(m->ds());
+  m->mutable_ds()->clear();
+  m->mutable_ds()->push_back('x');
+  m->mutable_ds()->append("10086");
+  ASSERT_EQ("x10086", m->ds());
+  assert_mutable_on_arena(m->ds());
+  m->set_qs(short_string);
+  m->mutable_qs()->assign(long_string);
+  ASSERT_EQ(long_string, m->qs());
+  assert_mutable_on_arena(m->qs());
+  m->mutable_qs()->assign(short_string);
+  ASSERT_EQ(short_string, m->qs());
+  assert_mutable_on_arena(m->qs());
+  m->mutable_qs()->clear();
+  m->mutable_qs()->push_back('x');
+  m->mutable_qs()->append("10086");
+  ASSERT_EQ("x10086", m->qs());
+  assert_mutable_on_arena(m->qs());
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, mutable_string_on_arena_pb2) {
+  mutable_string_on_arena_pb2<Proto2>(*this, arena);
+  mutable_string_on_arena_pb2<Proto2>(*this, nullptr);
+  mutable_string_on_arena_pb2<ArenaProto2>(*this, arena);
+  mutable_string_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename E, typename T>
+static void extension_on_arena(T& t, Arena* arena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, arena, arena);
+  };
+  auto assert_mutable_on_arena = [&](const ::std::string& s) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    t.assert_on_arena(s, arena, arena);
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    t.assert_on_arena(s, arena, false);
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  };
+  auto* m = Arena::CreateMessage<M>(arena);
+  m->SetExtension(E::es, short_string);
+  ASSERT_EQ(short_string, m->GetExtension(E::es));
+  assert_on_arena(m->GetExtension(E::es));
+  m->ClearExtension(E::es);
+  m->SetExtension(E::es, long_string);
+  ASSERT_EQ(long_string, m->GetExtension(E::es));
+  assert_on_arena(m->GetExtension(E::es));
+  m->MutableExtension(E::es)->append(long_string);
+  ASSERT_EQ(long_string + long_string, m->GetExtension(E::es));
+  assert_mutable_on_arena(m->GetExtension(E::es));
+  m->ClearExtension(E::es);
+  m->MutableExtension(E::es)->assign(long_string.c_str());
+  ASSERT_EQ(long_string, m->GetExtension(E::es));
+  ASSERT_LE(long_string.size() * 2, m->GetExtension(E::es).capacity());
+  assert_mutable_on_arena(m->GetExtension(E::es));
+  m->AddExtension(E::ers, long_string);
+  ASSERT_EQ(long_string, m->GetExtension(E::ers, 0));
+  assert_on_arena(m->GetExtension(E::ers, 0));
+  m->MutableExtension(E::ers, 0)->append(long_string);
+  ASSERT_EQ(long_string + long_string, m->GetExtension(E::ers, 0));
+  assert_mutable_on_arena(m->GetExtension(E::ers, 0));
+  if (!arena) {
+    delete m;
+  }
+}
+TEST_F(ArenaStringTest, extension_on_arena) {
+  extension_on_arena<Proto2, Proto2Extension>(*this, arena);
+  extension_on_arena<Proto2, Proto2Extension>(*this, nullptr);
+  extension_on_arena<ArenaProto2, ArenaProto2Extension>(*this, arena);
+  extension_on_arena<ArenaProto2, ArenaProto2Extension>(*this, nullptr);
+}
+
+template <typename M, typename E, typename T>
+static void extension_parse_and_merge_on_arena(T& t, Arena* farena,
+                                               Arena* tarena) {
+  auto assert_on_arena = [&](const ::std::string& s) {
+    t.assert_on_arena(s, tarena, tarena);
+  };
+  auto assert_mutable_on_arena = [&](const ::std::string& s) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    t.assert_on_arena(s, tarena, tarena);
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    t.assert_on_arena(s, tarena, false);
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  };
+  ::std::string string;
+  auto* fm = Arena::CreateMessage<M>(farena);
+  auto* tm = Arena::CreateMessage<M>(tarena);
+  tm->AddExtension(E::ers, short_string);
+  fm->SetExtension(E::es, short_string);
+  fm->set_qs(long_string);
+  fm->set_qb(long_string);
+  fm->set_qc(long_string);
+  fm->AddExtension(E::ers, long_string);
+  fm->AddExtension(E::ers, long_string);
+  ASSERT_TRUE(fm->SerializeToString(&string));
+  ASSERT_TRUE(tm->ParseFromString(string));
+  ASSERT_EQ(short_string, tm->GetExtension(E::es));
+  assert_on_arena(tm->GetExtension(E::es));
+  ASSERT_EQ(long_string, tm->GetExtension(E::ers, 0));
+  assert_on_arena(tm->GetExtension(E::ers, 0));
+  ASSERT_EQ(long_string, tm->GetExtension(E::ers, 1));
+  assert_on_arena(tm->GetExtension(E::ers, 1));
+  tm->MutableExtension(E::es)->assign(long_string.c_str());
+  tm->MutableExtension(E::ers, 0)->append(long_string);
+  ASSERT_TRUE(tm->ParseFromString(string));
+  ASSERT_EQ(short_string, tm->GetExtension(E::es));
+  assert_mutable_on_arena(tm->GetExtension(E::es));
+  ASSERT_EQ(long_string, tm->GetExtension(E::ers, 0));
+  assert_mutable_on_arena(tm->GetExtension(E::ers, 0));
+  ASSERT_EQ(long_string, tm->GetExtension(E::ers, 1));
+  assert_on_arena(tm->GetExtension(E::ers, 1));
+  if (!tarena) {
+    delete tm;
+  }
+  tm = Arena::CreateMessage<M>(tarena);
+  tm->MergeFrom(*fm);
+  ASSERT_EQ(short_string, tm->GetExtension(E::es));
+  assert_on_arena(tm->GetExtension(E::es));
+  ASSERT_EQ(long_string, tm->GetExtension(E::ers, 0));
+  assert_on_arena(tm->GetExtension(E::ers, 0));
+  ASSERT_EQ(long_string, tm->GetExtension(E::ers, 1));
+  assert_on_arena(tm->GetExtension(E::ers, 1));
+  tm->MutableExtension(E::es)->assign(long_string.c_str());
+  tm->MutableExtension(E::ers, 0)->append(long_string);
+  tm->CopyFrom(*fm);
+  ASSERT_EQ(short_string, tm->GetExtension(E::es));
+  assert_mutable_on_arena(tm->GetExtension(E::es));
+  ASSERT_EQ(long_string, tm->GetExtension(E::ers, 0));
+  assert_mutable_on_arena(tm->GetExtension(E::ers, 0));
+  ASSERT_EQ(long_string, tm->GetExtension(E::ers, 1));
+  assert_on_arena(tm->GetExtension(E::ers, 1));
+  if (!farena) {
+    delete fm;
+  }
+  if (!tarena) {
+    delete tm;
+  }
+}
+TEST_F(ArenaStringTest, extension_parse_and_merge_on_arena) {
+  extension_parse_and_merge_on_arena<Proto2, Proto2Extension>(*this, arena,
+                                                              arena);
+  extension_parse_and_merge_on_arena<Proto2, Proto2Extension>(*this, arena,
+                                                              nullptr);
+  extension_parse_and_merge_on_arena<Proto2, Proto2Extension>(*this, nullptr,
+                                                              arena);
+  extension_parse_and_merge_on_arena<Proto2, Proto2Extension>(*this, nullptr,
+                                                              nullptr);
+  extension_parse_and_merge_on_arena<ArenaProto2, ArenaProto2Extension>(
+      *this, arena, arena);
+  extension_parse_and_merge_on_arena<ArenaProto2, ArenaProto2Extension>(
+      *this, arena, nullptr);
+  extension_parse_and_merge_on_arena<ArenaProto2, ArenaProto2Extension>(
+      *this, nullptr, arena);
+  extension_parse_and_merge_on_arena<ArenaProto2, ArenaProto2Extension>(
+      *this, nullptr, nullptr);
+}
diff --git a/src/google/protobuf/compiler/BUILD.bazel b/src/google/protobuf/compiler/BUILD.bazel
index 3f5624d5f..64cf4f852 100644
--- a/src/google/protobuf/compiler/BUILD.bazel
+++ b/src/google/protobuf/compiler/BUILD.bazel
@@ -347,6 +347,7 @@ cc_binary(
     testonly = True,
     srcs = ["fake_plugin.cc"],
     deps = [
+        ":code_generator",
         ":plugin_cc_proto",
         "//src/google/protobuf",
         "//src/google/protobuf/io:io_win32",
diff --git a/src/google/protobuf/compiler/cpp/field.cc b/src/google/protobuf/compiler/cpp/field.cc
index b7a8d1f45..cd0481b9f 100644
--- a/src/google/protobuf/compiler/cpp/field.cc
+++ b/src/google/protobuf/compiler/cpp/field.cc
@@ -336,7 +336,7 @@ void InlinedStringVars(const FieldDescriptor* field, const Options& opts,
                                 : "_impl_._inlined_string_donated_";
 
   vars.emplace_back("inlined_string_donated",
-                    absl::StrFormat("(%s[%d] & %s) != 0;", array, index, mask));
+                    absl::StrFormat("(%s[%d] & %s) != 0", array, index, mask));
   vars.emplace_back("donating_states_word",
                     absl::StrFormat("%s[%d]", array, index));
   vars.emplace_back("mask_for_undonate", absl::StrFormat("~%s", mask));
diff --git a/src/google/protobuf/compiler/cpp/field_generators/string_field.cc b/src/google/protobuf/compiler/cpp/field_generators/string_field.cc
index fcca9dfc3..7bc363071 100644
--- a/src/google/protobuf/compiler/cpp/field_generators/string_field.cc
+++ b/src/google/protobuf/compiler/cpp/field_generators/string_field.cc
@@ -78,6 +78,16 @@ class SingularString : public FieldGeneratorBase {
     return is_inlined() ? ArenaDtorNeeds::kOnDemand : ArenaDtorNeeds::kNone;
   }
 
+  void GenerateArenaDestructorCode(io::Printer* p) const override {
+    if (!is_inlined()) return;
+
+    p->Emit(R"cc(
+      if (!_this->_internal_$name$_donated()) {
+        _this->$field_$.~InlinedStringField();
+      }
+    )cc");
+  }
+
   void GeneratePrivateMembers(io::Printer* p) const override {
     // Skips the automatic destruction if inlined; rather calls it explicitly if
     // allocating arena is null.
@@ -110,16 +120,6 @@ class SingularString : public FieldGeneratorBase {
     }
   }
 
-  void GenerateArenaDestructorCode(io::Printer* p) const override {
-    if (!is_inlined()) return;
-
-    p->Emit(R"cc(
-      if (!_this->_internal_$name$_donated()) {
-        _this->$field_$.~InlinedStringField();
-      }
-    )cc");
-  }
-
   void GenerateNonInlineAccessorDefinitions(io::Printer* p) const override {
     if (EmptyDefault()) return;
     p->Emit(R"cc(
@@ -262,7 +262,17 @@ void SingularString::GenerateAccessorDeclarations(io::Printer* p) const {
           p->Emit(R"cc(
             inline PROTOBUF_ALWAYS_INLINE bool _internal_$name$_donated() const;
           )cc");
-        }}},
+        }},
+       // ARENASTRING PATCH: change mutable_xxx function return value to
+       //                    MaybeArenaStringAccessor when cc_mutable_donated_string=true
+       {"mutable_return_type", [&] {
+         if (field_->file()->options().cc_mutable_donated_string()) {
+           p->Emit("$pb$::MaybeArenaStringAccessor");
+         } else {
+           p->Emit("std::string*");
+         }
+       }},
+      },
       R"cc(
         $DEPRECATED$ const std::string& $name$() const;
         //~ Using `Arg_ = const std::string&` will make the type of `arg`
@@ -271,7 +281,7 @@ void SingularString::GenerateAccessorDeclarations(io::Printer* p) const {
         //~ default.
         template <typename Arg_ = const std::string&, typename... Args_>
         $DEPRECATED$ void $set_name$(Arg_&& arg, Args_... args);
-        $DEPRECATED$ std::string* $mutable_name$();
+        $DEPRECATED$ $mutable_return_type$ $mutable_name$();
         $DEPRECATED$ PROTOBUF_NODISCARD std::string* $release_name$();
         $DEPRECATED$ void $set_allocated_name$(std::string* value);
 
@@ -280,6 +290,7 @@ void SingularString::GenerateAccessorDeclarations(io::Printer* p) const {
         inline PROTOBUF_ALWAYS_INLINE void _internal_set_$name$(
             const std::string& value);
         std::string* _internal_mutable_$name$();
+        $pb$::MaybeArenaStringAccessor _internal_mutable_$name$_accessor();
         $donated$;
 
         public:
@@ -326,32 +337,22 @@ void SingularString::ReleaseImpl(io::Printer* p) const {
     return;
   }
 
-  if (!HasHasbit(field_)) {
-    p->Emit(R"cc(
-      return $field_$.Release();
-    )cc");
-    return;
-  }
-
-  if (is_inlined()) {
+  if (HasHasbit(field_)) {
     p->Emit(R"cc(
       if (($has_hasbit$) == 0) {
         return nullptr;
       }
       $clear_hasbit$;
+    )cc");
+  }
 
+  if (is_inlined()) {
+    p->Emit(R"cc(
       return $field_$.Release(GetArena(), _internal_$name_internal$_donated());
     )cc");
     return;
   }
 
-  p->Emit(R"cc(
-    if (($has_hasbit$) == 0) {
-      return nullptr;
-    }
-    $clear_hasbit$;
-  )cc");
-
   if (!EmptyDefault()) {
     p->Emit(R"cc(
       return $field_$.Release();
@@ -442,6 +443,20 @@ void SingularString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
            SafeFunctionName(field_->containing_type(), field_, "release_")},
           {"release_impl", [&] { ReleaseImpl(p); }},
           {"set_allocated_impl", [&] { SetAllocatedImpl(p); }},
+          // ARENASTRING PATCH: change mutable_xxx function return value to
+          //                    MaybeArenaStringAccessor when cc_mutable_donated_string=true
+          {"mutable_return_type", [&] {
+             if (field_->file()->options().cc_mutable_donated_string()) {
+               p->Emit("$pb$::MaybeArenaStringAccessor");
+             } else {
+               p->Emit("std::string*");
+             }
+           }},
+          {"mutable_suffix", [&] {
+             if (field_->file()->options().cc_mutable_donated_string()) {
+               p->Emit("_accessor");
+             }
+           }},
       },
       R"cc(
         inline const std::string& $Msg$::$name$() const
@@ -463,10 +478,10 @@ void SingularString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
           $annotate_set$;
           // @@protoc_insertion_point(field_set:$pkg.Msg.field$)
         }
-        inline std::string* $Msg$::mutable_$name$() ABSL_ATTRIBUTE_LIFETIME_BOUND {
+        inline $mutable_return_type$ $Msg$::mutable_$name$() ABSL_ATTRIBUTE_LIFETIME_BOUND {
           $WeakDescriptorSelfPin$;
           $PrepareSplitMessageForWrite$;
-          std::string* _s = _internal_mutable_$name_internal$();
+          auto _s = _internal_mutable_$name_internal$$mutable_suffix$();
           $annotate_mutable$;
           // @@protoc_insertion_point(field_mutable:$pkg.Msg.field$)
           return _s;
@@ -488,6 +503,11 @@ void SingularString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
           $update_hasbit$;
           return $field_$.Mutable($lazy_args$, $set_args$);
         }
+        inline $pb$::MaybeArenaStringAccessor $Msg$::_internal_mutable_$name_internal$_accessor() {
+          $TsanDetectConcurrentMutation$;
+          $update_hasbit$;
+          return $field_$.MutableAccessor($lazy_args$, $set_args$);
+        }
         inline std::string* $Msg$::$release_name$() {
           $WeakDescriptorSelfPin$;
           $TsanDetectConcurrentMutation$;
@@ -837,12 +857,22 @@ void RepeatedString::GenerateAccessorDeclarations(io::Printer* p) const {
   auto v3 = p->WithVars(
       AnnotatedAccessors(field_, {"mutable_"}, AnnotationCollector::kAlias));
 
-  p->Emit(R"cc(
+  // ARENASTRING PATCH: change mutable_xxx function return value to
+  //                    MaybeArenaStringAccessor when cc_mutable_donated_string=true
+  p->Emit({{"mutable_return_type",
+            [&] {
+              if (field_->file()->options().cc_mutable_donated_string()) {
+                p->Emit("$pb$::MaybeArenaStringAccessor");
+              } else {
+                p->Emit("std::string*");
+              }
+            }}},
+          R"cc(
     $DEPRECATED$ const std::string& $name$(int index) const;
-    $DEPRECATED$ std::string* $mutable_name$(int index);
+    $DEPRECATED$ $mutable_return_type$ $mutable_name$(int index);
     template <typename Arg_ = const std::string&, typename... Args_>
     $DEPRECATED$ void set_$name$(int index, Arg_&& value, Args_... args);
-    $DEPRECATED$ std::string* $add_name$();
+    $DEPRECATED$ $mutable_return_type$ $add_name$();
     template <typename Arg_ = const std::string&, typename... Args_>
     $DEPRECATED$ void $add_name$(Arg_&& value, Args_... args);
     $DEPRECATED$ const $pb$::RepeatedPtrField<std::string>& $name$() const;
@@ -873,12 +903,29 @@ void RepeatedString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
                p->Emit(", $pbi$::BytesTag{}");
              }
            }},
+           // ARENASTRING PATCH: change mutable_xxx function return value to
+           //                    MaybeArenaStringAccessor when cc_mutable_donated_string=true
+           {"mutable_return_type",
+            [&] {
+              if (field_->file()->options().cc_mutable_donated_string()) {
+                p->Emit("$pb$::MaybeArenaStringAccessor");
+              } else {
+                p->Emit("std::string*");
+              }
+            }},
+           {"mutable_suffix", [&] {
+              if (field_->file()->options().cc_mutable_donated_string()) {
+                p->Emit("Accessor");
+              } else {
+                p->Emit("String");
+              }
+            }},
       },
       R"cc(
-        inline std::string* $Msg$::add_$name$() ABSL_ATTRIBUTE_LIFETIME_BOUND {
+        inline $mutable_return_type$ $Msg$::add_$name$() ABSL_ATTRIBUTE_LIFETIME_BOUND {
           $WeakDescriptorSelfPin$;
           $TsanDetectConcurrentMutation$;
-          std::string* _s = _internal_mutable_$name_internal$()->Add();
+          auto _s = _internal_mutable_$name_internal$()->Add$mutable_suffix$();
           $annotate_add_mutable$;
           // @@protoc_insertion_point(field_add_mutable:$pkg.Msg.field$)
           return _s;
@@ -890,18 +937,18 @@ void RepeatedString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
           // @@protoc_insertion_point(field_get:$pkg.Msg.field$)
           return _internal_$name_internal$().$Get$(index$GetExtraArg$);
         }
-        inline std::string* $Msg$::mutable_$name$(int index)
+        inline $mutable_return_type$ $Msg$::mutable_$name$(int index)
             ABSL_ATTRIBUTE_LIFETIME_BOUND {
           $WeakDescriptorSelfPin$;
           $annotate_mutable$;
           // @@protoc_insertion_point(field_mutable:$pkg.Msg.field$)
-          return _internal_mutable_$name_internal$()->Mutable(index);
+          return _internal_mutable_$name_internal$()->Mutable$mutable_suffix$(index);
         }
         template <typename Arg_, typename... Args_>
         inline void $Msg$::set_$name$(int index, Arg_&& value, Args_... args) {
           $WeakDescriptorSelfPin$;
           $pbi$::AssignToString(
-              *_internal_mutable_$name_internal$()->Mutable(index),
+              *_internal_mutable_$name_internal$()->MutableAccessor(index),
               std::forward<Arg_>(value), args... $bytes_tag$);
           $annotate_set$;
           // @@protoc_insertion_point(field_set:$pkg.Msg.field$)
diff --git a/src/google/protobuf/compiler/cpp/helpers.cc b/src/google/protobuf/compiler/cpp/helpers.cc
index 4a3a47e10..bb07bea0e 100644
--- a/src/google/protobuf/compiler/cpp/helpers.cc
+++ b/src/google/protobuf/compiler/cpp/helpers.cc
@@ -959,7 +959,20 @@ bool CanStringBeInlined(const FieldDescriptor* field) {
 bool IsStringInlined(const FieldDescriptor* field, const Options& options) {
   (void)field;
   (void)options;
-  return false;
+  // ARENASTRING PATCH: enable InlinedStringField when cc_mutable_donated_string=true
+  return field->file()->options().cc_mutable_donated_string() &&
+         // only for string/bytes
+         field->cpp_type() == FieldDescriptor::CPPTYPE_STRING &&
+         // exclude non default ctype
+         internal::cpp::EffectiveStringCType(field) == FieldOptions::STRING &&
+         // exclude oneof
+         !field->real_containing_oneof() &&
+         // exclude repeated
+         !field->is_repeated() &&
+         // exclude map
+         !field->containing_type()->options().map_entry() &&
+         // no default value
+         !field->has_default_value();
 }
 
 static bool HasLazyFields(const Descriptor* descriptor, const Options& options,
diff --git a/src/google/protobuf/compiler/cpp/message.cc b/src/google/protobuf/compiler/cpp/message.cc
index 1f868e589..0e816a64f 100644
--- a/src/google/protobuf/compiler/cpp/message.cc
+++ b/src/google/protobuf/compiler/cpp/message.cc
@@ -2139,23 +2139,30 @@ void MessageGenerator::GenerateInlineMethods(io::Printer* p) {
 
 void MessageGenerator::GenerateSchema(io::Printer* p, int offset,
                                       int has_offset) {
-  has_offset = !has_bit_indices_.empty() || IsMapEntryMessage(descriptor_)
-                   ? offset + has_offset
-                   : -1;
+  // ARENASTRING PATCH: schema of Message is composed as
+  //                      <metadata>[has_bit_indices][inlined_string_indices]
+  //                      has_offset = sizeof(metadata)
+  //                      offset = base offset of metadata
+  //                    original implementation dont support inlined string
+  //                    without hasbit. modify to support that
+  int has_bit_indices_offset =
+      !has_bit_indices_.empty() || IsMapEntryMessage(descriptor_)
+          ? offset + has_offset
+          : -1;
   int inlined_string_indices_offset;
   if (inlined_string_indices_.empty()) {
     inlined_string_indices_offset = -1;
   } else {
     ABSL_DCHECK_NE(has_offset, -1);
     ABSL_DCHECK(!IsMapEntryMessage(descriptor_));
-    inlined_string_indices_offset = has_offset + has_bit_indices_.size();
+    inlined_string_indices_offset = offset + has_offset + has_bit_indices_.size();
   }
 
   auto v = p->WithVars(ClassVars(descriptor_, options_));
   p->Emit(
       {
           {"offset", offset},
-          {"has_offset", has_offset},
+          {"has_offset", has_bit_indices_offset},
           {"string_offsets", inlined_string_indices_offset},
       },
       R"cc(
diff --git a/src/google/protobuf/compiler/plugin.pb.h b/src/google/protobuf/compiler/plugin.pb.h
index ae179a29e..5af526320 100644
--- a/src/google/protobuf/compiler/plugin.pb.h
+++ b/src/google/protobuf/compiler/plugin.pb.h
@@ -276,6 +276,7 @@ class PROTOC_EXPORT Version final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(
       const std::string& value);
   std::string* _internal_mutable_suffix();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_suffix_accessor();
 
   public:
   // optional int32 major = 1;
@@ -509,6 +510,7 @@ class PROTOC_EXPORT CodeGeneratorResponse_File final : public ::google::protobuf
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional string insertion_point = 2;
@@ -526,6 +528,7 @@ class PROTOC_EXPORT CodeGeneratorResponse_File final : public ::google::protobuf
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_insertion_point(
       const std::string& value);
   std::string* _internal_mutable_insertion_point();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_insertion_point_accessor();
 
   public:
   // optional string content = 15;
@@ -543,6 +546,7 @@ class PROTOC_EXPORT CodeGeneratorResponse_File final : public ::google::protobuf
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
       const std::string& value);
   std::string* _internal_mutable_content();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_content_accessor();
 
   public:
   // optional .google.protobuf.GeneratedCodeInfo generated_code_info = 16;
@@ -797,6 +801,7 @@ class PROTOC_EXPORT CodeGeneratorResponse final : public ::google::protobuf::Mes
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
       const std::string& value);
   std::string* _internal_mutable_error();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_error_accessor();
 
   public:
   // optional uint64 supported_features = 2;
@@ -1093,6 +1098,7 @@ class PROTOC_EXPORT CodeGeneratorRequest final : public ::google::protobuf::Mess
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter(
       const std::string& value);
   std::string* _internal_mutable_parameter();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_parameter_accessor();
 
   public:
   // optional .google.protobuf.compiler.Version compiler_version = 3;
@@ -1271,7 +1277,7 @@ inline PROTOBUF_ALWAYS_INLINE void Version::set_suffix(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.Version.suffix)
 }
 inline std::string* Version::mutable_suffix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_suffix();
+  auto _s = _internal_mutable_suffix();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.Version.suffix)
   return _s;
 }
@@ -1289,6 +1295,11 @@ inline std::string* Version::_internal_mutable_suffix() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.suffix_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Version::_internal_mutable_suffix_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.suffix_.MutableAccessor( GetArena());
+}
 inline std::string* Version::release_suffix() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.Version.suffix)
@@ -1335,7 +1346,7 @@ inline void CodeGeneratorRequest::clear_file_to_generate() {
 }
 inline std::string* CodeGeneratorRequest::add_file_to_generate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
   ::google::protobuf::internal::TSanWrite(&_impl_);
-  std::string* _s = _internal_mutable_file_to_generate()->Add();
+  auto _s = _internal_mutable_file_to_generate()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
   return _s;
 }
@@ -1347,12 +1358,12 @@ inline const std::string& CodeGeneratorRequest::file_to_generate(int index) cons
 inline std::string* CodeGeneratorRequest::mutable_file_to_generate(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
-  return _internal_mutable_file_to_generate()->Mutable(index);
+  return _internal_mutable_file_to_generate()->MutableString(index);
 }
 template <typename Arg_, typename... Args_>
 inline void CodeGeneratorRequest::set_file_to_generate(int index, Arg_&& value, Args_... args) {
   ::google::protobuf::internal::AssignToString(
-      *_internal_mutable_file_to_generate()->Mutable(index),
+      *_internal_mutable_file_to_generate()->MutableAccessor(index),
       std::forward<Arg_>(value), args... );
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
@@ -1410,7 +1421,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorRequest::set_parameter(Arg_&& ar
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorRequest.parameter)
 }
 inline std::string* CodeGeneratorRequest::mutable_parameter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_parameter();
+  auto _s = _internal_mutable_parameter();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorRequest.parameter)
   return _s;
 }
@@ -1428,6 +1439,11 @@ inline std::string* CodeGeneratorRequest::_internal_mutable_parameter() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.parameter_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorRequest::_internal_mutable_parameter_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.parameter_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorRequest::release_parameter() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorRequest.parameter)
@@ -1671,7 +1687,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorResponse_File::set_name(Arg_&& a
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorResponse.File.name)
 }
 inline std::string* CodeGeneratorResponse_File::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorResponse.File.name)
   return _s;
 }
@@ -1689,6 +1705,11 @@ inline std::string* CodeGeneratorResponse_File::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorResponse_File::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorResponse_File::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.File.name)
@@ -1742,7 +1763,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorResponse_File::set_insertion_poi
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorResponse.File.insertion_point)
 }
 inline std::string* CodeGeneratorResponse_File::mutable_insertion_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_insertion_point();
+  auto _s = _internal_mutable_insertion_point();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorResponse.File.insertion_point)
   return _s;
 }
@@ -1760,6 +1781,11 @@ inline std::string* CodeGeneratorResponse_File::_internal_mutable_insertion_poin
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.insertion_point_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorResponse_File::_internal_mutable_insertion_point_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.insertion_point_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorResponse_File::release_insertion_point() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.File.insertion_point)
@@ -1813,7 +1839,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorResponse_File::set_content(Arg_&
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorResponse.File.content)
 }
 inline std::string* CodeGeneratorResponse_File::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_content();
+  auto _s = _internal_mutable_content();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorResponse.File.content)
   return _s;
 }
@@ -1831,6 +1857,11 @@ inline std::string* CodeGeneratorResponse_File::_internal_mutable_content() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.content_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorResponse_File::_internal_mutable_content_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.content_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorResponse_File::release_content() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.File.content)
@@ -1979,7 +2010,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorResponse::set_error(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorResponse.error)
 }
 inline std::string* CodeGeneratorResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_error();
+  auto _s = _internal_mutable_error();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorResponse.error)
   return _s;
 }
@@ -1997,6 +2028,11 @@ inline std::string* CodeGeneratorResponse::_internal_mutable_error() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.error_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorResponse::_internal_mutable_error_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.error_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorResponse::release_error() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.error)
diff --git a/src/google/protobuf/descriptor.pb.cc b/src/google/protobuf/descriptor.pb.cc
index d626f33db..5fe419ebf 100644
--- a/src/google/protobuf/descriptor.pb.cc
+++ b/src/google/protobuf/descriptor.pb.cc
@@ -647,6 +647,7 @@ inline constexpr FileOptions::Impl_::Impl_(
         java_generic_services_{false},
         py_generic_services_{false},
         deprecated_{false},
+        cc_mutable_donated_string_{false},
         optimize_for_{static_cast< ::google::protobuf::FileOptions_OptimizeMode >(1)},
         cc_enable_arenas_{true} {}
 
@@ -1508,6 +1509,7 @@ const ::uint32_t
         PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.py_generic_services_),
         PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.deprecated_),
         PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.cc_enable_arenas_),
+        PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.cc_mutable_donated_string_),
         PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.objc_class_prefix_),
         PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.csharp_namespace_),
         PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.swift_prefix_),
@@ -1522,13 +1524,14 @@ const ::uint32_t
         11,
         12,
         13,
-        18,
+        19,
         2,
         14,
         15,
         16,
         17,
-        19,
+        20,
+        18,
         3,
         4,
         5,
@@ -1856,25 +1859,25 @@ static const ::_pbi::MigrationSchema
         {203, 214, -1, sizeof(::google::protobuf::EnumValueDescriptorProto)},
         {217, 228, -1, sizeof(::google::protobuf::ServiceDescriptorProto)},
         {231, 245, -1, sizeof(::google::protobuf::MethodDescriptorProto)},
-        {251, 280, -1, sizeof(::google::protobuf::FileOptions)},
-        {301, 316, -1, sizeof(::google::protobuf::MessageOptions)},
-        {323, 333, -1, sizeof(::google::protobuf::FieldOptions_EditionDefault)},
-        {335, 347, -1, sizeof(::google::protobuf::FieldOptions_FeatureSupport)},
-        {351, 373, -1, sizeof(::google::protobuf::FieldOptions)},
-        {387, 397, -1, sizeof(::google::protobuf::OneofOptions)},
-        {399, 412, -1, sizeof(::google::protobuf::EnumOptions)},
-        {417, 430, -1, sizeof(::google::protobuf::EnumValueOptions)},
-        {435, 446, -1, sizeof(::google::protobuf::ServiceOptions)},
-        {449, 461, -1, sizeof(::google::protobuf::MethodOptions)},
-        {465, 475, -1, sizeof(::google::protobuf::UninterpretedOption_NamePart)},
-        {477, 492, -1, sizeof(::google::protobuf::UninterpretedOption)},
-        {499, 513, -1, sizeof(::google::protobuf::FeatureSet)},
-        {519, 530, -1, sizeof(::google::protobuf::FeatureSetDefaults_FeatureSetEditionDefault)},
-        {533, 544, -1, sizeof(::google::protobuf::FeatureSetDefaults)},
-        {547, 560, -1, sizeof(::google::protobuf::SourceCodeInfo_Location)},
-        {565, -1, -1, sizeof(::google::protobuf::SourceCodeInfo)},
-        {574, 587, -1, sizeof(::google::protobuf::GeneratedCodeInfo_Annotation)},
-        {592, -1, -1, sizeof(::google::protobuf::GeneratedCodeInfo)},
+        {251, 281, -1, sizeof(::google::protobuf::FileOptions)},
+        {303, 318, -1, sizeof(::google::protobuf::MessageOptions)},
+        {325, 335, -1, sizeof(::google::protobuf::FieldOptions_EditionDefault)},
+        {337, 349, -1, sizeof(::google::protobuf::FieldOptions_FeatureSupport)},
+        {353, 375, -1, sizeof(::google::protobuf::FieldOptions)},
+        {389, 399, -1, sizeof(::google::protobuf::OneofOptions)},
+        {401, 414, -1, sizeof(::google::protobuf::EnumOptions)},
+        {419, 432, -1, sizeof(::google::protobuf::EnumValueOptions)},
+        {437, 448, -1, sizeof(::google::protobuf::ServiceOptions)},
+        {451, 463, -1, sizeof(::google::protobuf::MethodOptions)},
+        {467, 477, -1, sizeof(::google::protobuf::UninterpretedOption_NamePart)},
+        {479, 494, -1, sizeof(::google::protobuf::UninterpretedOption)},
+        {501, 515, -1, sizeof(::google::protobuf::FeatureSet)},
+        {521, 532, -1, sizeof(::google::protobuf::FeatureSetDefaults_FeatureSetEditionDefault)},
+        {535, 546, -1, sizeof(::google::protobuf::FeatureSetDefaults)},
+        {549, 562, -1, sizeof(::google::protobuf::SourceCodeInfo_Location)},
+        {567, -1, -1, sizeof(::google::protobuf::SourceCodeInfo)},
+        {576, 589, -1, sizeof(::google::protobuf::GeneratedCodeInfo_Annotation)},
+        {594, -1, -1, sizeof(::google::protobuf::GeneratedCodeInfo)},
 };
 static const ::_pb::Message* const file_default_instances[] = {
     &::google::protobuf::_FileDescriptorSet_default_instance_._instance,
@@ -1997,7 +2000,7 @@ const char descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto[] AB
     "\001(\t\022\023\n\013output_type\030\003 \001(\t\022/\n\007options\030\004 \001("
     "\0132\036.google.protobuf.MethodOptions\022\037\n\020cli"
     "ent_streaming\030\005 \001(\010:\005false\022\037\n\020server_str"
-    "eaming\030\006 \001(\010:\005false\"\313\006\n\013FileOptions\022\024\n\014j"
+    "eaming\030\006 \001(\010:\005false\"\365\006\n\013FileOptions\022\024\n\014j"
     "ava_package\030\001 \001(\t\022\034\n\024java_outer_classnam"
     "e\030\010 \001(\t\022\"\n\023java_multiple_files\030\n \001(\010:\005fa"
     "lse\022)\n\035java_generate_equals_and_hash\030\024 \001"
@@ -2008,170 +2011,171 @@ const char descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto[] AB
     "\030\020 \001(\010:\005false\022$\n\025java_generic_services\030\021"
     " \001(\010:\005false\022\"\n\023py_generic_services\030\022 \001(\010"
     ":\005false\022\031\n\ndeprecated\030\027 \001(\010:\005false\022\036\n\020cc"
-    "_enable_arenas\030\037 \001(\010:\004true\022\031\n\021objc_class"
-    "_prefix\030$ \001(\t\022\030\n\020csharp_namespace\030% \001(\t\022"
-    "\024\n\014swift_prefix\030\' \001(\t\022\030\n\020php_class_prefi"
-    "x\030( \001(\t\022\025\n\rphp_namespace\030) \001(\t\022\036\n\026php_me"
-    "tadata_namespace\030, \001(\t\022\024\n\014ruby_package\030-"
-    " \001(\t\022-\n\010features\0302 \001(\0132\033.google.protobuf"
-    ".FeatureSet\022C\n\024uninterpreted_option\030\347\007 \003"
-    "(\0132$.google.protobuf.UninterpretedOption"
-    "\":\n\014OptimizeMode\022\t\n\005SPEED\020\001\022\r\n\tCODE_SIZE"
-    "\020\002\022\020\n\014LITE_RUNTIME\020\003*\t\010\350\007\020\200\200\200\200\002J\004\010*\020+J\004\010"
-    "&\020\'R\024php_generic_services\"\347\002\n\016MessageOpt"
-    "ions\022&\n\027message_set_wire_format\030\001 \001(\010:\005f"
-    "alse\022.\n\037no_standard_descriptor_accessor\030"
-    "\002 \001(\010:\005false\022\031\n\ndeprecated\030\003 \001(\010:\005false\022"
-    "\021\n\tmap_entry\030\007 \001(\010\0222\n&deprecated_legacy_"
-    "json_field_conflicts\030\013 \001(\010B\002\030\001\022-\n\010featur"
-    "es\030\014 \001(\0132\033.google.protobuf.FeatureSet\022C\n"
-    "\024uninterpreted_option\030\347\007 \003(\0132$.google.pr"
-    "otobuf.UninterpretedOption*\t\010\350\007\020\200\200\200\200\002J\004\010"
-    "\004\020\005J\004\010\005\020\006J\004\010\006\020\007J\004\010\010\020\tJ\004\010\t\020\n\"\243\013\n\014FieldOpt"
-    "ions\022:\n\005ctype\030\001 \001(\0162#.google.protobuf.Fi"
-    "eldOptions.CType:\006STRING\022\016\n\006packed\030\002 \001(\010"
-    "\022\?\n\006jstype\030\006 \001(\0162$.google.protobuf.Field"
-    "Options.JSType:\tJS_NORMAL\022\023\n\004lazy\030\005 \001(\010:"
-    "\005false\022\036\n\017unverified_lazy\030\017 \001(\010:\005false\022\031"
-    "\n\ndeprecated\030\003 \001(\010:\005false\022\023\n\004weak\030\n \001(\010:"
-    "\005false\022\033\n\014debug_redact\030\020 \001(\010:\005false\022@\n\tr"
-    "etention\030\021 \001(\0162-.google.protobuf.FieldOp"
-    "tions.OptionRetention\022\?\n\007targets\030\023 \003(\0162."
-    ".google.protobuf.FieldOptions.OptionTarg"
-    "etType\022F\n\020edition_defaults\030\024 \003(\0132,.googl"
-    "e.protobuf.FieldOptions.EditionDefault\022-"
-    "\n\010features\030\025 \001(\0132\033.google.protobuf.Featu"
-    "reSet\022E\n\017feature_support\030\026 \001(\0132,.google."
-    "protobuf.FieldOptions.FeatureSupport\022C\n\024"
-    "uninterpreted_option\030\347\007 \003(\0132$.google.pro"
-    "tobuf.UninterpretedOption\032J\n\016EditionDefa"
-    "ult\022)\n\007edition\030\003 \001(\0162\030.google.protobuf.E"
-    "dition\022\r\n\005value\030\002 \001(\t\032\314\001\n\016FeatureSupport"
-    "\0224\n\022edition_introduced\030\001 \001(\0162\030.google.pr"
-    "otobuf.Edition\0224\n\022edition_deprecated\030\002 \001"
-    "(\0162\030.google.protobuf.Edition\022\033\n\023deprecat"
-    "ion_warning\030\003 \001(\t\0221\n\017edition_removed\030\004 \001"
-    "(\0162\030.google.protobuf.Edition\"/\n\005CType\022\n\n"
-    "\006STRING\020\000\022\010\n\004CORD\020\001\022\020\n\014STRING_PIECE\020\002\"5\n"
-    "\006JSType\022\r\n\tJS_NORMAL\020\000\022\r\n\tJS_STRING\020\001\022\r\n"
-    "\tJS_NUMBER\020\002\"U\n\017OptionRetention\022\025\n\021RETEN"
-    "TION_UNKNOWN\020\000\022\025\n\021RETENTION_RUNTIME\020\001\022\024\n"
-    "\020RETENTION_SOURCE\020\002\"\214\002\n\020OptionTargetType"
-    "\022\027\n\023TARGET_TYPE_UNKNOWN\020\000\022\024\n\020TARGET_TYPE"
-    "_FILE\020\001\022\037\n\033TARGET_TYPE_EXTENSION_RANGE\020\002"
-    "\022\027\n\023TARGET_TYPE_MESSAGE\020\003\022\025\n\021TARGET_TYPE"
-    "_FIELD\020\004\022\025\n\021TARGET_TYPE_ONEOF\020\005\022\024\n\020TARGE"
-    "T_TYPE_ENUM\020\006\022\032\n\026TARGET_TYPE_ENUM_ENTRY\020"
-    "\007\022\027\n\023TARGET_TYPE_SERVICE\020\010\022\026\n\022TARGET_TYP"
-    "E_METHOD\020\t*\t\010\350\007\020\200\200\200\200\002J\004\010\004\020\005J\004\010\022\020\023\"\215\001\n\014On"
-    "eofOptions\022-\n\010features\030\001 \001(\0132\033.google.pr"
-    "otobuf.FeatureSet\022C\n\024uninterpreted_optio"
-    "n\030\347\007 \003(\0132$.google.protobuf.Uninterpreted"
-    "Option*\t\010\350\007\020\200\200\200\200\002\"\366\001\n\013EnumOptions\022\023\n\013all"
-    "ow_alias\030\002 \001(\010\022\031\n\ndeprecated\030\003 \001(\010:\005fals"
-    "e\0222\n&deprecated_legacy_json_field_confli"
-    "cts\030\006 \001(\010B\002\030\001\022-\n\010features\030\007 \001(\0132\033.google"
-    ".protobuf.FeatureSet\022C\n\024uninterpreted_op"
-    "tion\030\347\007 \003(\0132$.google.protobuf.Uninterpre"
-    "tedOption*\t\010\350\007\020\200\200\200\200\002J\004\010\005\020\006\"\220\002\n\020EnumValue"
-    "Options\022\031\n\ndeprecated\030\001 \001(\010:\005false\022-\n\010fe"
-    "atures\030\002 \001(\0132\033.google.protobuf.FeatureSe"
-    "t\022\033\n\014debug_redact\030\003 \001(\010:\005false\022E\n\017featur"
-    "e_support\030\004 \001(\0132,.google.protobuf.FieldO"
-    "ptions.FeatureSupport\022C\n\024uninterpreted_o"
-    "ption\030\347\007 \003(\0132$.google.protobuf.Uninterpr"
-    "etedOption*\t\010\350\007\020\200\200\200\200\002\"\252\001\n\016ServiceOptions"
-    "\022-\n\010features\030\" \001(\0132\033.google.protobuf.Fea"
-    "tureSet\022\031\n\ndeprecated\030! \001(\010:\005false\022C\n\024un"
-    "interpreted_option\030\347\007 \003(\0132$.google.proto"
-    "buf.UninterpretedOption*\t\010\350\007\020\200\200\200\200\002\"\334\002\n\rM"
-    "ethodOptions\022\031\n\ndeprecated\030! \001(\010:\005false\022"
-    "_\n\021idempotency_level\030\" \001(\0162/.google.prot"
-    "obuf.MethodOptions.IdempotencyLevel:\023IDE"
-    "MPOTENCY_UNKNOWN\022-\n\010features\030# \001(\0132\033.goo"
-    "gle.protobuf.FeatureSet\022C\n\024uninterpreted"
+    "_enable_arenas\030\037 \001(\010:\004true\022(\n\031cc_mutable"
+    "_donated_string\030  \001(\010:\005false\022\031\n\021objc_cla"
+    "ss_prefix\030$ \001(\t\022\030\n\020csharp_namespace\030% \001("
+    "\t\022\024\n\014swift_prefix\030\' \001(\t\022\030\n\020php_class_pre"
+    "fix\030( \001(\t\022\025\n\rphp_namespace\030) \001(\t\022\036\n\026php_"
+    "metadata_namespace\030, \001(\t\022\024\n\014ruby_package"
+    "\030- \001(\t\022-\n\010features\0302 \001(\0132\033.google.protob"
+    "uf.FeatureSet\022C\n\024uninterpreted_option\030\347\007"
+    " \003(\0132$.google.protobuf.UninterpretedOpti"
+    "on\":\n\014OptimizeMode\022\t\n\005SPEED\020\001\022\r\n\tCODE_SI"
+    "ZE\020\002\022\020\n\014LITE_RUNTIME\020\003*\t\010\350\007\020\200\200\200\200\002J\004\010*\020+J"
+    "\004\010&\020\'R\024php_generic_services\"\347\002\n\016MessageO"
+    "ptions\022&\n\027message_set_wire_format\030\001 \001(\010:"
+    "\005false\022.\n\037no_standard_descriptor_accesso"
+    "r\030\002 \001(\010:\005false\022\031\n\ndeprecated\030\003 \001(\010:\005fals"
+    "e\022\021\n\tmap_entry\030\007 \001(\010\0222\n&deprecated_legac"
+    "y_json_field_conflicts\030\013 \001(\010B\002\030\001\022-\n\010feat"
+    "ures\030\014 \001(\0132\033.google.protobuf.FeatureSet\022"
+    "C\n\024uninterpreted_option\030\347\007 \003(\0132$.google."
+    "protobuf.UninterpretedOption*\t\010\350\007\020\200\200\200\200\002J"
+    "\004\010\004\020\005J\004\010\005\020\006J\004\010\006\020\007J\004\010\010\020\tJ\004\010\t\020\n\"\243\013\n\014FieldO"
+    "ptions\022:\n\005ctype\030\001 \001(\0162#.google.protobuf."
+    "FieldOptions.CType:\006STRING\022\016\n\006packed\030\002 \001"
+    "(\010\022\?\n\006jstype\030\006 \001(\0162$.google.protobuf.Fie"
+    "ldOptions.JSType:\tJS_NORMAL\022\023\n\004lazy\030\005 \001("
+    "\010:\005false\022\036\n\017unverified_lazy\030\017 \001(\010:\005false"
+    "\022\031\n\ndeprecated\030\003 \001(\010:\005false\022\023\n\004weak\030\n \001("
+    "\010:\005false\022\033\n\014debug_redact\030\020 \001(\010:\005false\022@\n"
+    "\tretention\030\021 \001(\0162-.google.protobuf.Field"
+    "Options.OptionRetention\022\?\n\007targets\030\023 \003(\016"
+    "2..google.protobuf.FieldOptions.OptionTa"
+    "rgetType\022F\n\020edition_defaults\030\024 \003(\0132,.goo"
+    "gle.protobuf.FieldOptions.EditionDefault"
+    "\022-\n\010features\030\025 \001(\0132\033.google.protobuf.Fea"
+    "tureSet\022E\n\017feature_support\030\026 \001(\0132,.googl"
+    "e.protobuf.FieldOptions.FeatureSupport\022C"
+    "\n\024uninterpreted_option\030\347\007 \003(\0132$.google.p"
+    "rotobuf.UninterpretedOption\032J\n\016EditionDe"
+    "fault\022)\n\007edition\030\003 \001(\0162\030.google.protobuf"
+    ".Edition\022\r\n\005value\030\002 \001(\t\032\314\001\n\016FeatureSuppo"
+    "rt\0224\n\022edition_introduced\030\001 \001(\0162\030.google."
+    "protobuf.Edition\0224\n\022edition_deprecated\030\002"
+    " \001(\0162\030.google.protobuf.Edition\022\033\n\023deprec"
+    "ation_warning\030\003 \001(\t\0221\n\017edition_removed\030\004"
+    " \001(\0162\030.google.protobuf.Edition\"/\n\005CType\022"
+    "\n\n\006STRING\020\000\022\010\n\004CORD\020\001\022\020\n\014STRING_PIECE\020\002\""
+    "5\n\006JSType\022\r\n\tJS_NORMAL\020\000\022\r\n\tJS_STRING\020\001\022"
+    "\r\n\tJS_NUMBER\020\002\"U\n\017OptionRetention\022\025\n\021RET"
+    "ENTION_UNKNOWN\020\000\022\025\n\021RETENTION_RUNTIME\020\001\022"
+    "\024\n\020RETENTION_SOURCE\020\002\"\214\002\n\020OptionTargetTy"
+    "pe\022\027\n\023TARGET_TYPE_UNKNOWN\020\000\022\024\n\020TARGET_TY"
+    "PE_FILE\020\001\022\037\n\033TARGET_TYPE_EXTENSION_RANGE"
+    "\020\002\022\027\n\023TARGET_TYPE_MESSAGE\020\003\022\025\n\021TARGET_TY"
+    "PE_FIELD\020\004\022\025\n\021TARGET_TYPE_ONEOF\020\005\022\024\n\020TAR"
+    "GET_TYPE_ENUM\020\006\022\032\n\026TARGET_TYPE_ENUM_ENTR"
+    "Y\020\007\022\027\n\023TARGET_TYPE_SERVICE\020\010\022\026\n\022TARGET_T"
+    "YPE_METHOD\020\t*\t\010\350\007\020\200\200\200\200\002J\004\010\004\020\005J\004\010\022\020\023\"\215\001\n\014"
+    "OneofOptions\022-\n\010features\030\001 \001(\0132\033.google."
+    "protobuf.FeatureSet\022C\n\024uninterpreted_opt"
+    "ion\030\347\007 \003(\0132$.google.protobuf.Uninterpret"
+    "edOption*\t\010\350\007\020\200\200\200\200\002\"\366\001\n\013EnumOptions\022\023\n\013a"
+    "llow_alias\030\002 \001(\010\022\031\n\ndeprecated\030\003 \001(\010:\005fa"
+    "lse\0222\n&deprecated_legacy_json_field_conf"
+    "licts\030\006 \001(\010B\002\030\001\022-\n\010features\030\007 \001(\0132\033.goog"
+    "le.protobuf.FeatureSet\022C\n\024uninterpreted_"
+    "option\030\347\007 \003(\0132$.google.protobuf.Uninterp"
+    "retedOption*\t\010\350\007\020\200\200\200\200\002J\004\010\005\020\006\"\220\002\n\020EnumVal"
+    "ueOptions\022\031\n\ndeprecated\030\001 \001(\010:\005false\022-\n\010"
+    "features\030\002 \001(\0132\033.google.protobuf.Feature"
+    "Set\022\033\n\014debug_redact\030\003 \001(\010:\005false\022E\n\017feat"
+    "ure_support\030\004 \001(\0132,.google.protobuf.Fiel"
+    "dOptions.FeatureSupport\022C\n\024uninterpreted"
     "_option\030\347\007 \003(\0132$.google.protobuf.Uninter"
-    "pretedOption\"P\n\020IdempotencyLevel\022\027\n\023IDEM"
-    "POTENCY_UNKNOWN\020\000\022\023\n\017NO_SIDE_EFFECTS\020\001\022\016"
-    "\n\nIDEMPOTENT\020\002*\t\010\350\007\020\200\200\200\200\002\"\236\002\n\023Uninterpre"
-    "tedOption\022;\n\004name\030\002 \003(\0132-.google.protobu"
-    "f.UninterpretedOption.NamePart\022\030\n\020identi"
-    "fier_value\030\003 \001(\t\022\032\n\022positive_int_value\030\004"
-    " \001(\004\022\032\n\022negative_int_value\030\005 \001(\003\022\024\n\014doub"
-    "le_value\030\006 \001(\001\022\024\n\014string_value\030\007 \001(\014\022\027\n\017"
-    "aggregate_value\030\010 \001(\t\0323\n\010NamePart\022\021\n\tnam"
-    "e_part\030\001 \002(\t\022\024\n\014is_extension\030\002 \002(\010\"\311\t\n\nF"
-    "eatureSet\022\202\001\n\016field_presence\030\001 \001(\0162).goo"
-    "gle.protobuf.FeatureSet.FieldPresenceB\?\210"
-    "\001\001\230\001\004\230\001\001\242\001\r\022\010EXPLICIT\030\204\007\242\001\r\022\010IMPLICIT\030\347\007"
-    "\242\001\r\022\010EXPLICIT\030\350\007\262\001\003\010\350\007\022b\n\tenum_type\030\002 \001("
-    "\0162$.google.protobuf.FeatureSet.EnumTypeB"
-    ")\210\001\001\230\001\006\230\001\001\242\001\013\022\006CLOSED\030\204\007\242\001\t\022\004OPEN\030\347\007\262\001\003\010"
-    "\350\007\022\201\001\n\027repeated_field_encoding\030\003 \001(\01621.g"
-    "oogle.protobuf.FeatureSet.RepeatedFieldE"
-    "ncodingB-\210\001\001\230\001\004\230\001\001\242\001\r\022\010EXPANDED\030\204\007\242\001\013\022\006P"
-    "ACKED\030\347\007\262\001\003\010\350\007\022n\n\017utf8_validation\030\004 \001(\0162"
-    "*.google.protobuf.FeatureSet.Utf8Validat"
-    "ionB)\210\001\001\230\001\004\230\001\001\242\001\t\022\004NONE\030\204\007\242\001\013\022\006VERIFY\030\347\007"
-    "\262\001\003\010\350\007\022m\n\020message_encoding\030\005 \001(\0162+.googl"
-    "e.protobuf.FeatureSet.MessageEncodingB&\210"
-    "\001\001\230\001\004\230\001\001\242\001\024\022\017LENGTH_PREFIXED\030\204\007\262\001\003\010\350\007\022v\n"
-    "\013json_format\030\006 \001(\0162&.google.protobuf.Fea"
-    "tureSet.JsonFormatB9\210\001\001\230\001\003\230\001\006\230\001\001\242\001\027\022\022LEG"
-    "ACY_BEST_EFFORT\030\204\007\242\001\n\022\005ALLOW\030\347\007\262\001\003\010\350\007\"\\\n"
-    "\rFieldPresence\022\032\n\026FIELD_PRESENCE_UNKNOWN"
-    "\020\000\022\014\n\010EXPLICIT\020\001\022\014\n\010IMPLICIT\020\002\022\023\n\017LEGACY"
-    "_REQUIRED\020\003\"7\n\010EnumType\022\025\n\021ENUM_TYPE_UNK"
-    "NOWN\020\000\022\010\n\004OPEN\020\001\022\n\n\006CLOSED\020\002\"V\n\025Repeated"
-    "FieldEncoding\022#\n\037REPEATED_FIELD_ENCODING"
-    "_UNKNOWN\020\000\022\n\n\006PACKED\020\001\022\014\n\010EXPANDED\020\002\"I\n\016"
-    "Utf8Validation\022\033\n\027UTF8_VALIDATION_UNKNOW"
-    "N\020\000\022\n\n\006VERIFY\020\002\022\010\n\004NONE\020\003\"\004\010\001\020\001\"S\n\017Messa"
-    "geEncoding\022\034\n\030MESSAGE_ENCODING_UNKNOWN\020\000"
-    "\022\023\n\017LENGTH_PREFIXED\020\001\022\r\n\tDELIMITED\020\002\"H\n\n"
-    "JsonFormat\022\027\n\023JSON_FORMAT_UNKNOWN\020\000\022\t\n\005A"
-    "LLOW\020\001\022\026\n\022LEGACY_BEST_EFFORT\020\002*\006\010\350\007\020\213N*\006"
-    "\010\213N\020\220N*\006\010\220N\020\221NJ\006\010\347\007\020\350\007\"\230\003\n\022FeatureSetDef"
-    "aults\022N\n\010defaults\030\001 \003(\0132<.google.protobu"
-    "f.FeatureSetDefaults.FeatureSetEditionDe"
-    "fault\0221\n\017minimum_edition\030\004 \001(\0162\030.google."
-    "protobuf.Edition\0221\n\017maximum_edition\030\005 \001("
-    "\0162\030.google.protobuf.Edition\032\313\001\n\030FeatureS"
-    "etEditionDefault\022)\n\007edition\030\003 \001(\0162\030.goog"
-    "le.protobuf.Edition\0229\n\024overridable_featu"
-    "res\030\004 \001(\0132\033.google.protobuf.FeatureSet\0223"
-    "\n\016fixed_features\030\005 \001(\0132\033.google.protobuf"
-    ".FeatureSetJ\004\010\001\020\002J\004\010\002\020\003R\010features\"\325\001\n\016So"
-    "urceCodeInfo\022:\n\010location\030\001 \003(\0132(.google."
-    "protobuf.SourceCodeInfo.Location\032\206\001\n\010Loc"
-    "ation\022\020\n\004path\030\001 \003(\005B\002\020\001\022\020\n\004span\030\002 \003(\005B\002\020"
-    "\001\022\030\n\020leading_comments\030\003 \001(\t\022\031\n\021trailing_"
-    "comments\030\004 \001(\t\022!\n\031leading_detached_comme"
-    "nts\030\006 \003(\t\"\234\002\n\021GeneratedCodeInfo\022A\n\nannot"
-    "ation\030\001 \003(\0132-.google.protobuf.GeneratedC"
-    "odeInfo.Annotation\032\303\001\n\nAnnotation\022\020\n\004pat"
-    "h\030\001 \003(\005B\002\020\001\022\023\n\013source_file\030\002 \001(\t\022\r\n\005begi"
-    "n\030\003 \001(\005\022\013\n\003end\030\004 \001(\005\022H\n\010semantic\030\005 \001(\01626"
-    ".google.protobuf.GeneratedCodeInfo.Annot"
-    "ation.Semantic\"(\n\010Semantic\022\010\n\004NONE\020\000\022\007\n\003"
-    "SET\020\001\022\t\n\005ALIAS\020\002*\247\002\n\007Edition\022\023\n\017EDITION_"
-    "UNKNOWN\020\000\022\023\n\016EDITION_LEGACY\020\204\007\022\023\n\016EDITIO"
-    "N_PROTO2\020\346\007\022\023\n\016EDITION_PROTO3\020\347\007\022\021\n\014EDIT"
-    "ION_2023\020\350\007\022\021\n\014EDITION_2024\020\351\007\022\027\n\023EDITIO"
-    "N_1_TEST_ONLY\020\001\022\027\n\023EDITION_2_TEST_ONLY\020\002"
-    "\022\035\n\027EDITION_99997_TEST_ONLY\020\235\215\006\022\035\n\027EDITI"
-    "ON_99998_TEST_ONLY\020\236\215\006\022\035\n\027EDITION_99999_"
-    "TEST_ONLY\020\237\215\006\022\023\n\013EDITION_MAX\020\377\377\377\377\007B~\n\023co"
-    "m.google.protobufB\020DescriptorProtosH\001Z-g"
-    "oogle.golang.org/protobuf/types/descript"
-    "orpb\370\001\001\242\002\003GPB\252\002\032Google.Protobuf.Reflecti"
-    "on"
+    "pretedOption*\t\010\350\007\020\200\200\200\200\002\"\252\001\n\016ServiceOptio"
+    "ns\022-\n\010features\030\" \001(\0132\033.google.protobuf.F"
+    "eatureSet\022\031\n\ndeprecated\030! \001(\010:\005false\022C\n\024"
+    "uninterpreted_option\030\347\007 \003(\0132$.google.pro"
+    "tobuf.UninterpretedOption*\t\010\350\007\020\200\200\200\200\002\"\334\002\n"
+    "\rMethodOptions\022\031\n\ndeprecated\030! \001(\010:\005fals"
+    "e\022_\n\021idempotency_level\030\" \001(\0162/.google.pr"
+    "otobuf.MethodOptions.IdempotencyLevel:\023I"
+    "DEMPOTENCY_UNKNOWN\022-\n\010features\030# \001(\0132\033.g"
+    "oogle.protobuf.FeatureSet\022C\n\024uninterpret"
+    "ed_option\030\347\007 \003(\0132$.google.protobuf.Unint"
+    "erpretedOption\"P\n\020IdempotencyLevel\022\027\n\023ID"
+    "EMPOTENCY_UNKNOWN\020\000\022\023\n\017NO_SIDE_EFFECTS\020\001"
+    "\022\016\n\nIDEMPOTENT\020\002*\t\010\350\007\020\200\200\200\200\002\"\236\002\n\023Uninterp"
+    "retedOption\022;\n\004name\030\002 \003(\0132-.google.proto"
+    "buf.UninterpretedOption.NamePart\022\030\n\020iden"
+    "tifier_value\030\003 \001(\t\022\032\n\022positive_int_value"
+    "\030\004 \001(\004\022\032\n\022negative_int_value\030\005 \001(\003\022\024\n\014do"
+    "uble_value\030\006 \001(\001\022\024\n\014string_value\030\007 \001(\014\022\027"
+    "\n\017aggregate_value\030\010 \001(\t\0323\n\010NamePart\022\021\n\tn"
+    "ame_part\030\001 \002(\t\022\024\n\014is_extension\030\002 \002(\010\"\311\t\n"
+    "\nFeatureSet\022\202\001\n\016field_presence\030\001 \001(\0162).g"
+    "oogle.protobuf.FeatureSet.FieldPresenceB"
+    "\?\210\001\001\230\001\004\230\001\001\242\001\r\022\010EXPLICIT\030\204\007\242\001\r\022\010IMPLICIT\030"
+    "\347\007\242\001\r\022\010EXPLICIT\030\350\007\262\001\003\010\350\007\022b\n\tenum_type\030\002 "
+    "\001(\0162$.google.protobuf.FeatureSet.EnumTyp"
+    "eB)\210\001\001\230\001\006\230\001\001\242\001\013\022\006CLOSED\030\204\007\242\001\t\022\004OPEN\030\347\007\262\001"
+    "\003\010\350\007\022\201\001\n\027repeated_field_encoding\030\003 \001(\01621"
+    ".google.protobuf.FeatureSet.RepeatedFiel"
+    "dEncodingB-\210\001\001\230\001\004\230\001\001\242\001\r\022\010EXPANDED\030\204\007\242\001\013\022"
+    "\006PACKED\030\347\007\262\001\003\010\350\007\022n\n\017utf8_validation\030\004 \001("
+    "\0162*.google.protobuf.FeatureSet.Utf8Valid"
+    "ationB)\210\001\001\230\001\004\230\001\001\242\001\t\022\004NONE\030\204\007\242\001\013\022\006VERIFY\030"
+    "\347\007\262\001\003\010\350\007\022m\n\020message_encoding\030\005 \001(\0162+.goo"
+    "gle.protobuf.FeatureSet.MessageEncodingB"
+    "&\210\001\001\230\001\004\230\001\001\242\001\024\022\017LENGTH_PREFIXED\030\204\007\262\001\003\010\350\007\022"
+    "v\n\013json_format\030\006 \001(\0162&.google.protobuf.F"
+    "eatureSet.JsonFormatB9\210\001\001\230\001\003\230\001\006\230\001\001\242\001\027\022\022L"
+    "EGACY_BEST_EFFORT\030\204\007\242\001\n\022\005ALLOW\030\347\007\262\001\003\010\350\007\""
+    "\\\n\rFieldPresence\022\032\n\026FIELD_PRESENCE_UNKNO"
+    "WN\020\000\022\014\n\010EXPLICIT\020\001\022\014\n\010IMPLICIT\020\002\022\023\n\017LEGA"
+    "CY_REQUIRED\020\003\"7\n\010EnumType\022\025\n\021ENUM_TYPE_U"
+    "NKNOWN\020\000\022\010\n\004OPEN\020\001\022\n\n\006CLOSED\020\002\"V\n\025Repeat"
+    "edFieldEncoding\022#\n\037REPEATED_FIELD_ENCODI"
+    "NG_UNKNOWN\020\000\022\n\n\006PACKED\020\001\022\014\n\010EXPANDED\020\002\"I"
+    "\n\016Utf8Validation\022\033\n\027UTF8_VALIDATION_UNKN"
+    "OWN\020\000\022\n\n\006VERIFY\020\002\022\010\n\004NONE\020\003\"\004\010\001\020\001\"S\n\017Mes"
+    "sageEncoding\022\034\n\030MESSAGE_ENCODING_UNKNOWN"
+    "\020\000\022\023\n\017LENGTH_PREFIXED\020\001\022\r\n\tDELIMITED\020\002\"H"
+    "\n\nJsonFormat\022\027\n\023JSON_FORMAT_UNKNOWN\020\000\022\t\n"
+    "\005ALLOW\020\001\022\026\n\022LEGACY_BEST_EFFORT\020\002*\006\010\350\007\020\213N"
+    "*\006\010\213N\020\220N*\006\010\220N\020\221NJ\006\010\347\007\020\350\007\"\230\003\n\022FeatureSetD"
+    "efaults\022N\n\010defaults\030\001 \003(\0132<.google.proto"
+    "buf.FeatureSetDefaults.FeatureSetEdition"
+    "Default\0221\n\017minimum_edition\030\004 \001(\0162\030.googl"
+    "e.protobuf.Edition\0221\n\017maximum_edition\030\005 "
+    "\001(\0162\030.google.protobuf.Edition\032\313\001\n\030Featur"
+    "eSetEditionDefault\022)\n\007edition\030\003 \001(\0162\030.go"
+    "ogle.protobuf.Edition\0229\n\024overridable_fea"
+    "tures\030\004 \001(\0132\033.google.protobuf.FeatureSet"
+    "\0223\n\016fixed_features\030\005 \001(\0132\033.google.protob"
+    "uf.FeatureSetJ\004\010\001\020\002J\004\010\002\020\003R\010features\"\325\001\n\016"
+    "SourceCodeInfo\022:\n\010location\030\001 \003(\0132(.googl"
+    "e.protobuf.SourceCodeInfo.Location\032\206\001\n\010L"
+    "ocation\022\020\n\004path\030\001 \003(\005B\002\020\001\022\020\n\004span\030\002 \003(\005B"
+    "\002\020\001\022\030\n\020leading_comments\030\003 \001(\t\022\031\n\021trailin"
+    "g_comments\030\004 \001(\t\022!\n\031leading_detached_com"
+    "ments\030\006 \003(\t\"\234\002\n\021GeneratedCodeInfo\022A\n\nann"
+    "otation\030\001 \003(\0132-.google.protobuf.Generate"
+    "dCodeInfo.Annotation\032\303\001\n\nAnnotation\022\020\n\004p"
+    "ath\030\001 \003(\005B\002\020\001\022\023\n\013source_file\030\002 \001(\t\022\r\n\005be"
+    "gin\030\003 \001(\005\022\013\n\003end\030\004 \001(\005\022H\n\010semantic\030\005 \001(\016"
+    "26.google.protobuf.GeneratedCodeInfo.Ann"
+    "otation.Semantic\"(\n\010Semantic\022\010\n\004NONE\020\000\022\007"
+    "\n\003SET\020\001\022\t\n\005ALIAS\020\002*\247\002\n\007Edition\022\023\n\017EDITIO"
+    "N_UNKNOWN\020\000\022\023\n\016EDITION_LEGACY\020\204\007\022\023\n\016EDIT"
+    "ION_PROTO2\020\346\007\022\023\n\016EDITION_PROTO3\020\347\007\022\021\n\014ED"
+    "ITION_2023\020\350\007\022\021\n\014EDITION_2024\020\351\007\022\027\n\023EDIT"
+    "ION_1_TEST_ONLY\020\001\022\027\n\023EDITION_2_TEST_ONLY"
+    "\020\002\022\035\n\027EDITION_99997_TEST_ONLY\020\235\215\006\022\035\n\027EDI"
+    "TION_99998_TEST_ONLY\020\236\215\006\022\035\n\027EDITION_9999"
+    "9_TEST_ONLY\020\237\215\006\022\023\n\013EDITION_MAX\020\377\377\377\377\007B~\n\023"
+    "com.google.protobufB\020DescriptorProtosH\001Z"
+    "-google.golang.org/protobuf/types/descri"
+    "ptorpb\370\001\001\242\002\003GPB\252\002\032Google.Protobuf.Reflec"
+    "tion"
 };
 static ::absl::once_flag descriptor_table_google_2fprotobuf_2fdescriptor_2eproto_once;
 PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_google_2fprotobuf_2fdescriptor_2eproto = {
     false,
     false,
-    10082,
+    10124,
     descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto,
     "google/protobuf/descriptor.proto",
     &descriptor_table_google_2fprotobuf_2fdescriptor_2eproto_once,
@@ -7929,9 +7933,9 @@ inline void FileOptions::SharedCtor(::_pb::Arena* arena) {
   ::memset(reinterpret_cast<char *>(&_impl_) +
                offsetof(Impl_, features_),
            0,
-           offsetof(Impl_, deprecated_) -
+           offsetof(Impl_, cc_mutable_donated_string_) -
                offsetof(Impl_, features_) +
-               sizeof(Impl_::deprecated_));
+               sizeof(Impl_::cc_mutable_donated_string_));
 }
 FileOptions::~FileOptions() {
   // @@protoc_insertion_point(destructor:google.protobuf.FileOptions)
@@ -7982,15 +7986,15 @@ const ::google::protobuf::MessageLite::ClassData* FileOptions::GetClassData() co
   ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
   return _class_data_.base();
 }
-constexpr ::_pbi::TcParseTable<5, 21, 3, 202, 12> FileOptions::_table_ = {
+constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
   {
     PROTOBUF_FIELD_OFFSET(FileOptions, _impl_._has_bits_),
     PROTOBUF_FIELD_OFFSET(FileOptions, _impl_._extensions_),
     999, 248,  // max_field_number, fast_idx_mask
     offsetof(decltype(_table_), field_lookup_table),
-    3149166718,  // skipmap
+    1001683070,  // skipmap
     offsetof(decltype(_table_), field_entries),
-    21,  // num_field_entries
+    22,  // num_field_entries
     3,  // num_aux_entries
     offsetof(decltype(_table_), aux_entries),
     _class_data_.base(),
@@ -8015,7 +8019,7 @@ constexpr ::_pbi::TcParseTable<5, 21, 3, 202, 12> FileOptions::_table_ = {
      {66, 1, 0, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_outer_classname_)}},
     // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
     {::_pbi::TcParser::FastEr1S1,
-     {72, 18, 3, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.optimize_for_)}},
+     {72, 19, 3, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.optimize_for_)}},
     // optional bool java_multiple_files = 10 [default = false];
     {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(FileOptions, _impl_.java_multiple_files_), 11>(),
      {80, 11, 0, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_multiple_files_)}},
@@ -8065,11 +8069,11 @@ constexpr ::_pbi::TcParseTable<5, 21, 3, 202, 12> FileOptions::_table_ = {
     {::_pbi::TcParser::MiniParse, {}},
     // optional bool cc_enable_arenas = 31 [default = true];
     {::_pbi::TcParser::FastV8S2,
-     {504, 19, 0, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_enable_arenas_)}},
+     {504, 20, 0, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_enable_arenas_)}},
   }}, {{
     36, 0, 1,
-    48324, 12,999, 0, 1,
-     65534, 20,
+    48324, 13,999, 0, 1,
+     65534, 21,
     65535, 65535
   }}, {{
     // optional string java_package = 1;
@@ -8079,7 +8083,7 @@ constexpr ::_pbi::TcParseTable<5, 21, 3, 202, 12> FileOptions::_table_ = {
     {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_outer_classname_), _Internal::kHasBitsOffset + 1, 0,
     (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
     // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
-    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.optimize_for_), _Internal::kHasBitsOffset + 18, 2,
+    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.optimize_for_), _Internal::kHasBitsOffset + 19, 2,
     (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
     // optional bool java_multiple_files = 10 [default = false];
     {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_multiple_files_), _Internal::kHasBitsOffset + 11, 0,
@@ -8106,7 +8110,10 @@ constexpr ::_pbi::TcParseTable<5, 21, 3, 202, 12> FileOptions::_table_ = {
     {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_string_check_utf8_), _Internal::kHasBitsOffset + 13, 0,
     (0 | ::_fl::kFcOptional | ::_fl::kBool)},
     // optional bool cc_enable_arenas = 31 [default = true];
-    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_enable_arenas_), _Internal::kHasBitsOffset + 19, 0,
+    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_enable_arenas_), _Internal::kHasBitsOffset + 20, 0,
+    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
+    // optional bool cc_mutable_donated_string = 32 [default = false];
+    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_mutable_donated_string_), _Internal::kHasBitsOffset + 18, 0,
     (0 | ::_fl::kFcOptional | ::_fl::kBool)},
     // optional string objc_class_prefix = 36;
     {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.objc_class_prefix_), _Internal::kHasBitsOffset + 3, 0,
@@ -8140,7 +8147,7 @@ constexpr ::_pbi::TcParseTable<5, 21, 3, 202, 12> FileOptions::_table_ = {
     {::_pbi::TcParser::GetTable<::google::protobuf::UninterpretedOption>()},
     {1, 3},
   }}, {{
-    "\33\14\24\0\0\12\0\0\0\0\0\0\0\21\20\14\20\15\26\14\0\0\0\0"
+    "\33\14\24\0\0\12\0\0\0\0\0\0\0\0\21\20\14\20\15\26\14\0\0\0"
     "google.protobuf.FileOptions"
     "java_package"
     "java_outer_classname"
@@ -8208,10 +8215,10 @@ PROTOBUF_NOINLINE void FileOptions::Clear() {
         reinterpret_cast<char*>(&_impl_.java_generic_services_) -
         reinterpret_cast<char*>(&_impl_.java_multiple_files_)) + sizeof(_impl_.java_generic_services_));
   }
-  if (cached_has_bits & 0x000f0000u) {
+  if (cached_has_bits & 0x001f0000u) {
     ::memset(&_impl_.py_generic_services_, 0, static_cast<::size_t>(
-        reinterpret_cast<char*>(&_impl_.deprecated_) -
-        reinterpret_cast<char*>(&_impl_.py_generic_services_)) + sizeof(_impl_.deprecated_));
+        reinterpret_cast<char*>(&_impl_.cc_mutable_donated_string_) -
+        reinterpret_cast<char*>(&_impl_.py_generic_services_)) + sizeof(_impl_.cc_mutable_donated_string_));
     _impl_.optimize_for_ = 1;
     _impl_.cc_enable_arenas_ = true;
   }
@@ -8252,7 +8259,7 @@ PROTOBUF_NOINLINE void FileOptions::Clear() {
           }
 
           // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
-          if (cached_has_bits & 0x00040000u) {
+          if (cached_has_bits & 0x00080000u) {
             target = stream->EnsureSpace(target);
             target = ::_pbi::WireFormatLite::WriteEnumToArray(
                 9, this_._internal_optimize_for(), target);
@@ -8316,12 +8323,19 @@ PROTOBUF_NOINLINE void FileOptions::Clear() {
           }
 
           // optional bool cc_enable_arenas = 31 [default = true];
-          if (cached_has_bits & 0x00080000u) {
+          if (cached_has_bits & 0x00100000u) {
             target = stream->EnsureSpace(target);
             target = ::_pbi::WireFormatLite::WriteBoolToArray(
                 31, this_._internal_cc_enable_arenas(), target);
           }
 
+          // optional bool cc_mutable_donated_string = 32 [default = false];
+          if (cached_has_bits & 0x00040000u) {
+            target = stream->EnsureSpace(target);
+            target = ::_pbi::WireFormatLite::WriteBoolToArray(
+                32, this_._internal_cc_mutable_donated_string(), target);
+          }
+
           // optional string objc_class_prefix = 36;
           if (cached_has_bits & 0x00000008u) {
             const std::string& _s = this_._internal_objc_class_prefix();
@@ -8513,7 +8527,7 @@ PROTOBUF_NOINLINE void FileOptions::Clear() {
               total_size += 3;
             }
           }
-          if (cached_has_bits & 0x000f0000u) {
+          if (cached_has_bits & 0x001f0000u) {
             // optional bool py_generic_services = 18 [default = false];
             if (cached_has_bits & 0x00010000u) {
               total_size += 3;
@@ -8522,13 +8536,17 @@ PROTOBUF_NOINLINE void FileOptions::Clear() {
             if (cached_has_bits & 0x00020000u) {
               total_size += 3;
             }
-            // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
+            // optional bool cc_mutable_donated_string = 32 [default = false];
             if (cached_has_bits & 0x00040000u) {
+              total_size += 3;
+            }
+            // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
+            if (cached_has_bits & 0x00080000u) {
               total_size += 1 +
                             ::_pbi::WireFormatLite::EnumSize(this_._internal_optimize_for());
             }
             // optional bool cc_enable_arenas = 31 [default = true];
-            if (cached_has_bits & 0x00080000u) {
+            if (cached_has_bits & 0x00100000u) {
               total_size += 3;
             }
           }
@@ -8606,7 +8624,7 @@ void FileOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::goo
       _this->_impl_.java_generic_services_ = from._impl_.java_generic_services_;
     }
   }
-  if (cached_has_bits & 0x000f0000u) {
+  if (cached_has_bits & 0x001f0000u) {
     if (cached_has_bits & 0x00010000u) {
       _this->_impl_.py_generic_services_ = from._impl_.py_generic_services_;
     }
@@ -8614,9 +8632,12 @@ void FileOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::goo
       _this->_impl_.deprecated_ = from._impl_.deprecated_;
     }
     if (cached_has_bits & 0x00040000u) {
-      _this->_impl_.optimize_for_ = from._impl_.optimize_for_;
+      _this->_impl_.cc_mutable_donated_string_ = from._impl_.cc_mutable_donated_string_;
     }
     if (cached_has_bits & 0x00080000u) {
+      _this->_impl_.optimize_for_ = from._impl_.optimize_for_;
+    }
+    if (cached_has_bits & 0x00100000u) {
       _this->_impl_.cc_enable_arenas_ = from._impl_.cc_enable_arenas_;
     }
   }
diff --git a/src/google/protobuf/descriptor.pb.h b/src/google/protobuf/descriptor.pb.h
index 247c54b57..f825e89f0 100644
--- a/src/google/protobuf/descriptor.pb.h
+++ b/src/google/protobuf/descriptor.pb.h
@@ -865,6 +865,7 @@ class PROTOBUF_EXPORT UninterpretedOption_NamePart final : public ::google::prot
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_part(
       const std::string& value);
   std::string* _internal_mutable_name_part();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_part_accessor();
 
   public:
   // required bool is_extension = 2;
@@ -1133,6 +1134,7 @@ class PROTOBUF_EXPORT SourceCodeInfo_Location final : public ::google::protobuf:
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_leading_comments(
       const std::string& value);
   std::string* _internal_mutable_leading_comments();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_leading_comments_accessor();
 
   public:
   // optional string trailing_comments = 4;
@@ -1150,6 +1152,7 @@ class PROTOBUF_EXPORT SourceCodeInfo_Location final : public ::google::protobuf:
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_trailing_comments(
       const std::string& value);
   std::string* _internal_mutable_trailing_comments();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_trailing_comments_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.SourceCodeInfo.Location)
@@ -1392,6 +1395,7 @@ class PROTOBUF_EXPORT GeneratedCodeInfo_Annotation final : public ::google::prot
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_file(
       const std::string& value);
   std::string* _internal_mutable_source_file();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_source_file_accessor();
 
   public:
   // optional int32 begin = 3;
@@ -1627,6 +1631,7 @@ class PROTOBUF_EXPORT FieldOptions_FeatureSupport final : public ::google::proto
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecation_warning(
       const std::string& value);
   std::string* _internal_mutable_deprecation_warning();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_deprecation_warning_accessor();
 
   public:
   // optional .google.protobuf.Edition edition_introduced = 1;
@@ -1858,6 +1863,7 @@ class PROTOBUF_EXPORT FieldOptions_EditionDefault final : public ::google::proto
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
       const std::string& value);
   std::string* _internal_mutable_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_value_accessor();
 
   public:
   // optional .google.protobuf.Edition edition = 3;
@@ -2627,6 +2633,7 @@ class PROTOBUF_EXPORT ExtensionRangeOptions_Declaration final : public ::google:
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(
       const std::string& value);
   std::string* _internal_mutable_full_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_full_name_accessor();
 
   public:
   // optional string type = 3;
@@ -2644,6 +2651,7 @@ class PROTOBUF_EXPORT ExtensionRangeOptions_Declaration final : public ::google:
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
       const std::string& value);
   std::string* _internal_mutable_type();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_type_accessor();
 
   public:
   // optional int32 number = 1;
@@ -3306,6 +3314,7 @@ class PROTOBUF_EXPORT UninterpretedOption final : public ::google::protobuf::Mes
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier_value(
       const std::string& value);
   std::string* _internal_mutable_identifier_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_identifier_value_accessor();
 
   public:
   // optional bytes string_value = 7;
@@ -3323,6 +3332,7 @@ class PROTOBUF_EXPORT UninterpretedOption final : public ::google::protobuf::Mes
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
       const std::string& value);
   std::string* _internal_mutable_string_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_string_value_accessor();
 
   public:
   // optional string aggregate_value = 8;
@@ -3340,6 +3350,7 @@ class PROTOBUF_EXPORT UninterpretedOption final : public ::google::protobuf::Mes
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregate_value(
       const std::string& value);
   std::string* _internal_mutable_aggregate_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_aggregate_value_accessor();
 
   public:
   // optional uint64 positive_int_value = 4;
@@ -5923,6 +5934,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
     kJavaGenericServicesFieldNumber = 17,
     kPyGenericServicesFieldNumber = 18,
     kDeprecatedFieldNumber = 23,
+    kCcMutableDonatedStringFieldNumber = 32,
     kOptimizeForFieldNumber = 9,
     kCcEnableArenasFieldNumber = 31,
   };
@@ -5958,6 +5970,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_java_package(
       const std::string& value);
   std::string* _internal_mutable_java_package();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_java_package_accessor();
 
   public:
   // optional string java_outer_classname = 8;
@@ -5975,6 +5988,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_java_outer_classname(
       const std::string& value);
   std::string* _internal_mutable_java_outer_classname();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_java_outer_classname_accessor();
 
   public:
   // optional string go_package = 11;
@@ -5992,6 +6006,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_go_package(
       const std::string& value);
   std::string* _internal_mutable_go_package();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_go_package_accessor();
 
   public:
   // optional string objc_class_prefix = 36;
@@ -6009,6 +6024,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_objc_class_prefix(
       const std::string& value);
   std::string* _internal_mutable_objc_class_prefix();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_objc_class_prefix_accessor();
 
   public:
   // optional string csharp_namespace = 37;
@@ -6026,6 +6042,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_csharp_namespace(
       const std::string& value);
   std::string* _internal_mutable_csharp_namespace();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_csharp_namespace_accessor();
 
   public:
   // optional string swift_prefix = 39;
@@ -6043,6 +6060,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_swift_prefix(
       const std::string& value);
   std::string* _internal_mutable_swift_prefix();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_swift_prefix_accessor();
 
   public:
   // optional string php_class_prefix = 40;
@@ -6060,6 +6078,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_php_class_prefix(
       const std::string& value);
   std::string* _internal_mutable_php_class_prefix();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_php_class_prefix_accessor();
 
   public:
   // optional string php_namespace = 41;
@@ -6077,6 +6096,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_php_namespace(
       const std::string& value);
   std::string* _internal_mutable_php_namespace();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_php_namespace_accessor();
 
   public:
   // optional string php_metadata_namespace = 44;
@@ -6094,6 +6114,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_php_metadata_namespace(
       const std::string& value);
   std::string* _internal_mutable_php_metadata_namespace();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_php_metadata_namespace_accessor();
 
   public:
   // optional string ruby_package = 45;
@@ -6111,6 +6132,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruby_package(
       const std::string& value);
   std::string* _internal_mutable_ruby_package();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_ruby_package_accessor();
 
   public:
   // optional .google.protobuf.FeatureSet features = 50;
@@ -6204,6 +6226,17 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   bool _internal_deprecated() const;
   void _internal_set_deprecated(bool value);
 
+  public:
+  // optional bool cc_mutable_donated_string = 32 [default = false];
+  bool has_cc_mutable_donated_string() const;
+  void clear_cc_mutable_donated_string() ;
+  bool cc_mutable_donated_string() const;
+  void set_cc_mutable_donated_string(bool value);
+
+  private:
+  bool _internal_cc_mutable_donated_string() const;
+  void _internal_set_cc_mutable_donated_string(bool value);
+
   public:
   // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
   bool has_optimize_for() const;
@@ -6411,7 +6444,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
   class _Internal;
   friend class ::google::protobuf::internal::TcParser;
   static const ::google::protobuf::internal::TcParseTable<
-      5, 21, 3,
+      5, 22, 3,
       202, 12>
       _table_;
 
@@ -6452,6 +6485,7 @@ class PROTOBUF_EXPORT FileOptions final : public ::google::protobuf::Message
     bool java_generic_services_;
     bool py_generic_services_;
     bool deprecated_;
+    bool cc_mutable_donated_string_;
     int optimize_for_;
     bool cc_enable_arenas_;
     PROTOBUF_TSAN_DECLARE_MEMBER
@@ -8832,6 +8866,7 @@ class PROTOBUF_EXPORT OneofDescriptorProto final : public ::google::protobuf::Me
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.OneofOptions options = 2;
@@ -9052,6 +9087,7 @@ class PROTOBUF_EXPORT MethodDescriptorProto final : public ::google::protobuf::M
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional string input_type = 2;
@@ -9069,6 +9105,7 @@ class PROTOBUF_EXPORT MethodDescriptorProto final : public ::google::protobuf::M
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_type(
       const std::string& value);
   std::string* _internal_mutable_input_type();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_input_type_accessor();
 
   public:
   // optional string output_type = 3;
@@ -9086,6 +9123,7 @@ class PROTOBUF_EXPORT MethodDescriptorProto final : public ::google::protobuf::M
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_type(
       const std::string& value);
   std::string* _internal_mutable_output_type();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_output_type_accessor();
 
   public:
   // optional .google.protobuf.MethodOptions options = 4;
@@ -9392,6 +9430,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final : public ::google::protobuf::Me
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional string extendee = 2;
@@ -9409,6 +9448,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final : public ::google::protobuf::Me
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_extendee(
       const std::string& value);
   std::string* _internal_mutable_extendee();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_extendee_accessor();
 
   public:
   // optional string type_name = 6;
@@ -9426,6 +9466,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final : public ::google::protobuf::Me
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_name(
       const std::string& value);
   std::string* _internal_mutable_type_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_type_name_accessor();
 
   public:
   // optional string default_value = 7;
@@ -9443,6 +9484,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final : public ::google::protobuf::Me
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(
       const std::string& value);
   std::string* _internal_mutable_default_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_default_value_accessor();
 
   public:
   // optional string json_name = 10;
@@ -9460,6 +9502,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final : public ::google::protobuf::Me
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_json_name(
       const std::string& value);
   std::string* _internal_mutable_json_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_json_name_accessor();
 
   public:
   // optional .google.protobuf.FieldOptions options = 8;
@@ -9741,6 +9784,7 @@ class PROTOBUF_EXPORT EnumValueDescriptorProto final : public ::google::protobuf
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.EnumValueOptions options = 3;
@@ -10210,6 +10254,7 @@ class PROTOBUF_EXPORT ServiceDescriptorProto final : public ::google::protobuf::
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.ServiceOptions options = 3;
@@ -10487,6 +10532,7 @@ class PROTOBUF_EXPORT EnumDescriptorProto final : public ::google::protobuf::Mes
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.EnumOptions options = 3;
@@ -10857,6 +10903,7 @@ class PROTOBUF_EXPORT DescriptorProto final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.MessageOptions options = 7;
@@ -11218,6 +11265,7 @@ class PROTOBUF_EXPORT FileDescriptorProto final : public ::google::protobuf::Mes
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional string package = 2;
@@ -11235,6 +11283,7 @@ class PROTOBUF_EXPORT FileDescriptorProto final : public ::google::protobuf::Mes
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_package(
       const std::string& value);
   std::string* _internal_mutable_package();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_package_accessor();
 
   public:
   // optional string syntax = 12;
@@ -11252,6 +11301,7 @@ class PROTOBUF_EXPORT FileDescriptorProto final : public ::google::protobuf::Mes
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_syntax(
       const std::string& value);
   std::string* _internal_mutable_syntax();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_syntax_accessor();
 
   public:
   // optional .google.protobuf.FileOptions options = 8;
@@ -11631,7 +11681,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.name)
 }
 inline std::string* FileDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileDescriptorProto.name)
   return _s;
 }
@@ -11649,6 +11699,11 @@ inline std::string* FileDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileDescriptorProto::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* FileDescriptorProto::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileDescriptorProto.name)
@@ -11702,7 +11757,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileDescriptorProto::set_package(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.package)
 }
 inline std::string* FileDescriptorProto::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_package();
+  auto _s = _internal_mutable_package();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileDescriptorProto.package)
   return _s;
 }
@@ -11720,6 +11775,11 @@ inline std::string* FileDescriptorProto::_internal_mutable_package() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.package_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileDescriptorProto::_internal_mutable_package_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.package_.MutableAccessor( GetArena());
+}
 inline std::string* FileDescriptorProto::release_package() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileDescriptorProto.package)
@@ -11762,7 +11822,7 @@ inline void FileDescriptorProto::clear_dependency() {
 }
 inline std::string* FileDescriptorProto::add_dependency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
   ::google::protobuf::internal::TSanWrite(&_impl_);
-  std::string* _s = _internal_mutable_dependency()->Add();
+  auto _s = _internal_mutable_dependency()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.FileDescriptorProto.dependency)
   return _s;
 }
@@ -11774,12 +11834,12 @@ inline const std::string& FileDescriptorProto::dependency(int index) const
 inline std::string* FileDescriptorProto::mutable_dependency(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileDescriptorProto.dependency)
-  return _internal_mutable_dependency()->Mutable(index);
+  return _internal_mutable_dependency()->MutableString(index);
 }
 template <typename Arg_, typename... Args_>
 inline void FileDescriptorProto::set_dependency(int index, Arg_&& value, Args_... args) {
   ::google::protobuf::internal::AssignToString(
-      *_internal_mutable_dependency()->Mutable(index),
+      *_internal_mutable_dependency()->MutableAccessor(index),
       std::forward<Arg_>(value), args... );
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.dependency)
 }
@@ -12315,7 +12375,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileDescriptorProto::set_syntax(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.syntax)
 }
 inline std::string* FileDescriptorProto::mutable_syntax() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_syntax();
+  auto _s = _internal_mutable_syntax();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileDescriptorProto.syntax)
   return _s;
 }
@@ -12333,6 +12393,11 @@ inline std::string* FileDescriptorProto::_internal_mutable_syntax() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.syntax_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileDescriptorProto::_internal_mutable_syntax_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.syntax_.MutableAccessor( GetArena());
+}
 inline std::string* FileDescriptorProto::release_syntax() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileDescriptorProto.syntax)
@@ -12635,7 +12700,7 @@ inline PROTOBUF_ALWAYS_INLINE void DescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.DescriptorProto.name)
 }
 inline std::string* DescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.DescriptorProto.name)
   return _s;
 }
@@ -12653,6 +12718,11 @@ inline std::string* DescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor DescriptorProto::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* DescriptorProto::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.DescriptorProto.name)
@@ -13134,7 +13204,7 @@ inline void DescriptorProto::clear_reserved_name() {
 }
 inline std::string* DescriptorProto::add_reserved_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
   ::google::protobuf::internal::TSanWrite(&_impl_);
-  std::string* _s = _internal_mutable_reserved_name()->Add();
+  auto _s = _internal_mutable_reserved_name()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.DescriptorProto.reserved_name)
   return _s;
 }
@@ -13146,12 +13216,12 @@ inline const std::string& DescriptorProto::reserved_name(int index) const
 inline std::string* DescriptorProto::mutable_reserved_name(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.DescriptorProto.reserved_name)
-  return _internal_mutable_reserved_name()->Mutable(index);
+  return _internal_mutable_reserved_name()->MutableString(index);
 }
 template <typename Arg_, typename... Args_>
 inline void DescriptorProto::set_reserved_name(int index, Arg_&& value, Args_... args) {
   ::google::protobuf::internal::AssignToString(
-      *_internal_mutable_reserved_name()->Mutable(index),
+      *_internal_mutable_reserved_name()->MutableAccessor(index),
       std::forward<Arg_>(value), args... );
   // @@protoc_insertion_point(field_set:google.protobuf.DescriptorProto.reserved_name)
 }
@@ -13241,7 +13311,7 @@ inline PROTOBUF_ALWAYS_INLINE void ExtensionRangeOptions_Declaration::set_full_n
   // @@protoc_insertion_point(field_set:google.protobuf.ExtensionRangeOptions.Declaration.full_name)
 }
 inline std::string* ExtensionRangeOptions_Declaration::mutable_full_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_full_name();
+  auto _s = _internal_mutable_full_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.ExtensionRangeOptions.Declaration.full_name)
   return _s;
 }
@@ -13259,6 +13329,11 @@ inline std::string* ExtensionRangeOptions_Declaration::_internal_mutable_full_na
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.full_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor ExtensionRangeOptions_Declaration::_internal_mutable_full_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.full_name_.MutableAccessor( GetArena());
+}
 inline std::string* ExtensionRangeOptions_Declaration::release_full_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.ExtensionRangeOptions.Declaration.full_name)
@@ -13312,7 +13387,7 @@ inline PROTOBUF_ALWAYS_INLINE void ExtensionRangeOptions_Declaration::set_type(A
   // @@protoc_insertion_point(field_set:google.protobuf.ExtensionRangeOptions.Declaration.type)
 }
 inline std::string* ExtensionRangeOptions_Declaration::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_type();
+  auto _s = _internal_mutable_type();
   // @@protoc_insertion_point(field_mutable:google.protobuf.ExtensionRangeOptions.Declaration.type)
   return _s;
 }
@@ -13330,6 +13405,11 @@ inline std::string* ExtensionRangeOptions_Declaration::_internal_mutable_type()
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.type_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor ExtensionRangeOptions_Declaration::_internal_mutable_type_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.type_.MutableAccessor( GetArena());
+}
 inline std::string* ExtensionRangeOptions_Declaration::release_type() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.ExtensionRangeOptions.Declaration.type)
@@ -13670,7 +13750,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.name)
 }
 inline std::string* FieldDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.name)
   return _s;
 }
@@ -13688,6 +13768,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.name)
@@ -13827,7 +13912,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_type_name(Arg_&& ar
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.type_name)
 }
 inline std::string* FieldDescriptorProto::mutable_type_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_type_name();
+  auto _s = _internal_mutable_type_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.type_name)
   return _s;
 }
@@ -13845,6 +13930,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_type_name() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.type_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_type_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.type_name_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_type_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.type_name)
@@ -13898,7 +13988,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_extendee(Arg_&& arg
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.extendee)
 }
 inline std::string* FieldDescriptorProto::mutable_extendee() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_extendee();
+  auto _s = _internal_mutable_extendee();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.extendee)
   return _s;
 }
@@ -13916,6 +14006,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_extendee() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.extendee_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_extendee_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.extendee_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_extendee() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.extendee)
@@ -13969,7 +14064,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_default_value(Arg_&
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.default_value)
 }
 inline std::string* FieldDescriptorProto::mutable_default_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_default_value();
+  auto _s = _internal_mutable_default_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.default_value)
   return _s;
 }
@@ -13987,6 +14082,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_default_value() {
   _impl_._has_bits_[0] |= 0x00000008u;
   return _impl_.default_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_default_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000008u;
+  return _impl_.default_value_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_default_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.default_value)
@@ -14068,7 +14168,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_json_name(Arg_&& ar
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.json_name)
 }
 inline std::string* FieldDescriptorProto::mutable_json_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_json_name();
+  auto _s = _internal_mutable_json_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.json_name)
   return _s;
 }
@@ -14086,6 +14186,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_json_name() {
   _impl_._has_bits_[0] |= 0x00000010u;
   return _impl_.json_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_json_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000010u;
+  return _impl_.json_name_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_json_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.json_name)
@@ -14267,7 +14372,7 @@ inline PROTOBUF_ALWAYS_INLINE void OneofDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.OneofDescriptorProto.name)
 }
 inline std::string* OneofDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.OneofDescriptorProto.name)
   return _s;
 }
@@ -14285,6 +14390,11 @@ inline std::string* OneofDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor OneofDescriptorProto::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* OneofDescriptorProto::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.OneofDescriptorProto.name)
@@ -14498,7 +14608,7 @@ inline PROTOBUF_ALWAYS_INLINE void EnumDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.EnumDescriptorProto.name)
 }
 inline std::string* EnumDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.EnumDescriptorProto.name)
   return _s;
 }
@@ -14516,6 +14626,11 @@ inline std::string* EnumDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor EnumDescriptorProto::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* EnumDescriptorProto::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.EnumDescriptorProto.name)
@@ -14752,7 +14867,7 @@ inline void EnumDescriptorProto::clear_reserved_name() {
 }
 inline std::string* EnumDescriptorProto::add_reserved_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
   ::google::protobuf::internal::TSanWrite(&_impl_);
-  std::string* _s = _internal_mutable_reserved_name()->Add();
+  auto _s = _internal_mutable_reserved_name()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.EnumDescriptorProto.reserved_name)
   return _s;
 }
@@ -14764,12 +14879,12 @@ inline const std::string& EnumDescriptorProto::reserved_name(int index) const
 inline std::string* EnumDescriptorProto::mutable_reserved_name(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.EnumDescriptorProto.reserved_name)
-  return _internal_mutable_reserved_name()->Mutable(index);
+  return _internal_mutable_reserved_name()->MutableString(index);
 }
 template <typename Arg_, typename... Args_>
 inline void EnumDescriptorProto::set_reserved_name(int index, Arg_&& value, Args_... args) {
   ::google::protobuf::internal::AssignToString(
-      *_internal_mutable_reserved_name()->Mutable(index),
+      *_internal_mutable_reserved_name()->MutableAccessor(index),
       std::forward<Arg_>(value), args... );
   // @@protoc_insertion_point(field_set:google.protobuf.EnumDescriptorProto.reserved_name)
 }
@@ -14831,7 +14946,7 @@ inline PROTOBUF_ALWAYS_INLINE void EnumValueDescriptorProto::set_name(Arg_&& arg
   // @@protoc_insertion_point(field_set:google.protobuf.EnumValueDescriptorProto.name)
 }
 inline std::string* EnumValueDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.EnumValueDescriptorProto.name)
   return _s;
 }
@@ -14849,6 +14964,11 @@ inline std::string* EnumValueDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor EnumValueDescriptorProto::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* EnumValueDescriptorProto::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.EnumValueDescriptorProto.name)
@@ -15030,7 +15150,7 @@ inline PROTOBUF_ALWAYS_INLINE void ServiceDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.ServiceDescriptorProto.name)
 }
 inline std::string* ServiceDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.ServiceDescriptorProto.name)
   return _s;
 }
@@ -15048,6 +15168,11 @@ inline std::string* ServiceDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor ServiceDescriptorProto::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* ServiceDescriptorProto::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.ServiceDescriptorProto.name)
@@ -15250,7 +15375,7 @@ inline PROTOBUF_ALWAYS_INLINE void MethodDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.MethodDescriptorProto.name)
 }
 inline std::string* MethodDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.MethodDescriptorProto.name)
   return _s;
 }
@@ -15268,6 +15393,11 @@ inline std::string* MethodDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor MethodDescriptorProto::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* MethodDescriptorProto::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.MethodDescriptorProto.name)
@@ -15321,7 +15451,7 @@ inline PROTOBUF_ALWAYS_INLINE void MethodDescriptorProto::set_input_type(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.MethodDescriptorProto.input_type)
 }
 inline std::string* MethodDescriptorProto::mutable_input_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_input_type();
+  auto _s = _internal_mutable_input_type();
   // @@protoc_insertion_point(field_mutable:google.protobuf.MethodDescriptorProto.input_type)
   return _s;
 }
@@ -15339,6 +15469,11 @@ inline std::string* MethodDescriptorProto::_internal_mutable_input_type() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.input_type_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor MethodDescriptorProto::_internal_mutable_input_type_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.input_type_.MutableAccessor( GetArena());
+}
 inline std::string* MethodDescriptorProto::release_input_type() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.MethodDescriptorProto.input_type)
@@ -15392,7 +15527,7 @@ inline PROTOBUF_ALWAYS_INLINE void MethodDescriptorProto::set_output_type(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.MethodDescriptorProto.output_type)
 }
 inline std::string* MethodDescriptorProto::mutable_output_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_output_type();
+  auto _s = _internal_mutable_output_type();
   // @@protoc_insertion_point(field_mutable:google.protobuf.MethodDescriptorProto.output_type)
   return _s;
 }
@@ -15410,6 +15545,11 @@ inline std::string* MethodDescriptorProto::_internal_mutable_output_type() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.output_type_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor MethodDescriptorProto::_internal_mutable_output_type_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.output_type_.MutableAccessor( GetArena());
+}
 inline std::string* MethodDescriptorProto::release_output_type() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.MethodDescriptorProto.output_type)
@@ -15619,7 +15759,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_java_package(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.java_package)
 }
 inline std::string* FileOptions::mutable_java_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_java_package();
+  auto _s = _internal_mutable_java_package();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.java_package)
   return _s;
 }
@@ -15637,6 +15777,11 @@ inline std::string* FileOptions::_internal_mutable_java_package() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.java_package_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_java_package_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.java_package_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_java_package() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.java_package)
@@ -15690,7 +15835,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_java_outer_classname(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.java_outer_classname)
 }
 inline std::string* FileOptions::mutable_java_outer_classname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_java_outer_classname();
+  auto _s = _internal_mutable_java_outer_classname();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.java_outer_classname)
   return _s;
 }
@@ -15708,6 +15853,11 @@ inline std::string* FileOptions::_internal_mutable_java_outer_classname() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.java_outer_classname_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_java_outer_classname_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.java_outer_classname_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_java_outer_classname() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.java_outer_classname)
@@ -15823,13 +15973,13 @@ inline void FileOptions::_internal_set_java_string_check_utf8(bool value) {
 
 // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
 inline bool FileOptions::has_optimize_for() const {
-  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
+  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
   return value;
 }
 inline void FileOptions::clear_optimize_for() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   _impl_.optimize_for_ = 1;
-  _impl_._has_bits_[0] &= ~0x00040000u;
+  _impl_._has_bits_[0] &= ~0x00080000u;
 }
 inline ::google::protobuf::FileOptions_OptimizeMode FileOptions::optimize_for() const {
   // @@protoc_insertion_point(field_get:google.protobuf.FileOptions.optimize_for)
@@ -15837,7 +15987,7 @@ inline ::google::protobuf::FileOptions_OptimizeMode FileOptions::optimize_for()
 }
 inline void FileOptions::set_optimize_for(::google::protobuf::FileOptions_OptimizeMode value) {
   _internal_set_optimize_for(value);
-  _impl_._has_bits_[0] |= 0x00040000u;
+  _impl_._has_bits_[0] |= 0x00080000u;
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.optimize_for)
 }
 inline ::google::protobuf::FileOptions_OptimizeMode FileOptions::_internal_optimize_for() const {
@@ -15874,7 +16024,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_go_package(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.go_package)
 }
 inline std::string* FileOptions::mutable_go_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_go_package();
+  auto _s = _internal_mutable_go_package();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.go_package)
   return _s;
 }
@@ -15892,6 +16042,11 @@ inline std::string* FileOptions::_internal_mutable_go_package() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.go_package_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_go_package_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.go_package_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_go_package() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.go_package)
@@ -16035,13 +16190,13 @@ inline void FileOptions::_internal_set_deprecated(bool value) {
 
 // optional bool cc_enable_arenas = 31 [default = true];
 inline bool FileOptions::has_cc_enable_arenas() const {
-  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
+  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
   return value;
 }
 inline void FileOptions::clear_cc_enable_arenas() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   _impl_.cc_enable_arenas_ = true;
-  _impl_._has_bits_[0] &= ~0x00080000u;
+  _impl_._has_bits_[0] &= ~0x00100000u;
 }
 inline bool FileOptions::cc_enable_arenas() const {
   // @@protoc_insertion_point(field_get:google.protobuf.FileOptions.cc_enable_arenas)
@@ -16049,7 +16204,7 @@ inline bool FileOptions::cc_enable_arenas() const {
 }
 inline void FileOptions::set_cc_enable_arenas(bool value) {
   _internal_set_cc_enable_arenas(value);
-  _impl_._has_bits_[0] |= 0x00080000u;
+  _impl_._has_bits_[0] |= 0x00100000u;
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.cc_enable_arenas)
 }
 inline bool FileOptions::_internal_cc_enable_arenas() const {
@@ -16061,6 +16216,34 @@ inline void FileOptions::_internal_set_cc_enable_arenas(bool value) {
   _impl_.cc_enable_arenas_ = value;
 }
 
+// optional bool cc_mutable_donated_string = 32 [default = false];
+inline bool FileOptions::has_cc_mutable_donated_string() const {
+  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
+  return value;
+}
+inline void FileOptions::clear_cc_mutable_donated_string() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_.cc_mutable_donated_string_ = false;
+  _impl_._has_bits_[0] &= ~0x00040000u;
+}
+inline bool FileOptions::cc_mutable_donated_string() const {
+  // @@protoc_insertion_point(field_get:google.protobuf.FileOptions.cc_mutable_donated_string)
+  return _internal_cc_mutable_donated_string();
+}
+inline void FileOptions::set_cc_mutable_donated_string(bool value) {
+  _internal_set_cc_mutable_donated_string(value);
+  _impl_._has_bits_[0] |= 0x00040000u;
+  // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.cc_mutable_donated_string)
+}
+inline bool FileOptions::_internal_cc_mutable_donated_string() const {
+  ::google::protobuf::internal::TSanRead(&_impl_);
+  return _impl_.cc_mutable_donated_string_;
+}
+inline void FileOptions::_internal_set_cc_mutable_donated_string(bool value) {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_.cc_mutable_donated_string_ = value;
+}
+
 // optional string objc_class_prefix = 36;
 inline bool FileOptions::has_objc_class_prefix() const {
   bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
@@ -16085,7 +16268,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_objc_class_prefix(Arg_&& arg
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.objc_class_prefix)
 }
 inline std::string* FileOptions::mutable_objc_class_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_objc_class_prefix();
+  auto _s = _internal_mutable_objc_class_prefix();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.objc_class_prefix)
   return _s;
 }
@@ -16103,6 +16286,11 @@ inline std::string* FileOptions::_internal_mutable_objc_class_prefix() {
   _impl_._has_bits_[0] |= 0x00000008u;
   return _impl_.objc_class_prefix_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_objc_class_prefix_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000008u;
+  return _impl_.objc_class_prefix_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_objc_class_prefix() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.objc_class_prefix)
@@ -16156,7 +16344,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_csharp_namespace(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.csharp_namespace)
 }
 inline std::string* FileOptions::mutable_csharp_namespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_csharp_namespace();
+  auto _s = _internal_mutable_csharp_namespace();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.csharp_namespace)
   return _s;
 }
@@ -16174,6 +16362,11 @@ inline std::string* FileOptions::_internal_mutable_csharp_namespace() {
   _impl_._has_bits_[0] |= 0x00000010u;
   return _impl_.csharp_namespace_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_csharp_namespace_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000010u;
+  return _impl_.csharp_namespace_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_csharp_namespace() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.csharp_namespace)
@@ -16227,7 +16420,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_swift_prefix(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.swift_prefix)
 }
 inline std::string* FileOptions::mutable_swift_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_swift_prefix();
+  auto _s = _internal_mutable_swift_prefix();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.swift_prefix)
   return _s;
 }
@@ -16245,6 +16438,11 @@ inline std::string* FileOptions::_internal_mutable_swift_prefix() {
   _impl_._has_bits_[0] |= 0x00000020u;
   return _impl_.swift_prefix_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_swift_prefix_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000020u;
+  return _impl_.swift_prefix_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_swift_prefix() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.swift_prefix)
@@ -16298,7 +16496,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_php_class_prefix(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.php_class_prefix)
 }
 inline std::string* FileOptions::mutable_php_class_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_php_class_prefix();
+  auto _s = _internal_mutable_php_class_prefix();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.php_class_prefix)
   return _s;
 }
@@ -16316,6 +16514,11 @@ inline std::string* FileOptions::_internal_mutable_php_class_prefix() {
   _impl_._has_bits_[0] |= 0x00000040u;
   return _impl_.php_class_prefix_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_php_class_prefix_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000040u;
+  return _impl_.php_class_prefix_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_php_class_prefix() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.php_class_prefix)
@@ -16369,7 +16572,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_php_namespace(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.php_namespace)
 }
 inline std::string* FileOptions::mutable_php_namespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_php_namespace();
+  auto _s = _internal_mutable_php_namespace();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.php_namespace)
   return _s;
 }
@@ -16387,6 +16590,11 @@ inline std::string* FileOptions::_internal_mutable_php_namespace() {
   _impl_._has_bits_[0] |= 0x00000080u;
   return _impl_.php_namespace_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_php_namespace_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000080u;
+  return _impl_.php_namespace_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_php_namespace() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.php_namespace)
@@ -16440,7 +16648,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_php_metadata_namespace(Arg_&
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.php_metadata_namespace)
 }
 inline std::string* FileOptions::mutable_php_metadata_namespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_php_metadata_namespace();
+  auto _s = _internal_mutable_php_metadata_namespace();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.php_metadata_namespace)
   return _s;
 }
@@ -16458,6 +16666,11 @@ inline std::string* FileOptions::_internal_mutable_php_metadata_namespace() {
   _impl_._has_bits_[0] |= 0x00000100u;
   return _impl_.php_metadata_namespace_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_php_metadata_namespace_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000100u;
+  return _impl_.php_metadata_namespace_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_php_metadata_namespace() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.php_metadata_namespace)
@@ -16511,7 +16724,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_ruby_package(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.ruby_package)
 }
 inline std::string* FileOptions::mutable_ruby_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_ruby_package();
+  auto _s = _internal_mutable_ruby_package();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.ruby_package)
   return _s;
 }
@@ -16529,6 +16742,11 @@ inline std::string* FileOptions::_internal_mutable_ruby_package() {
   _impl_._has_bits_[0] |= 0x00000200u;
   return _impl_.ruby_package_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_ruby_package_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000200u;
+  return _impl_.ruby_package_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_ruby_package() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.ruby_package)
@@ -17049,7 +17267,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldOptions_EditionDefault::set_value(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.FieldOptions.EditionDefault.value)
 }
 inline std::string* FieldOptions_EditionDefault::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_value();
+  auto _s = _internal_mutable_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldOptions.EditionDefault.value)
   return _s;
 }
@@ -17067,6 +17285,11 @@ inline std::string* FieldOptions_EditionDefault::_internal_mutable_value() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldOptions_EditionDefault::_internal_mutable_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.value_.MutableAccessor( GetArena());
+}
 inline std::string* FieldOptions_EditionDefault::release_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldOptions.EditionDefault.value)
@@ -17182,7 +17405,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldOptions_FeatureSupport::set_deprecation_
   // @@protoc_insertion_point(field_set:google.protobuf.FieldOptions.FeatureSupport.deprecation_warning)
 }
 inline std::string* FieldOptions_FeatureSupport::mutable_deprecation_warning() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_deprecation_warning();
+  auto _s = _internal_mutable_deprecation_warning();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldOptions.FeatureSupport.deprecation_warning)
   return _s;
 }
@@ -17200,6 +17423,11 @@ inline std::string* FieldOptions_FeatureSupport::_internal_mutable_deprecation_w
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.deprecation_warning_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldOptions_FeatureSupport::_internal_mutable_deprecation_warning_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.deprecation_warning_.MutableAccessor( GetArena());
+}
 inline std::string* FieldOptions_FeatureSupport::release_deprecation_warning() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldOptions.FeatureSupport.deprecation_warning)
@@ -18948,7 +19176,7 @@ inline PROTOBUF_ALWAYS_INLINE void UninterpretedOption_NamePart::set_name_part(A
   // @@protoc_insertion_point(field_set:google.protobuf.UninterpretedOption.NamePart.name_part)
 }
 inline std::string* UninterpretedOption_NamePart::mutable_name_part() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name_part();
+  auto _s = _internal_mutable_name_part();
   // @@protoc_insertion_point(field_mutable:google.protobuf.UninterpretedOption.NamePart.name_part)
   return _s;
 }
@@ -18966,6 +19194,11 @@ inline std::string* UninterpretedOption_NamePart::_internal_mutable_name_part()
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_part_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor UninterpretedOption_NamePart::_internal_mutable_name_part_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_part_.MutableAccessor( GetArena());
+}
 inline std::string* UninterpretedOption_NamePart::release_name_part() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.UninterpretedOption.NamePart.name_part)
@@ -19100,7 +19333,7 @@ inline PROTOBUF_ALWAYS_INLINE void UninterpretedOption::set_identifier_value(Arg
   // @@protoc_insertion_point(field_set:google.protobuf.UninterpretedOption.identifier_value)
 }
 inline std::string* UninterpretedOption::mutable_identifier_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_identifier_value();
+  auto _s = _internal_mutable_identifier_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.UninterpretedOption.identifier_value)
   return _s;
 }
@@ -19118,6 +19351,11 @@ inline std::string* UninterpretedOption::_internal_mutable_identifier_value() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.identifier_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor UninterpretedOption::_internal_mutable_identifier_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.identifier_value_.MutableAccessor( GetArena());
+}
 inline std::string* UninterpretedOption::release_identifier_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.UninterpretedOption.identifier_value)
@@ -19255,7 +19493,7 @@ inline PROTOBUF_ALWAYS_INLINE void UninterpretedOption::set_string_value(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.UninterpretedOption.string_value)
 }
 inline std::string* UninterpretedOption::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_string_value();
+  auto _s = _internal_mutable_string_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.UninterpretedOption.string_value)
   return _s;
 }
@@ -19273,6 +19511,11 @@ inline std::string* UninterpretedOption::_internal_mutable_string_value() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.string_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor UninterpretedOption::_internal_mutable_string_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.string_value_.MutableAccessor( GetArena());
+}
 inline std::string* UninterpretedOption::release_string_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.UninterpretedOption.string_value)
@@ -19326,7 +19569,7 @@ inline PROTOBUF_ALWAYS_INLINE void UninterpretedOption::set_aggregate_value(Arg_
   // @@protoc_insertion_point(field_set:google.protobuf.UninterpretedOption.aggregate_value)
 }
 inline std::string* UninterpretedOption::mutable_aggregate_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_aggregate_value();
+  auto _s = _internal_mutable_aggregate_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.UninterpretedOption.aggregate_value)
   return _s;
 }
@@ -19344,6 +19587,11 @@ inline std::string* UninterpretedOption::_internal_mutable_aggregate_value() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.aggregate_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor UninterpretedOption::_internal_mutable_aggregate_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.aggregate_value_.MutableAccessor( GetArena());
+}
 inline std::string* UninterpretedOption::release_aggregate_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.UninterpretedOption.aggregate_value)
@@ -20005,7 +20253,7 @@ inline PROTOBUF_ALWAYS_INLINE void SourceCodeInfo_Location::set_leading_comments
   // @@protoc_insertion_point(field_set:google.protobuf.SourceCodeInfo.Location.leading_comments)
 }
 inline std::string* SourceCodeInfo_Location::mutable_leading_comments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_leading_comments();
+  auto _s = _internal_mutable_leading_comments();
   // @@protoc_insertion_point(field_mutable:google.protobuf.SourceCodeInfo.Location.leading_comments)
   return _s;
 }
@@ -20023,6 +20271,11 @@ inline std::string* SourceCodeInfo_Location::_internal_mutable_leading_comments(
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.leading_comments_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor SourceCodeInfo_Location::_internal_mutable_leading_comments_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.leading_comments_.MutableAccessor( GetArena());
+}
 inline std::string* SourceCodeInfo_Location::release_leading_comments() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.SourceCodeInfo.Location.leading_comments)
@@ -20076,7 +20329,7 @@ inline PROTOBUF_ALWAYS_INLINE void SourceCodeInfo_Location::set_trailing_comment
   // @@protoc_insertion_point(field_set:google.protobuf.SourceCodeInfo.Location.trailing_comments)
 }
 inline std::string* SourceCodeInfo_Location::mutable_trailing_comments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_trailing_comments();
+  auto _s = _internal_mutable_trailing_comments();
   // @@protoc_insertion_point(field_mutable:google.protobuf.SourceCodeInfo.Location.trailing_comments)
   return _s;
 }
@@ -20094,6 +20347,11 @@ inline std::string* SourceCodeInfo_Location::_internal_mutable_trailing_comments
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.trailing_comments_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor SourceCodeInfo_Location::_internal_mutable_trailing_comments_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.trailing_comments_.MutableAccessor( GetArena());
+}
 inline std::string* SourceCodeInfo_Location::release_trailing_comments() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.SourceCodeInfo.Location.trailing_comments)
@@ -20136,7 +20394,7 @@ inline void SourceCodeInfo_Location::clear_leading_detached_comments() {
 }
 inline std::string* SourceCodeInfo_Location::add_leading_detached_comments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
   ::google::protobuf::internal::TSanWrite(&_impl_);
-  std::string* _s = _internal_mutable_leading_detached_comments()->Add();
+  auto _s = _internal_mutable_leading_detached_comments()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
   return _s;
 }
@@ -20148,12 +20406,12 @@ inline const std::string& SourceCodeInfo_Location::leading_detached_comments(int
 inline std::string* SourceCodeInfo_Location::mutable_leading_detached_comments(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
-  return _internal_mutable_leading_detached_comments()->Mutable(index);
+  return _internal_mutable_leading_detached_comments()->MutableString(index);
 }
 template <typename Arg_, typename... Args_>
 inline void SourceCodeInfo_Location::set_leading_detached_comments(int index, Arg_&& value, Args_... args) {
   ::google::protobuf::internal::AssignToString(
-      *_internal_mutable_leading_detached_comments()->Mutable(index),
+      *_internal_mutable_leading_detached_comments()->MutableAccessor(index),
       std::forward<Arg_>(value), args... );
   // @@protoc_insertion_point(field_set:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
@@ -20313,7 +20571,7 @@ inline PROTOBUF_ALWAYS_INLINE void GeneratedCodeInfo_Annotation::set_source_file
   // @@protoc_insertion_point(field_set:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
 }
 inline std::string* GeneratedCodeInfo_Annotation::mutable_source_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_source_file();
+  auto _s = _internal_mutable_source_file();
   // @@protoc_insertion_point(field_mutable:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
   return _s;
 }
@@ -20331,6 +20589,11 @@ inline std::string* GeneratedCodeInfo_Annotation::_internal_mutable_source_file(
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.source_file_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor GeneratedCodeInfo_Annotation::_internal_mutable_source_file_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.source_file_.MutableAccessor( GetArena());
+}
 inline std::string* GeneratedCodeInfo_Annotation::release_source_file() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
diff --git a/src/google/protobuf/descriptor.proto b/src/google/protobuf/descriptor.proto
index dfabac416..805fe4e65 100644
--- a/src/google/protobuf/descriptor.proto
+++ b/src/google/protobuf/descriptor.proto
@@ -506,6 +506,11 @@ message FileOptions {
   // only to generated classes for C++.
   optional bool cc_enable_arenas = 31 [default = true];
 
+  // Change mutable_xxx function to support mutation on arena
+  // false: default. copy arenastring to heap and return std::string*
+  // true: return MaybeArenaStringAccessor to support mutation on arena
+  optional bool cc_mutable_donated_string = 32 [default = false];
+
   // Sets the objective c class prefix which is prepended to all objective c
   // generated classes from this .proto. There is no default.
   optional string objc_class_prefix = 36;
diff --git a/src/google/protobuf/extension_set.cc b/src/google/protobuf/extension_set.cc
index 21f24037a..0a8407ccd 100644
--- a/src/google/protobuf/extension_set.cc
+++ b/src/google/protobuf/extension_set.cc
@@ -526,23 +526,62 @@ const std::string& ExtensionSet::GetString(
     return default_value;
   } else {
     ABSL_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
-    return *extension->string_value;
+    return *extension->string_value.Get();
   }
 }
 
-std::string* ExtensionSet::MutableString(int number, FieldType type,
-                                         const FieldDescriptor* descriptor) {
+MutableStringType ExtensionSet::MutableString(
+    int number, FieldType type, const FieldDescriptor* descriptor) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(number, type, descriptor);
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   Extension* extension;
+  std::string* string;
   if (MaybeNewExtension(number, descriptor, &extension)) {
     extension->type = type;
     ABSL_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
     extension->is_repeated = false;
-    extension->string_value = Arena::Create<std::string>(arena_);
+    string = Arena::Create<std::string>(arena_);
+    if (arena_ != nullptr) {
+      extension->string_value.SetMutableArena(string);
+    } else {
+      extension->string_value.SetAllocated(string);
+    }
   } else {
     ABSL_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
+    string = extension->string_value.Get();
+    if (extension->string_value.IsFixedSizeArena()) {
+      string = Arena::Create<std::string>(arena_, *string);
+      extension->string_value.SetMutableArena(string);
+    }
   }
   extension->is_cleared = false;
-  return extension->string_value;
+  return string;
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+MaybeArenaStringAccessor ExtensionSet::MutableAccessor(
+    int number, FieldType type, const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    ABSL_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
+    extension->is_repeated = false;
+    auto accessor = MaybeArenaStringAccessor::create(arena_);
+    if (arena_ != nullptr) {
+      extension->string_value.SetFixedSizeArena(accessor.underlying());
+    } else {
+      extension->string_value.SetAllocated(accessor.underlying());
+    }
+    extension->is_cleared = false;
+    return accessor;
+  } else {
+    ABSL_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
+    extension->is_cleared = false;
+    return MaybeArenaStringAccessor(
+        extension->string_value.IsFixedSizeArena() ? arena_ : nullptr,
+        extension->string_value.Get());
+  }
 }
 
 const std::string& ExtensionSet::GetRepeatedString(int number,
@@ -553,15 +592,23 @@ const std::string& ExtensionSet::GetRepeatedString(int number,
   return extension->repeated_string_value->Get(index);
 }
 
-std::string* ExtensionSet::MutableRepeatedString(int number, int index) {
+MutableStringType ExtensionSet::MutableRepeatedString(int number, int index) {
   Extension* extension = FindOrNull(number);
   ABSL_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
   ABSL_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
   return extension->repeated_string_value->Mutable(index);
 }
 
-std::string* ExtensionSet::AddString(int number, FieldType type,
-                                     const FieldDescriptor* descriptor) {
+MaybeArenaStringAccessor ExtensionSet::MutableRepeatedAccessor(int number,
+                                                               int index) {
+  Extension* extension = FindOrNull(number);
+  ABSL_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
+  ABSL_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  return extension->repeated_string_value->MutableAccessor(index);
+}
+
+MutableStringType ExtensionSet::AddString(int number, FieldType type,
+                                          const FieldDescriptor* descriptor) {
   Extension* extension;
   if (MaybeNewExtension(number, descriptor, &extension)) {
     extension->type = type;
@@ -576,6 +623,22 @@ std::string* ExtensionSet::AddString(int number, FieldType type,
   return extension->repeated_string_value->Add();
 }
 
+MaybeArenaStringAccessor ExtensionSet::AddAccessor(
+    int number, FieldType type, const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    ABSL_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
+    extension->is_repeated = true;
+    extension->is_packed = false;
+    extension->repeated_string_value =
+        Arena::CreateMessage<RepeatedPtrField<std::string>>(arena_);
+  } else {
+    ABSL_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  }
+  return extension->repeated_string_value->AddAccessor();
+}
+
 // -------------------------------------------------------------------
 // Messages
 
@@ -1017,7 +1080,8 @@ void ExtensionSet::InternalExtensionMergeFrom(const MessageLite* extendee,
         HANDLE_TYPE(ENUM, enum, Enum);
 #undef HANDLE_TYPE
         case WireFormatLite::CPPTYPE_STRING:
-          SetString(number, other_extension.type, *other_extension.string_value,
+          SetString(number, other_extension.type,
+                    *other_extension.string_value.Get(),
                     other_extension.descriptor);
           break;
         case WireFormatLite::CPPTYPE_MESSAGE: {
@@ -1291,7 +1355,7 @@ void ExtensionSet::Extension::Clear() {
     if (!is_cleared) {
       switch (cpp_type(type)) {
         case WireFormatLite::CPPTYPE_STRING:
-          string_value->clear();
+          MaybeArenaStringAccessor::clear(string_value.Get());
           break;
         case WireFormatLite::CPPTYPE_MESSAGE:
           if (is_lazy) {
@@ -1420,8 +1484,8 @@ size_t ExtensionSet::Extension::ByteSize(int number) const {
       HANDLE_TYPE(UINT64, UInt64, uint64_t_value);
       HANDLE_TYPE(SINT32, SInt32, int32_t_value);
       HANDLE_TYPE(SINT64, SInt64, int64_t_value);
-      HANDLE_TYPE(STRING, String, *string_value);
-      HANDLE_TYPE(BYTES, Bytes, *string_value);
+      HANDLE_TYPE(STRING, String, *string_value.Get());
+      HANDLE_TYPE(BYTES, Bytes, *string_value.Get());
       HANDLE_TYPE(ENUM, Enum, enum_value);
       HANDLE_TYPE(GROUP, Group, *message_value);
 #undef HANDLE_TYPE
@@ -1500,7 +1564,7 @@ void ExtensionSet::Extension::Free() {
   } else {
     switch (cpp_type(type)) {
       case WireFormatLite::CPPTYPE_STRING:
-        delete string_value;
+        delete string_value.Get();
         break;
       case WireFormatLite::CPPTYPE_MESSAGE:
         if (is_lazy) {
@@ -1799,8 +1863,8 @@ uint8_t* ExtensionSet::Extension::InternalSerializeFieldWithCachedSizesToArray(
     target = stream->EnsureSpace(target);                \
     target = stream->WriteString(number, VALUE, target); \
     break
-      HANDLE_TYPE(STRING, String, *string_value);
-      HANDLE_TYPE(BYTES, Bytes, *string_value);
+      HANDLE_TYPE(STRING, String, *string_value.Get());
+      HANDLE_TYPE(BYTES, Bytes, *string_value.Get());
 #undef HANDLE_TYPE
       case WireFormatLite::TYPE_GROUP:
         target = stream->EnsureSpace(target);
diff --git a/src/google/protobuf/extension_set.h b/src/google/protobuf/extension_set.h
index 8b95b7224..f76bb60e3 100644
--- a/src/google/protobuf/extension_set.h
+++ b/src/google/protobuf/extension_set.h
@@ -318,7 +318,8 @@ class PROTOBUF_EXPORT ExtensionSet {
   void SetBool(int number, FieldType type, bool value, desc);
   void SetEnum(int number, FieldType type, int value, desc);
   void SetString(int number, FieldType type, std::string value, desc);
-  std::string* MutableString(int number, FieldType type, desc);
+  MutableStringType MutableString(int number, FieldType type, desc);
+  MaybeArenaStringAccessor MutableAccessor(int number, FieldType type, desc);
   MessageLite* MutableMessage(int number, FieldType type,
                               const MessageLite& prototype, desc);
   MessageLite* MutableMessage(const FieldDescriptor* descriptor,
@@ -382,7 +383,8 @@ class PROTOBUF_EXPORT ExtensionSet {
   void SetRepeatedBool(int number, int index, bool value);
   void SetRepeatedEnum(int number, int index, int value);
   void SetRepeatedString(int number, int index, std::string value);
-  std::string* MutableRepeatedString(int number, int index);
+  MutableStringType MutableRepeatedString(int number, int index);
+  MaybeArenaStringAccessor MutableRepeatedAccessor(int number, int index);
   MessageLite* MutableRepeatedMessage(int number, int index);
 
 #define desc const FieldDescriptor* descriptor  // avoid line wrapping
@@ -395,7 +397,8 @@ class PROTOBUF_EXPORT ExtensionSet {
   void AddBool(int number, FieldType type, bool packed, bool value, desc);
   void AddEnum(int number, FieldType type, bool packed, int value, desc);
   void AddString(int number, FieldType type, std::string value, desc);
-  std::string* AddString(int number, FieldType type, desc);
+  MutableStringType AddString(int number, FieldType type, desc);
+  MaybeArenaStringAccessor AddAccessor(int number, FieldType type, desc);
   MessageLite* AddMessage(int number, FieldType type,
                           const MessageLite& prototype, desc);
   MessageLite* AddMessage(const FieldDescriptor* descriptor,
@@ -644,7 +647,7 @@ class PROTOBUF_EXPORT ExtensionSet {
       double double_value;
       bool bool_value;
       int enum_value;
-      std::string* string_value;
+      internal::TaggedStringPtr string_value;
       MessageLite* message_value;
       LazyMessageExtension* lazymessage_value;
 
@@ -971,16 +974,16 @@ constexpr ExtensionSet::ExtensionSet(Arena* arena)
 inline void ExtensionSet::SetString(int number, FieldType type,
                                     std::string value,
                                     const FieldDescriptor* descriptor) {
-  MutableString(number, type, descriptor)->assign(std::move(value));
+  MutableAccessor(number, type, descriptor)->assign(std::move(value));
 }
 inline void ExtensionSet::SetRepeatedString(int number, int index,
                                             std::string value) {
-  MutableRepeatedString(number, index)->assign(std::move(value));
+  MutableRepeatedAccessor(number, index)->assign(std::move(value));
 }
 inline void ExtensionSet::AddString(int number, FieldType type,
                                     std::string value,
                                     const FieldDescriptor* descriptor) {
-  AddString(number, type, descriptor)->assign(std::move(value));
+  AddAccessor(number, type, descriptor)->assign(std::move(value));
 }
 // ===================================================================
 // Glue for generated extension accessors
@@ -1189,7 +1192,7 @@ PROTOBUF_DEFINE_PRIMITIVE_TYPE(bool, Bool)
 class PROTOBUF_EXPORT StringTypeTraits {
  public:
   typedef const std::string& ConstType;
-  typedef std::string* MutableType;
+  typedef MutableStringType MutableType;
   using InitType = ConstType;
   static ConstType FromInitType(InitType v) { return v; }
   typedef StringTypeTraits Singular;
@@ -1207,7 +1210,7 @@ class PROTOBUF_EXPORT StringTypeTraits {
                          const std::string& value, ExtensionSet* set) {
     set->SetString(number, field_type, value, nullptr);
   }
-  static inline std::string* Mutable(int number, FieldType field_type,
+  static inline MutableType Mutable(int number, FieldType field_type,
                                      ExtensionSet* set) {
     return set->MutableString(number, field_type, nullptr);
   }
@@ -1216,7 +1219,7 @@ class PROTOBUF_EXPORT StringTypeTraits {
 class PROTOBUF_EXPORT RepeatedStringTypeTraits {
  public:
   typedef const std::string& ConstType;
-  typedef std::string* MutableType;
+  typedef MutableStringType MutableType;
   using InitType = ConstType;
   static ConstType FromInitType(InitType v) { return v; }
   typedef RepeatedStringTypeTraits Repeated;
@@ -1240,14 +1243,14 @@ class PROTOBUF_EXPORT RepeatedStringTypeTraits {
                          ExtensionSet* set) {
     set->SetRepeatedString(number, index, value);
   }
-  static inline std::string* Mutable(int number, int index, ExtensionSet* set) {
+  static inline MutableType Mutable(int number, int index, ExtensionSet* set) {
     return set->MutableRepeatedString(number, index);
   }
   static inline void Add(int number, FieldType field_type, bool /*is_packed*/,
                          const std::string& value, ExtensionSet* set) {
     set->AddString(number, field_type, value, nullptr);
   }
-  static inline std::string* Add(int number, FieldType field_type,
+  static inline MutableType Add(int number, FieldType field_type,
                                  ExtensionSet* set) {
     return set->AddString(number, field_type, nullptr);
   }
diff --git a/src/google/protobuf/extension_set_heavy.cc b/src/google/protobuf/extension_set_heavy.cc
index ea99df6b5..1579892eb 100644
--- a/src/google/protobuf/extension_set_heavy.cc
+++ b/src/google/protobuf/extension_set_heavy.cc
@@ -399,8 +399,8 @@ size_t ExtensionSet::Extension::SpaceUsedExcludingSelfLong() const {
   } else {
     switch (cpp_type(type)) {
       case FieldDescriptor::CPPTYPE_STRING:
-        total_size += sizeof(*string_value) +
-                      StringSpaceUsedExcludingSelfLong(*string_value);
+        total_size += sizeof(*string_value.Get()) +
+                      StringSpaceUsedExcludingSelfLong(*string_value.Get());
         break;
       case FieldDescriptor::CPPTYPE_MESSAGE:
         if (is_lazy) {
diff --git a/src/google/protobuf/extension_set_inl.h b/src/google/protobuf/extension_set_inl.h
index 7360f181a..e79c9be84 100644
--- a/src/google/protobuf/extension_set_inl.h
+++ b/src/google/protobuf/extension_set_inl.h
@@ -138,15 +138,12 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
 
       case WireFormatLite::TYPE_BYTES:
       case WireFormatLite::TYPE_STRING: {
-        std::string* value =
-            extension.is_repeated
-                ? AddString(number, WireFormatLite::TYPE_STRING,
-                            extension.descriptor)
-                : MutableString(number, WireFormatLite::TYPE_STRING,
-                                extension.descriptor);
-        int size = ReadSize(&ptr);
-        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        return ctx->ReadString(ptr, size, value);
+        auto value = extension.is_repeated
+                         ? AddAccessor(number, WireFormatLite::TYPE_STRING,
+                                       extension.descriptor)
+                         : MutableAccessor(number, WireFormatLite::TYPE_STRING,
+                                           extension.descriptor);
+        return ctx->ReadArenaString(ptr, value);
       }
 
       case WireFormatLite::TYPE_GROUP: {
diff --git a/src/google/protobuf/extension_set_unittest.cc b/src/google/protobuf/extension_set_unittest.cc
index 5a77a3bb6..d8e9b1daa 100644
--- a/src/google/protobuf/extension_set_unittest.cc
+++ b/src/google/protobuf/extension_set_unittest.cc
@@ -1142,10 +1142,17 @@ TEST(ExtensionSetTest, RepeatedFields) {
     ASSERT_EQ(x, 4321);
   }
   // Test one string field.
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  for (auto x :
+       *message.MutableRepeatedExtension(unittest::repeated_string_extension)) {
+    x = "test_range_based_for";
+  }
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   for (auto& x :
        *message.MutableRepeatedExtension(unittest::repeated_string_extension)) {
     x = "test_range_based_for";
   }
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   for (const auto& x :
        message.GetRepeatedExtension(unittest::repeated_string_extension)) {
     ASSERT_TRUE(x == "test_range_based_for");
diff --git a/src/google/protobuf/field_mask.pb.h b/src/google/protobuf/field_mask.pb.h
index eb654f5bf..284fbbddd 100644
--- a/src/google/protobuf/field_mask.pb.h
+++ b/src/google/protobuf/field_mask.pb.h
@@ -291,7 +291,7 @@ inline void FieldMask::clear_paths() {
 }
 inline std::string* FieldMask::add_paths() ABSL_ATTRIBUTE_LIFETIME_BOUND {
   ::google::protobuf::internal::TSanWrite(&_impl_);
-  std::string* _s = _internal_mutable_paths()->Add();
+  auto _s = _internal_mutable_paths()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.FieldMask.paths)
   return _s;
 }
@@ -303,12 +303,12 @@ inline const std::string& FieldMask::paths(int index) const
 inline std::string* FieldMask::mutable_paths(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldMask.paths)
-  return _internal_mutable_paths()->Mutable(index);
+  return _internal_mutable_paths()->MutableString(index);
 }
 template <typename Arg_, typename... Args_>
 inline void FieldMask::set_paths(int index, Arg_&& value, Args_... args) {
   ::google::protobuf::internal::AssignToString(
-      *_internal_mutable_paths()->Mutable(index),
+      *_internal_mutable_paths()->MutableAccessor(index),
       std::forward<Arg_>(value), args... );
   // @@protoc_insertion_point(field_set:google.protobuf.FieldMask.paths)
 }
diff --git a/src/google/protobuf/generated_message_reflection.cc b/src/google/protobuf/generated_message_reflection.cc
index 74bcfd977..10a55fd66 100644
--- a/src/google/protobuf/generated_message_reflection.cc
+++ b/src/google/protobuf/generated_message_reflection.cc
@@ -1325,6 +1325,7 @@ void Reflection::InternalSwap(Message* lhs, Message* rhs) const {
 }
 
 void Reflection::MaybePoisonAfterClear(Message& root) const {
+  fprintf(stderr, "Reflection::MaybePoisonAfterClear\n");
   root.Clear();
 }
 
@@ -2001,9 +2002,13 @@ void Reflection::SetString(Message* message, const FieldDescriptor* field,
                            const absl::Cord& value) const {
   USAGE_MUTABLE_CHECK_ALL(SetString, SINGULAR, STRING);
   if (field->is_extension()) {
-    return absl::CopyCordToString(value,
-                                  MutableExtensionSet(message)->MutableString(
-                                      field->number(), field->type(), field));
+    auto accessor = MutableExtensionSet(message)->MutableAccessor(
+        field->number(), field->type(), field);
+    accessor.clear();
+    accessor.reserve(value.size());
+    for (auto chunk : value.Chunks()) {
+      accessor.append(chunk);
+    }
   } else {
     switch (field->cpp_string_type()) {
       case FieldDescriptor::CppStringType::kCord:
@@ -2125,8 +2130,8 @@ void Reflection::SetRepeatedString(Message* message,
         break;
       case FieldDescriptor::CppStringType::kView:
       case FieldDescriptor::CppStringType::kString:
-        MutableRepeatedField<std::string>(message, field, index)
-            ->assign(std::move(value));
+        MutableRaw<RepeatedPtrField<std::string>>(message, field)
+            ->MutableAccessor(index)->assign(std::move(value));
         break;
     }
   }
@@ -2146,7 +2151,8 @@ void Reflection::AddString(Message* message, const FieldDescriptor* field,
         break;
       case FieldDescriptor::CppStringType::kView:
       case FieldDescriptor::CppStringType::kString:
-        AddField<std::string>(message, field)->assign(std::move(value));
+        MutableRaw<RepeatedPtrField<std::string>>(message, field)
+            ->Add(std::move(value));
         break;
     }
   }
diff --git a/src/google/protobuf/generated_message_tctable_gen.cc b/src/google/protobuf/generated_message_tctable_gen.cc
index 0b6a1c38a..88eb985b8 100644
--- a/src/google/protobuf/generated_message_tctable_gen.cc
+++ b/src/google/protobuf/generated_message_tctable_gen.cc
@@ -774,6 +774,9 @@ uint16_t MakeTypeCardForField(
           // A repeated string field uses RepeatedPtrField<std::string>
           // (unless it has a ctype option; see above).
           type_card |= fl::kRepSString;
+        } else if (options.is_string_inlined) {
+          // 按照is_string_inlined标记设置kRepIString类型标记
+          type_card |= fl::kRepIString;
         } else {
           // Otherwise, non-repeated string fields use ArenaStringPtr.
           type_card |= fl::kRepAString;
diff --git a/src/google/protobuf/generated_message_tctable_impl.h b/src/google/protobuf/generated_message_tctable_impl.h
index 0e639a89a..8bb1b557d 100644
--- a/src/google/protobuf/generated_message_tctable_impl.h
+++ b/src/google/protobuf/generated_message_tctable_impl.h
@@ -997,8 +997,10 @@ class PROTOBUF_EXPORT TcParser final {
   template <typename TagType, typename FieldType, Utf8Type utf8>
   PROTOBUF_CC static inline const char* RepeatedString(PROTOBUF_TC_PARAM_DECL);
 
+  // 整体代码只有此处依赖SerialArena的内部实现，比较trick先不支持这种优化
+  // 而且ArenaString实现变更后这种加速意义不大
   static inline const char* ParseRepeatedStringOnce(
-      const char* ptr, SerialArena* serial_arena, ParseContext* ctx,
+      const char* ptr, Arena* arena, ParseContext* ctx,
       RepeatedPtrField<std::string>& field);
 
   PROTOBUF_NOINLINE
diff --git a/src/google/protobuf/generated_message_tctable_lite.cc b/src/google/protobuf/generated_message_tctable_lite.cc
index 155efbbbc..dcf61830a 100644
--- a/src/google/protobuf/generated_message_tctable_lite.cc
+++ b/src/google/protobuf/generated_message_tctable_lite.cc
@@ -1378,23 +1378,46 @@ PROTOBUF_ALWAYS_INLINE inline const char* ReadStringIntoArena(
     MessageLite* /*msg*/, const char* ptr, ParseContext* ctx,
     uint32_t /*aux_idx*/, const TcParseTableBase* /*table*/,
     ArenaStringPtr& field, Arena* arena) {
-  return ctx->ReadArenaString(ptr, &field, arena);
+  // 统一适配Allocated/MutableArena/FixedSizeArena模式
+  return ctx->ReadArenaString(ptr, field.MutableAccessor(arena));
 }
 
+// ArenaStringPtr/InlinedStringField具有类似的API，模板支持
+template <typename T>
 PROTOBUF_NOINLINE
 const char* ReadStringNoArena(MessageLite* /*msg*/, const char* ptr,
                               ParseContext* ctx, uint32_t /*aux_idx*/,
                               const TcParseTableBase* /*table*/,
-                              ArenaStringPtr& field) {
+                              T& field) {
   int size = ReadSize(&ptr);
   if (!ptr) return nullptr;
   return ctx->ReadString(ptr, size, field.MutableNoCopy(nullptr));
 }
 
-PROTOBUF_ALWAYS_INLINE inline bool IsValidUTF8(ArenaStringPtr& field) {
+// ArenaStringPtr/InlinedStringField具有类似的API，模板支持
+template <typename T>
+PROTOBUF_ALWAYS_INLINE inline bool IsValidUTF8(T& field) {
   return utf8_range::IsStructurallyValid(field.Get());
 }
 
+// InlinedStringField需要按照协议提取donated标记之后进行访问
+PROTOBUF_ALWAYS_INLINE inline const char* ReadStringIntoArena(
+    MessageLite* msg, const char* ptr, ParseContext* ctx,
+    uint32_t aux_idx, const TcParseTableBase* table,
+    InlinedStringField& field, Arena* arena) {
+  // 包含InlinedStringField时aux[0]固定存储了donated bit图
+  // _inlined_string_donated_成员的偏移量
+  auto donated_slot_offset = table->field_aux(0u)->offset;
+  // 根据序号计算bit偏移量
+  auto donated_slot_index = aux_idx / 32;
+  donated_slot_offset += donated_slot_index << 4;
+  auto donated_slot_mask = 1 << (aux_idx % 32);
+  // 取出donated bit，相当于如下方式
+  // msg->_inlined_string_donated_[donated_slot_offset] & donated_slot_mask
+  auto donated = TcParser::RefAt<uint32_t>(msg, donated_slot_offset) & donated_slot_mask;
+  // 实际开始读取数据
+  return ctx->ReadArenaString(ptr, field.MutableAccessor(arena, donated));
+}
 
 }  // namespace
 
@@ -1467,23 +1490,32 @@ PROTOBUF_NOINLINE const char* TcParser::FastUS2(PROTOBUF_TC_PARAM_DECL) {
 
 // Inlined string variants:
 
+// 增加和ArenaStringPtr一样的fast path支持
 const char* TcParser::FastBiS1(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint8_t, InlinedStringField, kNoUtf8>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastBiS2(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint16_t, InlinedStringField, kNoUtf8>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastSiS1(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint8_t, InlinedStringField,
+                                          kUtf8ValidateOnly>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastSiS2(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint16_t, InlinedStringField,
+                                          kUtf8ValidateOnly>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastUiS1(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint8_t, InlinedStringField, kUtf8>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastUiS2(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint16_t, InlinedStringField, kUtf8>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 
 // Corded string variants:
@@ -1523,8 +1555,9 @@ PROTOBUF_ALWAYS_INLINE const char* TcParser::RepeatedString(
 #endif
         return true;
       default:
+        // 切换Get接口避免进行MutableArena转换
         if (PROTOBUF_PREDICT_TRUE(
-                utf8_range::IsStructurallyValid(field[field.size() - 1]))) {
+                utf8_range::IsStructurallyValid(field.Get(field.size() - 1)))) {
           return true;
         }
         ReportFastUtf8Error(FastDecodeTag(expected_tag), table);
@@ -1534,13 +1567,13 @@ PROTOBUF_ALWAYS_INLINE const char* TcParser::RepeatedString(
   };
 
   auto* arena = field.GetArena();
-  SerialArena* serial_arena;
+  // 整体代码只有此处依赖SerialArena的内部实现，比较trick先不支持这种优化
+  // 而且ArenaString实现变更后这种加速意义不大
   if (PROTOBUF_PREDICT_TRUE(arena != nullptr &&
-                            arena->impl_.GetSerialArenaFast(&serial_arena) &&
                             field.PrepareForParse())) {
     do {
       ptr += sizeof(TagType);
-      ptr = ParseRepeatedStringOnce(ptr, serial_arena, ctx, field);
+      ptr = ParseRepeatedStringOnce(ptr, arena, ctx, field);
 
       if (PROTOBUF_PREDICT_FALSE(ptr == nullptr || !validate_last_string())) {
         PROTOBUF_MUSTTAIL return Error(PROTOBUF_TC_PARAM_NO_DATA_PASS);
@@ -1550,8 +1583,9 @@ PROTOBUF_ALWAYS_INLINE const char* TcParser::RepeatedString(
   } else {
     do {
       ptr += sizeof(TagType);
-      std::string* str = field.Add();
-      ptr = InlineGreedyStringParser(str, ptr, ctx);
+      // 统一适配Allocated/MutableArena/FixedSizeArena模式
+      auto str = field.AddAccessor();
+      ptr = ctx->ReadArenaString(ptr, str);
       if (PROTOBUF_PREDICT_FALSE(ptr == nullptr || !validate_last_string())) {
         PROTOBUF_MUSTTAIL return Error(PROTOBUF_TC_PARAM_NO_DATA_PASS);
       }
@@ -2168,7 +2202,8 @@ PROTOBUF_NOINLINE const char* TcParser::MpString(PROTOBUF_TC_PARAM_DECL) {
       if (need_init) field.InitDefault();
       Arena* arena = msg->GetArena();
       if (arena) {
-        ptr = ctx->ReadArenaString(ptr, &field, arena);
+        // 统一适配Allocated/MutableArena/FixedSizeArena模式
+        ptr = ctx->ReadArenaString(ptr, field.MutableAccessor(arena));
       } else {
         std::string* str = field.MutableNoCopy(nullptr);
         ptr = InlineGreedyStringParser(str, ptr, ctx);
@@ -2178,6 +2213,24 @@ PROTOBUF_NOINLINE const char* TcParser::MpString(PROTOBUF_TC_PARAM_DECL) {
       break;
     }
 
+    // 增加InlinedStringField的支持分支
+    // 内容除了类型之外和kRepAString分支完全一致
+    case field_layout::kRepIString: {
+      auto& field = RefAt<InlinedStringField>(base, entry.offset);
+      Arena* arena = msg->GetArena();
+      if (arena) {
+        // 每个field通过aux_idx存储了自身使用的donated bit序号
+        auto aux_idx = table->field_aux(entry.aux_idx)->offset;
+        ptr = ReadStringIntoArena(
+            msg, ptr, ctx, aux_idx, table, field, arena);
+      } else {
+        std::string* str = field.MutableNoCopy(nullptr);
+        ptr = InlineGreedyStringParser(str, ptr, ctx);
+      }
+      if (!ptr) break;
+      is_valid = MpVerifyUtf8(field.Get(), table, entry, xform_val);
+      break;
+    }
 
     case field_layout::kRepCord: {
       absl::Cord* field;
@@ -2208,13 +2261,16 @@ PROTOBUF_NOINLINE const char* TcParser::MpString(PROTOBUF_TC_PARAM_DECL) {
 }
 
 PROTOBUF_ALWAYS_INLINE const char* TcParser::ParseRepeatedStringOnce(
-    const char* ptr, SerialArena* serial_arena, ParseContext* ctx,
+    const char* ptr, Arena* arena, ParseContext* ctx,
     RepeatedPtrField<std::string>& field) {
+  using TypeHandler = typename RepeatedPtrField<std::string>::TypeHandler;
   int size = ReadSize(&ptr);
   if (PROTOBUF_PREDICT_FALSE(!ptr)) return {};
-  auto* str = new (serial_arena->AllocateFromStringBlock()) std::string();
-  field.AddAllocatedForParse(str);
-  ptr = ctx->ReadString(ptr, size, str);
+  // 整体代码只有此处依赖SerialArena的内部实现，比较trick先不支持这种优化
+  // 而且ArenaString实现变更后这种加速意义不大
+  auto str = ArenaStringAccessor::create(arena);
+  field.AddAllocatedForParse(StringHandlerType::ToTagged(str.underlying()));
+  ptr = ctx->ReadArenaString(ptr, size, str);
   if (PROTOBUF_PREDICT_FALSE(!ptr)) return {};
   PROTOBUF_ASSUME(ptr != nullptr);
   return ptr;
@@ -2243,16 +2299,17 @@ PROTOBUF_NOINLINE const char* TcParser::MpRepeatedString(
       uint32_t next_tag;
 
       auto* arena = field.GetArena();
-      SerialArena* serial_arena;
+      // 整体代码只有此处依赖SerialArena的内部实现，比较trick先不支持这种优化
+      // 而且ArenaString实现变更后这种加速意义不大
       if (PROTOBUF_PREDICT_TRUE(
               arena != nullptr &&
-              arena->impl_.GetSerialArenaFast(&serial_arena) &&
               field.PrepareForParse())) {
         do {
           ptr = ptr2;
-          ptr = ParseRepeatedStringOnce(ptr, serial_arena, ctx, field);
+          ptr = ParseRepeatedStringOnce(ptr, arena, ctx, field);
+          // 切换Get接口避免进行MutableArena转换
           if (PROTOBUF_PREDICT_FALSE(ptr == nullptr ||
-                                     !MpVerifyUtf8(field[field.size() - 1],
+                                     !MpVerifyUtf8(field.Get(field.size() - 1),
                                                    table, entry, xform_val))) {
             PROTOBUF_MUSTTAIL return Error(PROTOBUF_TC_PARAM_NO_DATA_PASS);
           }
@@ -2262,8 +2319,9 @@ PROTOBUF_NOINLINE const char* TcParser::MpRepeatedString(
       } else {
         do {
           ptr = ptr2;
-          std::string* str = field.Add();
-          ptr = InlineGreedyStringParser(str, ptr, ctx);
+          // 统一适配Allocated/MutableArena/FixedSizeArena模式
+          auto str = field.AddAccessor();
+          ptr = ctx->ReadArenaString(ptr, str);
           if (PROTOBUF_PREDICT_FALSE(
                   ptr == nullptr ||
                   !MpVerifyUtf8(*str, table, entry, xform_val))) {
diff --git a/src/google/protobuf/generated_message_util.h b/src/google/protobuf/generated_message_util.h
index 589e01057..6247d7e30 100644
--- a/src/google/protobuf/generated_message_util.h
+++ b/src/google/protobuf/generated_message_util.h
@@ -336,27 +336,52 @@ struct BytesTag {
 // Assigns to `dest` the content of `value`, optionally bounded by `size`.
 // This overload set is used to implement `set_xxx()` methods for repeated
 // string fields in generated code.
-inline void AssignToString(std::string& dest, const std::string& value,
+//inline void AssignToString(std::string& dest, const std::string& value,
+//                           BytesTag tag = BytesTag{}) {
+//  dest.assign(value);
+//}
+//inline void AssignToString(std::string& dest, std::string&& value,
+//                           BytesTag tag = BytesTag{}) {
+//  dest.assign(std::move(value));
+//}
+//inline void AssignToString(std::string& dest, const char* value,
+//                           BytesTag tag = BytesTag{}) {
+//  dest.assign(value);
+//}
+//inline void AssignToString(std::string& dest, const char* value,
+//                           std::size_t size) {
+//  dest.assign(value, size);
+//}
+//inline void AssignToString(std::string& dest, const void* value,
+//                           std::size_t size, BytesTag tag) {
+//  dest.assign(reinterpret_cast<const char*>(value), size);
+//}
+//inline void AssignToString(std::string& dest, absl::string_view value,
+//                           BytesTag tag = BytesTag{}) {
+//  dest.assign(value.data(), value.size());
+//}
+
+inline void AssignToString(MaybeArenaStringAccessor dest, const std::string& value,
                            BytesTag tag = BytesTag{}) {
   dest.assign(value);
 }
-inline void AssignToString(std::string& dest, std::string&& value,
+inline void AssignToString(MaybeArenaStringAccessor dest, std::string&& value,
                            BytesTag tag = BytesTag{}) {
   dest.assign(std::move(value));
 }
-inline void AssignToString(std::string& dest, const char* value,
+inline void AssignToString(MaybeArenaStringAccessor dest, const char* value,
                            BytesTag tag = BytesTag{}) {
   dest.assign(value);
 }
-inline void AssignToString(std::string& dest, const char* value,
+inline void AssignToString(MaybeArenaStringAccessor dest, const char* value,
                            std::size_t size) {
   dest.assign(value, size);
 }
-inline void AssignToString(std::string& dest, const void* value,
+inline void AssignToString(MaybeArenaStringAccessor dest, const void* value,
                            std::size_t size, BytesTag tag) {
   dest.assign(reinterpret_cast<const char*>(value), size);
 }
-inline void AssignToString(std::string& dest, absl::string_view value,
+inline void AssignToString(MaybeArenaStringAccessor dest, absl::string_view value,
                            BytesTag tag = BytesTag{}) {
   dest.assign(value.data(), value.size());
 }
@@ -367,7 +392,7 @@ inline void AssignToString(std::string& dest, absl::string_view value,
 template <typename Arg, typename... Args>
 void AddToRepeatedPtrField(google::protobuf::RepeatedPtrField<std::string>& dest,
                            Arg&& value, Args... args) {
-  AssignToString(*dest.Add(), std::forward<Arg>(value), args...);
+  AssignToString(*dest.AddAccessor(), std::forward<Arg>(value), args...);
 }
 inline void AddToRepeatedPtrField(google::protobuf::RepeatedPtrField<std::string>& dest,
                                   std::string&& value,
diff --git a/src/google/protobuf/inlined_string_field.cc b/src/google/protobuf/inlined_string_field.cc
index a17f922b6..1c4a47f28 100644
--- a/src/google/protobuf/inlined_string_field.cc
+++ b/src/google/protobuf/inlined_string_field.cc
@@ -24,7 +24,6 @@
 #include "google/protobuf/message_lite.h"
 #include "google/protobuf/parse_context.h"
 
-
 // clang-format off
 #include "google/protobuf/port_def.inc"
 // clang-format on
@@ -33,21 +32,10 @@ namespace google {
 namespace protobuf {
 namespace internal {
 
-#if defined(NDEBUG) || !defined(GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL_INLINE)
-
-class InlinedStringField::ScopedCheckInvariants {
- public:
-  constexpr explicit ScopedCheckInvariants(const InlinedStringField*) {}
-};
-
-#endif  // NDEBUG || !GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL_INLINE
-
-
 std::string* InlinedStringField::Mutable(const LazyString& /*default_value*/,
                                          Arena* arena, bool donated,
                                          uint32_t* donating_states,
                                          uint32_t mask, MessageLite* msg) {
-  ScopedCheckInvariants invariants(this);
   if (arena == nullptr || !donated) {
     return UnsafeMutablePointer();
   }
@@ -57,7 +45,6 @@ std::string* InlinedStringField::Mutable(const LazyString& /*default_value*/,
 std::string* InlinedStringField::Mutable(Arena* arena, bool donated,
                                          uint32_t* donating_states,
                                          uint32_t mask, MessageLite* msg) {
-  ScopedCheckInvariants invariants(this);
   if (arena == nullptr || !donated) {
     return UnsafeMutablePointer();
   }
@@ -70,6 +57,9 @@ std::string* InlinedStringField::MutableSlow(::google::protobuf::Arena* arena,
                                              uint32_t mask, MessageLite* msg) {
   (void)mask;
   (void)msg;
+  new (get_mutable())::std::string(*get_const());
+  *donating_states &= mask;
+  msg->OnDemandRegisterArenaDtor(arena);
   return UnsafeMutablePointer();
 }
 
@@ -79,6 +69,13 @@ void InlinedStringField::SetAllocated(const std::string* default_value,
                                       uint32_t mask, MessageLite* msg) {
   (void)mask;
   (void)msg;
+  if (arena != nullptr && donated) {
+    new (get_mutable())::std::string(::std::move(*value));
+    *donating_states &= mask;
+    msg->OnDemandRegisterArenaDtor(arena);
+    delete value;
+    return;
+  }
   SetAllocatedNoArena(default_value, value);
 }
 
@@ -88,6 +85,12 @@ void InlinedStringField::Set(std::string&& value, Arena* arena, bool donated,
   (void)donating_states;
   (void)mask;
   (void)msg;
+  if (arena != nullptr && donated) {
+    new (get_mutable())::std::string(::std::move(value));
+    *donating_states &= mask;
+    msg->OnDemandRegisterArenaDtor(arena);
+    return;
+  }
   SetNoArena(std::move(value));
 }
 
@@ -102,14 +105,14 @@ std::string* InlinedStringField::Release(Arena* arena, bool donated) {
   std::string* released = (arena != nullptr && donated)
                               ? new std::string(*get_mutable())
                               : new std::string(std::move(*get_mutable()));
-  get_mutable()->clear();
+  ClearToEmpty();
   return released;
 }
 
 void InlinedStringField::ClearToDefault(const LazyString& default_value,
                                         Arena* arena, bool donated) {
   (void)arena;
-  get_mutable()->assign(default_value.get());
+  MutableAccessor(arena, donated)->assign(default_value.get());
 }
 
 
diff --git a/src/google/protobuf/inlined_string_field.h b/src/google/protobuf/inlined_string_field.h
index d894acb7e..06f651d3e 100644
--- a/src/google/protobuf/inlined_string_field.h
+++ b/src/google/protobuf/inlined_string_field.h
@@ -25,6 +25,8 @@
 #error "You cannot SWIG proto headers"
 #endif
 
+#define GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL_INLINE
+
 namespace google {
 namespace protobuf {
 
@@ -112,6 +114,8 @@ class PROTOBUF_EXPORT InlinedStringField {
   // This method never changes the `donating_states`.
   void Set(absl::string_view value, Arena* arena, bool donated,
            uint32_t* donating_states, uint32_t mask, MessageLite* msg);
+  void Set(const std::string& value, Arena* arena, bool donated,
+           uint32_t* donating_states, uint32_t mask, MessageLite* msg);
 
   // Rvalue Set. If this field is donated, this method will undonate this field
   // by mutating the `donating_states` according to `mask`.
@@ -131,6 +135,8 @@ class PROTOBUF_EXPORT InlinedStringField {
 
   void SetBytes(absl::string_view value, Arena* arena, bool donated,
                 uint32_t* donating_states, uint32_t mask, MessageLite* msg);
+  void SetBytes(const std::string& value, Arena* arena, bool donated,
+                uint32_t* donating_states, uint32_t mask, MessageLite* msg);
 
   void SetBytes(std::string&& value, Arena* arena, bool donated,
                 uint32_t* donating_states, uint32_t mask, MessageLite* msg);
@@ -163,6 +169,10 @@ class PROTOBUF_EXPORT InlinedStringField {
   std::string* Mutable(const LazyString& default_value, Arena* arena,
                        bool donated, uint32_t* donating_states, uint32_t mask,
                        MessageLite* msg);
+  MaybeArenaStringAccessor MutableAccessor(Arena* arena, bool donated,
+                                           uint32_t* donating_states,
+                                           uint32_t mask, MessageLite* msg);
+  MaybeArenaStringAccessor MutableAccessor(Arena* arena, bool donated);
 
   // Mutable(nullptr_t) is an overload to explicitly support Mutable(nullptr)
   // calls used by the internal parser logic. This provides API equivalence with
@@ -320,7 +330,7 @@ class PROTOBUF_EXPORT InlinedStringField {
   // always be the empty std::string.
   PROTOBUF_NDEBUG_INLINE void ClearToEmpty() { ClearNonDefaultToEmpty(); }
   PROTOBUF_NDEBUG_INLINE void ClearNonDefaultToEmpty() {
-    get_mutable()->clear();
+    MaybeArenaStringAccessor::clear(get_mutable());
   }
 
   // Clears content, but keeps allocated std::string if arena != nullptr, to
@@ -372,7 +382,6 @@ inline InlinedStringField::InlinedStringField(
   new (get_mutable()) std::string(default_value);
 }
 
-
 #ifdef GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL_INLINE
 constexpr uint32_t InitDonatingStates() { return ~0u; }
 inline void InternalRegisterArenaDtor(Arena*, void*, void (*)(void*)) {}
@@ -390,8 +399,8 @@ inline InlinedStringField::InlinedStringField(Arena* /*arena*/) { Init(); }
 
 inline InlinedStringField::InlinedStringField(Arena* arena,
                                               const InlinedStringField& rhs) {
-  const std::string& src = *rhs.get_const();
-  new (value_) std::string(src);
+  Init();
+  MaybeArenaStringAccessor(arena, get_mutable()) = *rhs.get_const();
 }
 
 inline const std::string& InlinedStringField::GetNoArena() const {
@@ -429,7 +438,7 @@ inline PROTOBUF_NDEBUG_INLINE void InlinedStringField::InternalSwap(
     InlinedStringField* rhs, bool rhs_arena_dtor_registered,
     MessageLite* rhs_msg, Arena* arena) {
 #ifdef GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL_INLINE
-  lhs->get_mutable()->swap(*rhs->get_mutable());
+  MaybeArenaStringAccessor::swap(lhs->get_mutable(), rhs->get_mutable());
   if (!lhs_arena_dtor_registered && rhs_arena_dtor_registered) {
     lhs_msg->OnDemandRegisterArenaDtor(arena);
   } else if (lhs_arena_dtor_registered && !rhs_arena_dtor_registered) {
@@ -441,7 +450,7 @@ inline PROTOBUF_NDEBUG_INLINE void InlinedStringField::InternalSwap(
   (void)rhs_arena_dtor_registered;
   (void)lhs_msg;
   (void)rhs_msg;
-  lhs->get_mutable()->swap(*rhs->get_mutable());
+  MaybeArenaStringAccessor::swap(lhs->get_mutable(), rhs->get_mutable());
 #endif
 }
 
@@ -450,10 +459,17 @@ inline void InlinedStringField::Set(absl::string_view value, Arena* arena,
                                     uint32_t /*mask*/, MessageLite* /*msg*/) {
   (void)arena;
   (void)donated;
-  SetNoArena(value);
+  MutableAccessor(arena, donated) = value;
 }
 
-inline void InlinedStringField::Set(const char* str, ::google::protobuf::Arena* arena,
+inline void InlinedStringField::Set(const std::string& value, Arena* arena,
+                                    bool donated, uint32_t* /*donating_states*/,
+                                    uint32_t /*mask*/, MessageLite* /*msg*/) {
+  MutableAccessor(arena, donated) = value;
+}
+
+inline void InlinedStringField::Set(const char* str,
+                                    ::google::protobuf::Arena* arena,
                                     bool donated, uint32_t* donating_states,
                                     uint32_t mask, MessageLite* msg) {
   Set(absl::string_view(str), arena, donated, donating_states, mask, msg);
@@ -473,6 +489,13 @@ inline void InlinedStringField::SetBytes(absl::string_view value, Arena* arena,
   Set(value, arena, donated, donating_states, mask, msg);
 }
 
+inline void InlinedStringField::SetBytes(const std::string& value, Arena* arena,
+                                         bool donated,
+                                         uint32_t* donating_states,
+                                         uint32_t mask, MessageLite* msg) {
+  Set(value, arena, donated, donating_states, mask, msg);
+}
+
 inline void InlinedStringField::SetBytes(std::string&& value, Arena* arena,
                                          bool donated,
                                          uint32_t* donating_states,
@@ -511,6 +534,17 @@ inline void InlinedStringField::SetBytes(
   Set(const_string_ref.get(), arena, donated, donating_states, mask, msg);
 }
 
+inline MaybeArenaStringAccessor InlinedStringField::MutableAccessor(
+    Arena* arena, bool donated, uint32_t* /*donating_states*/,
+    uint32_t /*mask*/, MessageLite* /*msg*/) {
+  return MutableAccessor(arena, donated);
+}
+
+inline MaybeArenaStringAccessor InlinedStringField::MutableAccessor(
+    Arena* arena, bool donated) {
+  return MaybeArenaStringAccessor(donated ? arena : nullptr, get_mutable());
+}
+
 inline std::string* InlinedStringField::UnsafeMutablePointer() {
   return get_mutable();
 }
diff --git a/src/google/protobuf/io/BUILD.bazel b/src/google/protobuf/io/BUILD.bazel
index 66819966b..fca18ed8d 100644
--- a/src/google/protobuf/io/BUILD.bazel
+++ b/src/google/protobuf/io/BUILD.bazel
@@ -199,6 +199,7 @@ cc_test(
         ":tokenizer",
         "//:protobuf",
         "//src/google/protobuf",
+        "//src/google/protobuf:cc_test_protos",
         "//src/google/protobuf:port",
         "//src/google/protobuf:test_util",
         "//src/google/protobuf:test_util2",
diff --git a/src/google/protobuf/io/zero_copy_stream_unittest.cc b/src/google/protobuf/io/zero_copy_stream_unittest.cc
index abbc40cd0..46127f762 100644
--- a/src/google/protobuf/io/zero_copy_stream_unittest.cc
+++ b/src/google/protobuf/io/zero_copy_stream_unittest.cc
@@ -58,6 +58,7 @@
 #include "google/protobuf/io/zero_copy_stream_impl.h"
 #include "google/protobuf/test_util.h"
 #include "google/protobuf/test_util2.h"
+#include "google/protobuf/unittest.pb.h"
 
 #if HAVE_ZLIB
 #include "google/protobuf/io/gzip_stream.h"
diff --git a/src/google/protobuf/message_lite.cc b/src/google/protobuf/message_lite.cc
index 22fe7d963..0f52113f1 100644
--- a/src/google/protobuf/message_lite.cc
+++ b/src/google/protobuf/message_lite.cc
@@ -579,6 +579,12 @@ bool MessageLite::AppendToString(std::string* output) const {
   return AppendPartialToString(output);
 }
 
+bool MessageLite::AppendToString(MaybeArenaStringAccessor output) const {
+  ABSL_DCHECK(IsInitialized())
+      << InitializationErrorMessage("serialize", *this);
+  return AppendPartialToString(output);
+}
+
 bool MessageLite::AppendPartialToString(std::string* output) const {
   size_t old_size = output->size();
   size_t byte_size = ByteSizeLong();
@@ -596,11 +602,31 @@ bool MessageLite::AppendPartialToString(std::string* output) const {
   return true;
 }
 
+bool MessageLite::AppendPartialToString(MaybeArenaStringAccessor output) const {
+  size_t old_size = output->size();
+  size_t byte_size = ByteSizeLong();
+  if (byte_size > INT_MAX) {
+    ABSL_LOG(ERROR) << GetTypeName()
+                    << " exceeded maximum protobuf size of 2GB: " << byte_size;
+    return false;
+  }
+
+  output.__resize_default_init(old_size + byte_size);
+  uint8_t* start = reinterpret_cast<uint8_t*>(&output[0] + old_size);
+  SerializeToArrayImpl(*this, start, byte_size);
+  return true;
+}
+
 bool MessageLite::SerializeToString(std::string* output) const {
   output->clear();
   return AppendToString(output);
 }
 
+bool MessageLite::SerializeToString(MaybeArenaStringAccessor output) const {
+  output->clear();
+  return AppendToString(output);
+}
+
 bool MessageLite::SerializePartialToString(std::string* output) const {
   output->clear();
   return AppendPartialToString(output);
diff --git a/src/google/protobuf/message_lite.h b/src/google/protobuf/message_lite.h
index cae4e6bbe..497cff971 100644
--- a/src/google/protobuf/message_lite.h
+++ b/src/google/protobuf/message_lite.h
@@ -28,6 +28,7 @@
 #include "absl/strings/cord.h"
 #include "absl/strings/string_view.h"
 #include "google/protobuf/arena.h"
+#include "google/protobuf/arenastring_impl.h"
 #include "google/protobuf/explicitly_constructed.h"
 #include "google/protobuf/internal_visibility.h"
 #include "google/protobuf/io/coded_stream.h"
@@ -398,6 +399,7 @@ class PROTOBUF_EXPORT MessageLite {
   // Serialize the message and store it in the given string.  All required
   // fields must be set.
   bool SerializeToString(std::string* output) const;
+  bool SerializeToString(MaybeArenaStringAccessor output) const;
   // Like SerializeToString(), but allows missing required fields.
   bool SerializePartialToString(std::string* output) const;
   // Serialize the message and store it in the given byte array.  All required
@@ -430,8 +432,10 @@ class PROTOBUF_EXPORT MessageLite {
   // Like SerializeToString(), but appends to the data to the string's
   // existing contents.  All required fields must be set.
   bool AppendToString(std::string* output) const;
+  bool AppendToString(MaybeArenaStringAccessor output) const;
   // Like AppendToString(), but allows missing required fields.
   bool AppendPartialToString(std::string* output) const;
+  bool AppendPartialToString(MaybeArenaStringAccessor output) const;
 
   // Reads a protocol buffer from a Cord and merges it into this message.
   bool MergeFromCord(const absl::Cord& cord);
diff --git a/src/google/protobuf/parse_context.h b/src/google/protobuf/parse_context.h
index d40e71c1d..6dab5c22c 100644
--- a/src/google/protobuf/parse_context.h
+++ b/src/google/protobuf/parse_context.h
@@ -198,9 +198,12 @@ class PROTOBUF_EXPORT EpsCopyInputStream {
     return AppendStringFallback(ptr, size, s);
   }
   // Implemented in arenastring.cc
+  PROTOBUF_NODISCARD const char* ReadArenaString(const char* ptr, int size,
+                                                 ArenaStringAccessor s);
   PROTOBUF_NODISCARD const char* ReadArenaString(const char* ptr,
-                                                 ArenaStringPtr* s,
-                                                 Arena* arena);
+                                                 ArenaStringAccessor s);
+  PROTOBUF_NODISCARD const char* ReadArenaString(const char* ptr,
+                                                 MaybeArenaStringAccessor s);
 
   PROTOBUF_NODISCARD const char* ReadCord(const char* ptr, int size,
                                           ::absl::Cord* cord) {
@@ -1267,7 +1270,6 @@ PROTOBUF_NODISCARD inline const char* InlineCordParser(::absl::Cord* cord,
   return ctx->ReadCord(ptr, size, cord);
 }
 
-
 template <typename T>
 PROTOBUF_NODISCARD const char* FieldParser(uint64_t tag, T& field_parser,
                                            const char* ptr, ParseContext* ctx) {
diff --git a/src/google/protobuf/proto3_arena_unittest.cc b/src/google/protobuf/proto3_arena_unittest.cc
index 49fc0b15c..2cafd0eb0 100644
--- a/src/google/protobuf/proto3_arena_unittest.cc
+++ b/src/google/protobuf/proto3_arena_unittest.cc
@@ -286,13 +286,7 @@ TEST(Proto3ArenaTest, CheckOneofMessageFieldIsCleared) {
   child->set_bb(100);
   msg->Clear();
 
-#ifndef PROTOBUF_ASAN
   EXPECT_EQ(child->bb(), 0);
-#else
-#if GTEST_HAS_DEATH_TEST && defined(__cpp_if_constexpr)
-  EXPECT_DEATH(EXPECT_EQ(child->bb(), 100), "use-after-poison");
-#endif
-#endif
 }
 
 TEST(Proto3OptionalTest, OptionalFieldDescriptor) {
diff --git a/src/google/protobuf/reflection_internal.h b/src/google/protobuf/reflection_internal.h
index ea4bac293..99f7f8c7c 100644
--- a/src/google/protobuf/reflection_internal.h
+++ b/src/google/protobuf/reflection_internal.h
@@ -136,13 +136,39 @@ class RepeatedPtrFieldWrapper : public RandomAccessRepeatedFieldAccessor {
     MutableRepeatedField(data)->Clear();
   }
   void Set(Field* data, int index, const Value* value) const override {
+    DoSet(data, index, value);
+  }
+  template <typename U = T,
+            typename std::enable_if<!std::is_same<U, std::string>::value,
+                                    int>::type = 0>
+  void DoSet(Field* data, int index, const Value* value) const {
     ConvertToT(value, MutableRepeatedField(data)->Mutable(index));
   }
+  template <typename U = T,
+            typename std::enable_if<std::is_same<U, std::string>::value,
+                                    int>::type = 0>
+  void DoSet(Field* data, int index, const Value* value) const {
+    MutableRepeatedField(data)->MutableAccessor(index) =
+        *static_cast<const std::string*>(value);
+  }
   void Add(Field* data, const Value* value) const override {
+    DoAdd(data, value);
+  }
+  template <typename U = T,
+            typename std::enable_if<!std::is_same<U, std::string>::value,
+                                    int>::type = 0>
+  void DoAdd(Field* data, const Value* value) const {
     T* allocated = New(value);
     ConvertToT(value, allocated);
     MutableRepeatedField(data)->AddAllocated(allocated);
   }
+  template <typename U = T,
+            typename std::enable_if<std::is_same<U, std::string>::value,
+                                    int>::type = 0>
+  void DoAdd(Field* data, const Value* value) const {
+    MutableRepeatedField(data)->AddAccessor() =
+        *static_cast<const std::string*>(value);
+  }
   void RemoveLast(Field* data) const override {
     MutableRepeatedField(data)->RemoveLast();
   }
diff --git a/src/google/protobuf/reflection_visit_field_info.h b/src/google/protobuf/reflection_visit_field_info.h
index f0c65db8a..25c8c2ad3 100644
--- a/src/google/protobuf/reflection_visit_field_info.h
+++ b/src/google/protobuf/reflection_visit_field_info.h
@@ -190,14 +190,18 @@ struct DynamicExtensionInfoHelper {
 #undef PROTOBUF_REPEATED_PTR_FIELD_METHODS
 
   static absl::string_view GetStringView(const Extension& ext) {
-    return *ext.string_value;
+    return *ext.string_value.Get();
   }
-  static void SetStringView(Extension& ext, absl::string_view value) {
-    ext.string_value->assign(value.data(), value.size());
+  static void SetStringView(Extension& ext, Arena* arena,
+                            absl::string_view value) {
+    MaybeArenaStringAccessor(
+        ext.string_value.IsFixedSizeArena() ? arena : nullptr,
+        ext.string_value.Get())
+        ->assign(value.data(), value.size());
   }
   static void ClearStringView(Extension& ext) {
     ext.is_cleared = true;
-    ext.string_value->clear();
+    MaybeArenaStringAccessor::clear(ext.string_value.Get());
   }
 
   static const Message& GetMessage(const Extension& ext) {
@@ -486,10 +490,10 @@ struct StringDynamicFieldInfo {
 ////////////////////////////////////////////////////////////////////////
 // Extension string fields
 ////////////////////////////////////////////////////////////////////////
-template <typename ExtensionT>
+template <typename ExtensionS, typename ExtensionT>
 struct StringDynamicExtensionInfo {
-  constexpr StringDynamicExtensionInfo(ExtensionT& e, int n)
-      : ext(e), ext_number(n) {}
+  constexpr StringDynamicExtensionInfo(ExtensionS& s, ExtensionT& e, int n)
+      : set(s), ext(e), ext_number(n) {}
 
   int number() const { return ext_number; }
   FieldDescriptor::Type type() const {
@@ -500,7 +504,7 @@ struct StringDynamicExtensionInfo {
     return DynamicExtensionInfoHelper::GetStringView(ext);
   }
   void Set(absl::string_view value) {
-    DynamicExtensionInfoHelper::SetStringView(ext, value);
+    DynamicExtensionInfoHelper::SetStringView(ext, set.GetArena(), value);
   }
   void Clear() { DynamicExtensionInfoHelper::ClearStringView(ext); }
   size_t FieldByteSize() const { return WireFormatLite::StringSize(Get()); }
@@ -513,6 +517,7 @@ struct StringDynamicExtensionInfo {
   static constexpr bool is_oneof = false;     // NOLINT
   static constexpr bool is_cord = false;      // NOLINT
 
+  ExtensionS& set;
   ExtensionT& ext;
   int ext_number;
 };
diff --git a/src/google/protobuf/reflection_visit_fields.h b/src/google/protobuf/reflection_visit_fields.h
index 3b53155b5..e44dfdab6 100644
--- a/src/google/protobuf/reflection_visit_fields.h
+++ b/src/google/protobuf/reflection_visit_fields.h
@@ -20,7 +20,6 @@
 #include "google/protobuf/repeated_field.h"
 #include "google/protobuf/repeated_ptr_field.h"
 
-
 // Must be the last include.
 #include "google/protobuf/port_def.inc"  // NOLINT
 
@@ -388,8 +387,9 @@ void ReflectionVisit::VisitFields(MessageT& message, CallbackFn&& func,
 
         case FieldDescriptor::TYPE_BYTES:
         case FieldDescriptor::TYPE_STRING:
-          func(
-              internal::StringDynamicExtensionInfo<decltype(ext)>{ext, number});
+          func(internal::StringDynamicExtensionInfo<decltype(set),
+                                                    decltype(ext)>{set, ext,
+                                                                   number});
           break;
 
         default:
diff --git a/src/google/protobuf/reflection_visit_fields_test.cc b/src/google/protobuf/reflection_visit_fields_test.cc
index eb69d9bb0..73e21dbb1 100644
--- a/src/google/protobuf/reflection_visit_fields_test.cc
+++ b/src/google/protobuf/reflection_visit_fields_test.cc
@@ -164,7 +164,11 @@ void MutateNothingByVisit(Message& message) {
             it.CopyFrom({it.data(), it.size()});
           }
         } else {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+          for (auto it : info.Mutable()) {
+#else   // GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
           for (auto& it : info.Mutable()) {
+#endif  // GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
             std::string tmp;
             tmp = it;
             it = tmp;
diff --git a/src/google/protobuf/repeated_field_unittest.cc b/src/google/protobuf/repeated_field_unittest.cc
index 144e17c93..6cb4a056a 100644
--- a/src/google/protobuf/repeated_field_unittest.cc
+++ b/src/google/protobuf/repeated_field_unittest.cc
@@ -1607,7 +1607,7 @@ TEST(RepeatedPtrField, SwapLargeLarge) {
 }
 
 static int ReservedSpace(RepeatedPtrField<std::string>* field) {
-  const std::string* const* ptr = field->data();
+  auto ptr = field->data();
   do {
     field->Add();
   } while (field->data() == ptr);
@@ -1636,7 +1636,7 @@ TEST(RepeatedPtrField, ReserveLessThanDouble) {
 TEST(RepeatedPtrField, ReserveLessThanExisting) {
   RepeatedPtrField<std::string> field;
   field.Reserve(20);
-  const std::string* const* previous_ptr = field.data();
+  auto previous_ptr = field.data();
   field.Reserve(10);
 
   EXPECT_EQ(previous_ptr, field.data());
@@ -1648,11 +1648,11 @@ TEST(RepeatedPtrField, ReserveDoesntLoseAllocated) {
   // failed to copy pointers to allocated-but-cleared objects, possibly
   // leading to segfaults.
   RepeatedPtrField<std::string> field;
-  std::string* first = field.Add();
+  std::string* first = field.AddString();
   field.RemoveLast();
 
   field.Reserve(20);
-  EXPECT_EQ(first, field.Add());
+  EXPECT_EQ(first, field.AddString());
 }
 
 // Clearing elements is tricky with RepeatedPtrFields since the memory for
@@ -1661,7 +1661,7 @@ TEST(RepeatedPtrField, ClearedElements) {
   PROTOBUF_IGNORE_DEPRECATION_START
   RepeatedPtrField<std::string> field;
 
-  std::string* original = field.Add();
+  std::string* original = field.AddString();
   *original = "foo";
 
   EXPECT_EQ(field.ClearedCount(), 0);
@@ -1670,17 +1670,19 @@ TEST(RepeatedPtrField, ClearedElements) {
   EXPECT_TRUE(original->empty());
   EXPECT_EQ(field.ClearedCount(), 1);
 
-  EXPECT_EQ(field.Add(),
+  EXPECT_EQ(field.AddString(),
             original);  // Should return same string for reuse.
-  EXPECT_EQ(field.UnsafeArenaReleaseLast(), original);  // We take ownership.
+  EXPECT_EQ(field.UnsafeArenaReleaseLast()->ToStringPtr(),
+            original);  // We take ownership.
   EXPECT_EQ(field.ClearedCount(), 0);
 
-  EXPECT_NE(field.Add(), original);  // Should NOT return the same string.
+  EXPECT_NE(field.AddString(), original);  // Should NOT return the same string.
   EXPECT_EQ(field.ClearedCount(), 0);
 
-  field.UnsafeArenaAddAllocated(original);  // Give ownership back.
+  field.UnsafeArenaAddAllocated(internal::StringHandlerType::ToUnTagged(
+      original));  // Give ownership back.
   EXPECT_EQ(field.ClearedCount(), 0);
-  EXPECT_EQ(field.Mutable(1), original);
+  EXPECT_EQ(field.MutableString(1), original);
 
   field.Clear();
   EXPECT_EQ(field.ClearedCount(), 2);
@@ -1775,7 +1777,6 @@ TEST(RepeatedPtrField, MergeFrom) {
   EXPECT_EQ("5", destination.Get(4));
 }
 
-
 TEST(RepeatedPtrField, CopyFrom) {
   RepeatedPtrField<std::string> source, destination;
   source.Add()->assign("4");
@@ -1912,13 +1913,17 @@ TEST(RepeatedPtrField, SmallOptimization) {
   // We use UnsafeArenaAddAllocated just to grow the array without creating
   // objects or causing extra cleanup costs in the arena to make the
   // measurements simpler.
-  array->UnsafeArenaAddAllocated(&str);
+  array->UnsafeArenaAddAllocated(internal::StringHandlerType::ToUnTagged(&str));
   // No backing array, just the string.
   EXPECT_EQ(array->SpaceUsedExcludingSelf(), sizeof(str));
   // We have not used any arena space.
   EXPECT_EQ(usage_before, arena.SpaceUsed());
   // Verify the string is where we think it is.
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  EXPECT_EQ(array->begin()->underlying(), &str);
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   EXPECT_EQ(&*array->begin(), &str);
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   EXPECT_EQ(array->pointer_begin()[0], &str);
   auto is_inlined = [array]() {
     return std::less_equal<void*>{}(array, &*array->pointer_begin()) &&
@@ -1929,7 +1934,8 @@ TEST(RepeatedPtrField, SmallOptimization) {
 
   // Adding a second object stops sso.
   std::string str2;
-  array->UnsafeArenaAddAllocated(&str2);
+  array->UnsafeArenaAddAllocated(
+      internal::StringHandlerType::ToUnTagged(&str2));
   EXPECT_EQ(array->Capacity(), 3);
   // Backing array and the strings.
   EXPECT_EQ(array->SpaceUsedExcludingSelf(),
@@ -1974,7 +1980,7 @@ TEST(RepeatedPtrField, MoveConstruct) {
     RepeatedPtrField<std::string> source;
     *source.Add() = "1";
     *source.Add() = "2";
-    const std::string* const* data = source.data();
+    auto data = source.data();
     RepeatedPtrField<std::string> destination = std::move(source);
     EXPECT_EQ(data, destination.data());
     EXPECT_THAT(destination, ElementsAre("1", "2"));
@@ -2004,7 +2010,7 @@ TEST(RepeatedPtrField, MoveAssign) {
     *source.Add() = "2";
     RepeatedPtrField<std::string> destination;
     *destination.Add() = "3";
-    const std::string* const* source_data = source.data();
+    auto source_data = source.data();
     destination = std::move(source);
     EXPECT_EQ(source_data, destination.data());
     EXPECT_THAT(destination, ElementsAre("1", "2"));
@@ -2019,7 +2025,7 @@ TEST(RepeatedPtrField, MoveAssign) {
     RepeatedPtrField<std::string>* destination =
         Arena::Create<RepeatedPtrField<std::string>>(&arena);
     *destination->Add() = "3";
-    const std::string* const* source_data = source->data();
+    auto source_data = source->data();
     *destination = std::move(*source);
     EXPECT_EQ(source_data, destination->data());
     EXPECT_THAT(*destination, ElementsAre("1", "2"));
@@ -2075,7 +2081,7 @@ TEST(RepeatedPtrField, MoveAssign) {
     RepeatedPtrField<std::string>& alias = field;
     *field.Add() = "1";
     *field.Add() = "2";
-    const std::string* const* data = field.data();
+    auto data = field.data();
     field = std::move(alias);
     EXPECT_EQ(data, field.data());
     EXPECT_THAT(field, ElementsAre("1", "2"));
@@ -2086,7 +2092,7 @@ TEST(RepeatedPtrField, MoveAssign) {
         Arena::Create<RepeatedPtrField<std::string>>(&arena);
     *field->Add() = "1";
     *field->Add() = "2";
-    const std::string* const* data = field->data();
+    auto data = field->data();
     *field = std::move(*field);
     EXPECT_EQ(data, field->data());
     EXPECT_THAT(*field, ElementsAre("1", "2"));
@@ -2099,8 +2105,8 @@ TEST(RepeatedPtrField, MutableDataIsMutable) {
   EXPECT_EQ("1", field.Get(0));
   // The fact that this line compiles would be enough, but we'll check the
   // value anyway.
-  std::string** data = field.mutable_data();
-  **data = "2";
+  auto data = field.mutable_data();
+  *(*data)->UnTaggedToStringPtr() = "2";
   EXPECT_EQ("2", field.Get(0));
 }
 
@@ -2109,9 +2115,13 @@ TEST(RepeatedPtrField, SubscriptOperators) {
   *field.Add() = "1";
   EXPECT_EQ("1", field.Get(0));
   EXPECT_EQ("1", field[0]);
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  EXPECT_EQ(field.MutableString(0), field[0]->underlying());
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   EXPECT_EQ(field.Mutable(0), &field[0]);
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   const RepeatedPtrField<std::string>& const_field = field;
-  EXPECT_EQ(*field.data(), &const_field[0]);
+  EXPECT_EQ((*field.data())->ToStringPtr(), &const_field[0]);
 }
 
 TEST(RepeatedPtrField, ExtractSubrange) {
@@ -2151,9 +2161,9 @@ TEST(RepeatedPtrField, ExtractSubrange) {
 
           // Does the resulting array contain the right values?
           for (int i = 0; i < start; ++i)
-            EXPECT_EQ(field.Mutable(i), subject[i]);
+            EXPECT_EQ(field.MutableString(i), subject[i]);
           for (int i = start; i < field.size(); ++i)
-            EXPECT_EQ(field.Mutable(i), subject[i + num]);
+            EXPECT_EQ(field.MutableString(i), subject[i + num]);
 
           // Reinstate the cleared elements.
           EXPECT_EQ(field.ClearedCount(), extra);
@@ -2165,7 +2175,7 @@ TEST(RepeatedPtrField, ExtractSubrange) {
           for (int i = sz; i < sz + extra; ++i) {
             int count = 0;
             for (int j = sz; j < sz + extra; ++j) {
-              if (field.Mutable(j - num) == subject[i]) count += 1;
+              if (field.MutableString(j - num) == subject[i]) count += 1;
             }
             EXPECT_EQ(count, 1);
           }
@@ -2776,8 +2786,8 @@ TEST_F(RepeatedFieldInsertionIteratorsTest,
     *new_data = absl::StrCat("name-", i);
     data.push_back(new_data);
 
-    new_data = goldenproto.add_repeated_string();
-    *new_data = absl::StrCat("name-", i);
+    auto new_data2 = goldenproto.add_repeated_string();
+    *new_data2 = absl::StrCat("name-", i);
   }
   TestAllTypes testproto;
   std::copy(data.begin(), data.end(),
@@ -2805,13 +2815,13 @@ TEST_F(RepeatedFieldInsertionIteratorsTest,
 
 TEST_F(RepeatedFieldInsertionIteratorsTest,
        UnsafeArenaAllocatedRepeatedPtrFieldWithString) {
-  std::vector<std::string*> data;
+  std::vector<internal::StringHandlerType*> data;
   Arena arena;
   auto* goldenproto = Arena::Create<TestAllTypes>(&arena);
   for (int i = 0; i < 10; ++i) {
-    auto* new_data = goldenproto->add_repeated_string();
+    auto new_data = goldenproto->add_repeated_string();
     *new_data = absl::StrCat("name-", i);
-    data.push_back(new_data);
+    data.push_back(internal::StringHandlerType::ToUnTagged(new_data));
   }
   auto* testproto = Arena::Create<TestAllTypes>(&arena);
   std::copy(data.begin(), data.end(),
diff --git a/src/google/protobuf/repeated_ptr_field.cc b/src/google/protobuf/repeated_ptr_field.cc
index 891439c14..785701733 100644
--- a/src/google/protobuf/repeated_ptr_field.cc
+++ b/src/google/protobuf/repeated_ptr_field.cc
@@ -130,24 +130,37 @@ memswap<ArenaOffsetHelper<RepeatedPtrFieldBase>::value>(
     char* PROTOBUF_RESTRICT, char* PROTOBUF_RESTRICT);
 
 template <>
-void RepeatedPtrFieldBase::MergeFrom<std::string>(
+void RepeatedPtrFieldBase::MergeFrom<GenericTypeHandler<std::string>::Type>(
     const RepeatedPtrFieldBase& from) {
+  using TypeHandler = GenericTypeHandler<std::string>;
   ABSL_DCHECK_NE(&from, this);
   int new_size = current_size_ + from.current_size_;
-  auto dst = reinterpret_cast<std::string**>(InternalReserve(new_size));
-  auto src = reinterpret_cast<std::string* const*>(from.elements());
+  auto dst = reinterpret_cast<TypeHandler::Type**>(InternalReserve(new_size));
+  auto src = reinterpret_cast<TypeHandler::Type* const*>(from.elements());
   auto end = src + from.current_size_;
   auto end_assign = src + std::min(ClearedCount(), from.current_size_);
-  for (; src < end_assign; ++dst, ++src) {
-    (*dst)->assign(**src);
-  }
+
   if (Arena* const arena = arena_) {
+    for (; src < end_assign; ++dst, ++src) {
+      if ((*dst)->IsTagged()) {
+        ArenaStringAccessor(arena, (*dst)->ToStringPtr())
+            .assign(*(*src)->ToStringPtr());
+      } else {
+        (*dst)->UnTaggedToStringPtr()->assign(*(*src)->ToStringPtr());
+      }
+    }
     for (; src < end; ++dst, ++src) {
-      *dst = Arena::Create<std::string>(arena, **src);
+      auto accessor =
+          ArenaStringAccessor::create(arena, *(*src)->ToStringPtr());
+      *dst = StringHandlerType::ToTagged(accessor.underlying());
     }
   } else {
+    for (; src < end_assign; ++dst, ++src) {
+      (*dst)->UnTaggedToStringPtr()->assign(*(*src)->ToStringPtr());
+    }
     for (; src < end; ++dst, ++src) {
-      *dst = new std::string(**src);
+      *dst = StringHandlerType::ToUnTagged(
+          new std::string(*(*src)->ToStringPtr()));
     }
   }
   ExchangeCurrentSize(new_size);
@@ -156,6 +169,17 @@ void RepeatedPtrFieldBase::MergeFrom<std::string>(
   }
 }
 
+template <>
+void RepeatedPtrFieldBase::AddAllocatedSlowWithCopy<
+    GenericTypeHandler<std::string>>(StringHandlerType* value,
+                                     Arena* value_arena, Arena* my_arena) {
+  using TypeHandler = GenericTypeHandler<std::string>;
+  if (my_arena != nullptr) {
+    my_arena->Own(value->UnTaggedToStringPtr());
+  }
+
+  UnsafeArenaAddAllocated<TypeHandler>(value);
+}
 
 int RepeatedPtrFieldBase::MergeIntoClearedMessages(
     const RepeatedPtrFieldBase& from) {
@@ -224,7 +248,7 @@ void RepeatedPtrFieldBase::MergeFrom<MessageLite>(
 }
 
 void* NewStringElement(Arena* arena) {
-  return Arena::Create<std::string>(arena);
+  return GenericTypeHandler<std::string>::New(arena);
 }
 
 }  // namespace internal
diff --git a/src/google/protobuf/repeated_ptr_field.h b/src/google/protobuf/repeated_ptr_field.h
index acbdb0c16..46c5c4a47 100644
--- a/src/google/protobuf/repeated_ptr_field.h
+++ b/src/google/protobuf/repeated_ptr_field.h
@@ -36,11 +36,11 @@
 #include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
 #include "google/protobuf/arena.h"
+#include "google/protobuf/arenastring.h"
 #include "google/protobuf/internal_visibility.h"
 #include "google/protobuf/message_lite.h"
 #include "google/protobuf/port.h"
 
-
 // Must be included last.
 #include "google/protobuf/port_def.inc"
 
@@ -765,12 +765,40 @@ inline void RepeatedPtrFieldBase::MergeFrom<Message>(
   return MergeFrom<MessageLite>(from);
 }
 
+// Use 1 << 1 bit in string* mark a string as arenastring
+// store this tagged ptr as StringHandlerType to disable align optimize
+struct StringHandlerType {
+  inline std::string* ToStringPtr() noexcept {
+    return reinterpret_cast<std::string*>(reinterpret_cast<uintptr_t>(this) &
+                                          ~2);
+  }
+  inline const std::string* ToStringPtr() const noexcept {
+    return reinterpret_cast<const std::string*>(
+        reinterpret_cast<uintptr_t>(this) & ~2);
+  }
+  inline std::string* UnTaggedToStringPtr() noexcept {
+    return reinterpret_cast<std::string*>(this);
+  }
+  inline const std::string* UnTaggedToStringPtr() const noexcept {
+    return reinterpret_cast<const std::string*>(this);
+  }
+  inline bool IsTagged() const noexcept {
+    return reinterpret_cast<uintptr_t>(this) & 2;
+  }
+  inline static StringHandlerType* ToTagged(std::string* string) noexcept {
+    return reinterpret_cast<StringHandlerType*>(
+        reinterpret_cast<uintptr_t>(string) | 2);
+  }
+  inline static StringHandlerType* ToUnTagged(std::string* string) noexcept {
+    return reinterpret_cast<StringHandlerType*>(string);
+  }
+};
+
 // Appends all `std::string` values from `from` to this instance.
 template <>
-void RepeatedPtrFieldBase::MergeFrom<std::string>(
+void RepeatedPtrFieldBase::MergeFrom<StringHandlerType>(
     const RepeatedPtrFieldBase& from);
 
-
 template <typename F>
 void* RepeatedPtrFieldBase::AddInternal(F factory) {
   Arena* const arena = GetArena();
@@ -891,36 +919,47 @@ PROTOBUF_EXPORT void* NewStringElement(Arena* arena);
 template <>
 class GenericTypeHandler<std::string> {
  public:
-  typedef std::string Type;
-  using Movable = IsMovable<Type>;
+  // Use StringHandlerType* instead of string* to support tagged ptr
+  using Type = StringHandlerType;
+  using Movable = IsMovable<std::string>;
 
   static constexpr auto GetNewFunc() { return NewStringElement; }
 
-  static PROTOBUF_NOINLINE std::string* New(Arena* arena) {
-    return Arena::Create<std::string>(arena);
-  }
-  static PROTOBUF_NOINLINE std::string* New(Arena* arena, std::string&& value) {
-    return Arena::Create<std::string>(arena, std::move(value));
+  static PROTOBUF_NOINLINE Type* New(Arena* arena) {
+    if (arena != nullptr) {
+      return Type::ToTagged(ArenaStringAccessor::create(arena).underlying());
+    } else {
+      return Type::ToUnTagged(new std::string());
+    }
   }
-  static inline std::string* NewFromPrototype(const std::string*,
-                                              Arena* arena) {
+  static inline Type* NewFromPrototype(const Type*, Arena* arena) {
     return New(arena);
   }
-  static inline Arena* GetArena(std::string*) { return nullptr; }
-  static inline void Delete(std::string* value, Arena* arena) {
+  static inline Arena* GetArena(Type*) { return nullptr; }
+  static inline void Delete(Type* value, Arena* arena) {
     if (arena == nullptr) {
-      delete value;
+      delete value->UnTaggedToStringPtr();
     }
   }
-  static inline void Clear(std::string* value) { value->clear(); }
-  static inline void Merge(const std::string& from, std::string* to) {
-    *to = from;
+  static inline void Clear(Type* value) {
+    MaybeArenaStringAccessor::clear(value->ToStringPtr());
+  }
+  static inline void Merge(const Type& from, Type* to) {
+    *to->UnTaggedToStringPtr() = *from.UnTaggedToStringPtr();
   }
-  static size_t SpaceUsedLong(const std::string& value) {
-    return sizeof(value) + StringSpaceUsedExcludingSelfLong(value);
+  static size_t SpaceUsedLong(const Type& value) {
+    return sizeof(std::string) +
+           StringSpaceUsedExcludingSelfLong(*value.ToStringPtr());
   }
 };
 
+// Most function of RepeatedPtrFieldBase is type erased except
+// AddAllocatedSlowWithCopy
+template <>
+void RepeatedPtrFieldBase::AddAllocatedSlowWithCopy<
+    GenericTypeHandler<std::string>>(StringHandlerType* value,
+                                     Arena* value_arena, Arena* my_arena);
+
 }  // namespace internal
 
 // RepeatedPtrField is like RepeatedField, but used for repeated strings or
@@ -943,6 +982,10 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
         "We only support string and Message types in RepeatedPtrField.");
   }
 
+  // Note:  RepeatedPtrField SHOULD NOT be subclassed by users.
+  using TypeHandler = internal::GenericTypeHandler<Element>;
+  using StorageType = typename TypeHandler::Type;
+
  public:
   using value_type = Element;
   using size_type = int;
@@ -996,13 +1039,46 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   int size() const;
 
   const_reference Get(int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  template <typename T = Element,
+            typename std::enable_if<!std::is_same<T, std::string>::value,
+                                    int>::type = 0>
   pointer Mutable(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  // Replace return type of mutable function from string* to MutableStringType
+  template <typename T = Element,
+            typename std::enable_if<std::is_same<T, std::string>::value,
+                                    int>::type = 0>
+  MutableStringType Mutable(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  pointer MutableString(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  MaybeArenaStringAccessor MutableAccessor(int index)
+      ABSL_ATTRIBUTE_LIFETIME_BOUND;
 
   // Unlike std::vector, adding an element to a RepeatedPtrField doesn't always
   // make a new element; it might re-use an element left over from when the
   // field was Clear()'d or resize()'d smaller.  For this reason, Add() is the
   // fastest API for adding a new element.
+  template <typename T = Element,
+            typename std::enable_if<!std::is_same<T, std::string>::value,
+                                    int>::type = 0>
   pointer Add() ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  // Replace return type of mutable function from string* to MutableStringType
+  template <typename T = Element,
+            typename std::enable_if<std::is_same<T, std::string>::value,
+                                    int>::type = 0>
+  MutableStringType Add();
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  Element* AddString();
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  MaybeArenaStringAccessor AddAccessor();
 
   // `Add(std::move(value));` is equivalent to `*Add() = std::move(value);`
   // It will either move-construct to the end of this field, or swap value
@@ -1021,18 +1097,35 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
 
   // Append elements in the range [begin, end) after reserving
   // the appropriate number of elements.
-  template <typename Iter>
+  template <typename Iter, typename T = Element,
+            typename std::enable_if<!std::is_same<T, std::string>::value,
+                                    int>::type = 0>
+  void Add(Iter begin, Iter end);
+  // Specialization for string
+  template <typename Iter, typename T = Element,
+            typename std::enable_if<std::is_same<T, std::string>::value,
+                                    int>::type = 0>
   void Add(Iter begin, Iter end);
 
   const_reference operator[](int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
     return Get(index);
   }
-  reference operator[](int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  typename std::conditional<::std::is_same<Element, std::string>::value,
+                            MutableStringReferenceType, reference>::type
+  operator[](int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
     return *Mutable(index);
   }
 
   const_reference at(int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  template <typename T = Element,
+            typename std::enable_if<!std::is_same<T, std::string>::value,
+                                    int>::type = 0>
   reference at(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  // Replace return type of mutable function from string* to MutableStringType
+  template <typename T = Element,
+            typename std::enable_if<std::is_same<T, std::string>::value,
+                                    int>::type = 0>
+  MutableStringReferenceType at(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
 
   // Removes the last element in the array.
   // Ownership of the element is retained by the array.
@@ -1060,9 +1153,10 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
 
   // Gets the underlying array.  This pointer is possibly invalidated by
   // any add or remove operation.
-  Element**
-  mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND;
-  const Element* const* data() const ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  //
+  // Underlying pointer for string maybe tagged
+  StorageType** mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  const StorageType* const* data() const ABSL_ATTRIBUTE_LIFETIME_BOUND;
 
   // Swaps entire contents with "other". If they are on separate arenas, then
   // copies data.
@@ -1149,13 +1243,17 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   // transfers to the arena at the "AddAllocated" call and is not released
   // anymore, causing a double delete. UnsafeArenaAddAllocated prevents this.
   // Requires:  value != nullptr
-  void UnsafeArenaAddAllocated(Element* value);
+  //
+  // Underlying pointer for string maybe tagged
+  void UnsafeArenaAddAllocated(StorageType* value);
 
   // Removes and returns the last element.  Unlike ReleaseLast, the returned
   // pointer is always to the original object.  This may be in an arena, in
   // which case it would have the arena's lifetime.
   // Requires: current_size_ > 0
-  pointer UnsafeArenaReleaseLast();
+  //
+  // Underlying pointer for string maybe tagged
+  StorageType* UnsafeArenaReleaseLast();
 
   // Extracts elements with indices in the range "[start .. start+num-1]".
   // The caller assumes ownership of the extracted elements and is responsible
@@ -1178,7 +1276,9 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   // copies are ever performed. Instead, the raw object pointers are returned.
   // Thus, if on an arena, the returned objects must not be freed, because they
   // will not be heap-allocated objects.
-  void UnsafeArenaExtractSubrange(int start, int num, Element** elements);
+  //
+  // Underlying pointer for string maybe tagged
+  void UnsafeArenaExtractSubrange(int start, int num, StorageType** elements);
 
   // When elements are removed by calls to RemoveLast() or Clear(), they
   // are not actually freed.  Instead, they are cleared and kept so that
@@ -1219,7 +1319,6 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
     internal::RepeatedPtrFieldBase::InternalSwap(other);
   }
 
-
  private:
   using InternalArenaConstructable_ = void;
   using DestructorSkippable_ = void;
@@ -1231,14 +1330,10 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   template <typename T>
   friend struct WeakRepeatedPtrField;
 
-  // Note:  RepeatedPtrField SHOULD NOT be subclassed by users.
-  using TypeHandler = internal::GenericTypeHandler<Element>;
-
   RepeatedPtrField(Arena* arena, const RepeatedPtrField& rhs);
   RepeatedPtrField(Arena* arena, RepeatedPtrField&& rhs);
 
-
-  void AddAllocatedForParse(Element* p) {
+  void AddAllocatedForParse(StorageType* p) {
     return RepeatedPtrFieldBase::AddAllocatedForParse(p);
   }
 };
@@ -1348,37 +1443,139 @@ inline const Element& RepeatedPtrField<Element>::Get(int index) const
   return RepeatedPtrFieldBase::Get<TypeHandler>(index);
 }
 
+template <>
+inline const std::string& RepeatedPtrField<std::string>::Get(int index) const
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  return *RepeatedPtrFieldBase::Get<TypeHandler>(index).ToStringPtr();
+}
+
 template <typename Element>
 inline const Element& RepeatedPtrField<Element>::at(int index) const
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return RepeatedPtrFieldBase::at<TypeHandler>(index);
+  return Get(index);
 }
 
 template <typename Element>
+template <typename T, typename std::enable_if<
+                          !std::is_same<T, std::string>::value, int>::type>
 inline Element& RepeatedPtrField<Element>::at(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::at<TypeHandler>(index);
 }
 
+template <typename Element>
+template <typename T, typename std::enable_if<
+                          std::is_same<T, std::string>::value, int>::type>
+inline MutableStringReferenceType RepeatedPtrField<Element>::at(int index) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(index);
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return *MutableString(index);
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
 
 template <typename Element>
+template <typename T, typename std::enable_if<
+                          !std::is_same<T, std::string>::value, int>::type>
 inline Element* RepeatedPtrField<Element>::Mutable(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::Mutable<TypeHandler>(index);
 }
 
 template <typename Element>
-inline Element* RepeatedPtrField<Element>::Add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
+template <typename T, typename std::enable_if<
+                          std::is_same<T, std::string>::value, int>::type>
+inline MutableStringType RepeatedPtrField<Element>::Mutable(int index)
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(index);
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableString(index);
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+template <typename Element>
+template <typename T, typename>
+inline Element* RepeatedPtrField<Element>::MutableString(int index)
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  auto value = RepeatedPtrFieldBase::Mutable<TypeHandler>(index);
+  if (value->IsTagged()) {
+    auto string = Arena::Create<std::string>(GetArena(), *value->ToStringPtr());
+    raw_mutable_data()[index] = string;
+    return string;
+  }
+  return value->UnTaggedToStringPtr();
+}
+
+template <typename Element>
+template <typename T, typename>
+inline MaybeArenaStringAccessor RepeatedPtrField<Element>::MutableAccessor(
+    int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  auto value = RepeatedPtrFieldBase::Mutable<TypeHandler>(index);
+  if (value->IsTagged()) {
+    return MaybeArenaStringAccessor(GetArena(), value->ToStringPtr());
+  }
+  return MaybeArenaStringAccessor(nullptr, value->UnTaggedToStringPtr());
+}
+
+template <typename Element>
+template <typename T, typename std::enable_if<
+                          !std::is_same<T, std::string>::value, int>::type>
+PROTOBUF_NOINLINE Element* RepeatedPtrField<Element>::Add()
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::Add<TypeHandler>();
 }
 
+template <typename Element>
+template <typename T, typename std::enable_if<
+                          std::is_same<T, std::string>::value, int>::type>
+inline MutableStringType RepeatedPtrField<Element>::Add()
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return AddAccessor();
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return AddString();
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+template <typename Element>
+template <typename T, typename>
+inline Element* RepeatedPtrField<Element>::AddString()
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  auto value = RepeatedPtrFieldBase::Add<TypeHandler>();
+  if (value->IsTagged()) {
+    auto string = Arena::Create<std::string>(GetArena(), *value->ToStringPtr());
+    raw_mutable_data()[size() - 1] = string;
+    return string;
+  }
+  return value->UnTaggedToStringPtr();
+}
+
+template <typename Element>
+template <typename T, typename>
+inline MaybeArenaStringAccessor RepeatedPtrField<Element>::AddAccessor()
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  auto value = RepeatedPtrFieldBase::Add<TypeHandler>();
+  if (value->IsTagged()) {
+    return MaybeArenaStringAccessor(GetArena(), value->ToStringPtr());
+  }
+  return MaybeArenaStringAccessor(nullptr, value->UnTaggedToStringPtr());
+}
+
 template <typename Element>
 inline void RepeatedPtrField<Element>::Add(Element&& value) {
   RepeatedPtrFieldBase::Add<TypeHandler>(std::move(value));
 }
 
+template <>
+inline void RepeatedPtrField<std::string>::Add(std::string&& value) {
+  AddAccessor() = std::move(value);
+}
+
 template <typename Element>
-template <typename Iter>
+template <
+    typename Iter, typename T,
+    typename std::enable_if<!std::is_same<T, std::string>::value, int>::type>
 inline void RepeatedPtrField<Element>::Add(Iter begin, Iter end) {
   if (std::is_base_of<
           std::forward_iterator_tag,
@@ -1391,6 +1588,22 @@ inline void RepeatedPtrField<Element>::Add(Iter begin, Iter end) {
   }
 }
 
+template <typename Element>
+template <
+    typename Iter, typename T,
+    typename std::enable_if<std::is_same<T, std::string>::value, int>::type>
+inline void RepeatedPtrField<Element>::Add(Iter begin, Iter end) {
+  if (std::is_base_of<
+          std::forward_iterator_tag,
+          typename std::iterator_traits<Iter>::iterator_category>::value) {
+    int reserve = static_cast<int>(std::distance(begin, end));
+    Reserve(size() + reserve);
+  }
+  for (; begin != end; ++begin) {
+    AddAccessor() = *begin;
+  }
+}
+
 template <typename Element>
 inline void RepeatedPtrField<Element>::RemoveLast() {
   RepeatedPtrFieldBase::RemoveLast<TypeHandler>();
@@ -1405,7 +1618,7 @@ inline void RepeatedPtrField<Element>::DeleteSubrange(int start, int num) {
   Arena* arena = GetArena();
   for (int i = 0; i < num; ++i) {
     using H = CommonHandler<TypeHandler>;
-    H::Delete(static_cast<Element*>(subrange[i]), arena);
+    H::Delete(static_cast<StorageType*>(subrange[i]), arena);
   }
   UnsafeArenaExtractSubrange(start, num, nullptr);
 }
@@ -1440,7 +1653,8 @@ inline void RepeatedPtrField<Element>::ExtractSubrange(int start, int num,
     // returned elements are heap-allocated. Otherwise, just forward it.
     if (arena != nullptr) {
       for (int i = 0; i < num; ++i) {
-        elements[i] = copy<TypeHandler>(extracted[i]);
+        elements[i] =
+            reinterpret_cast<Element*>(copy<TypeHandler>(extracted[i]));
       }
     } else {
       memcpy(elements, extracted, num * sizeof(Element*));
@@ -1452,7 +1666,7 @@ inline void RepeatedPtrField<Element>::ExtractSubrange(int start, int num,
 
 template <typename Element>
 inline void RepeatedPtrField<Element>::UnsafeArenaExtractSubrange(
-    int start, int num, Element** elements) {
+    int start, int num, StorageType** elements) {
   ABSL_DCHECK_GE(start, 0);
   ABSL_DCHECK_GE(num, 0);
   ABSL_DCHECK_LE(start + num, size());
@@ -1475,7 +1689,7 @@ template <typename Element>
 inline void RepeatedPtrField<Element>::MergeFrom(
     const RepeatedPtrField& other) {
   if (other.empty()) return;
-  RepeatedPtrFieldBase::MergeFrom<Element>(other);
+  RepeatedPtrFieldBase::MergeFrom<StorageType>(other);
 }
 
 template <typename Element>
@@ -1508,14 +1722,14 @@ RepeatedPtrField<Element>::erase(const_iterator first, const_iterator last)
 }
 
 template <typename Element>
-inline Element** RepeatedPtrField<Element>::mutable_data()
-    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+inline typename RepeatedPtrField<Element>::StorageType**
+RepeatedPtrField<Element>::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::mutable_data<TypeHandler>();
 }
 
 template <typename Element>
-inline const Element* const* RepeatedPtrField<Element>::data() const
-    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+inline const typename RepeatedPtrField<Element>::StorageType* const*
+RepeatedPtrField<Element>::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::data<TypeHandler>();
 }
 
@@ -1559,8 +1773,15 @@ inline void RepeatedPtrField<Element>::AddAllocated(Element* value) {
   RepeatedPtrFieldBase::AddAllocated<TypeHandler>(value);
 }
 
+template <>
+inline void RepeatedPtrField<std::string>::AddAllocated(std::string* value) {
+  RepeatedPtrFieldBase::AddAllocated<TypeHandler>(
+      internal::StringHandlerType::ToUnTagged(value));
+}
+
 template <typename Element>
-inline void RepeatedPtrField<Element>::UnsafeArenaAddAllocated(Element* value) {
+inline void RepeatedPtrField<Element>::UnsafeArenaAddAllocated(
+    StorageType* value) {
   RepeatedPtrFieldBase::UnsafeArenaAddAllocated<TypeHandler>(value);
 }
 
@@ -1569,8 +1790,20 @@ inline Element* RepeatedPtrField<Element>::ReleaseLast() {
   return RepeatedPtrFieldBase::ReleaseLast<TypeHandler>();
 }
 
+template <>
+inline std::string* RepeatedPtrField<std::string>::ReleaseLast() {
+  auto value = RepeatedPtrFieldBase::UnsafeArenaReleaseLast<TypeHandler>();
+  if (value->IsTagged()) {
+    return new std::string(*value->ToStringPtr());
+  } else if (GetArena() != nullptr) {
+    return new std::string(::std::move(*value->UnTaggedToStringPtr()));
+  }
+  return value->UnTaggedToStringPtr();
+}
+
 template <typename Element>
-inline Element* RepeatedPtrField<Element>::UnsafeArenaReleaseLast() {
+inline typename RepeatedPtrField<Element>::StorageType*
+RepeatedPtrField<Element>::UnsafeArenaReleaseLast() {
   return RepeatedPtrFieldBase::UnsafeArenaReleaseLast<TypeHandler>();
 }
 
@@ -1611,11 +1844,16 @@ class RepeatedPtrIterator {
   using iterator_category = std::random_access_iterator_tag;
   using value_type = typename std::remove_const<Element>::type;
   using difference_type = std::ptrdiff_t;
-  using pointer = Element*;
-  using reference = Element&;
+  using pointer =
+      typename std::conditional<std::is_same<std::string, Element>::value,
+                                MutableStringType, Element*>::type;
+  using reference =
+      typename std::conditional<std::is_same<std::string, Element>::value,
+                                MutableStringReferenceType, Element&>::type;
+  using TypeHandler = GenericTypeHandler<std::string>;
 
-  RepeatedPtrIterator() : it_(nullptr) {}
-  explicit RepeatedPtrIterator(void* const* it) : it_(it) {}
+  RepeatedPtrIterator() : it_(nullptr), arena_(nullptr) {}
+  RepeatedPtrIterator(void* const* it, Arena* arena) : it_(it), arena_(arena) {}
 
   // Allows "upcasting" from RepeatedPtrIterator<T**> to
   // RepeatedPtrIterator<const T*const*>.
@@ -1623,7 +1861,7 @@ class RepeatedPtrIterator {
             typename std::enable_if<std::is_convertible<
                 OtherElement*, pointer>::value>::type* = nullptr>
   RepeatedPtrIterator(const RepeatedPtrIterator<OtherElement>& other)
-      : it_(other.it_) {}
+      : it_(other.it_), arena_(other.arena_) {}
 
   // dereferenceable
   reference operator*() const { return *reinterpret_cast<Element*>(*it_); }
@@ -1634,12 +1872,12 @@ class RepeatedPtrIterator {
     ++it_;
     return *this;
   }
-  iterator operator++(int) { return iterator(it_++); }
+  iterator operator++(int) { return iterator(it_++, arena_); }
   iterator& operator--() {
     --it_;
     return *this;
   }
-  iterator operator--(int) { return iterator(it_--); }
+  iterator operator--(int) { return iterator(it_--, arena_); }
 
   // equality_comparable
   friend bool operator==(const iterator& x, const iterator& y) {
@@ -1699,6 +1937,7 @@ class RepeatedPtrIterator {
 
   // The internal iterator.
   void* const* it_;
+  Arena* arena_;
 };
 
 template <typename Traits, typename = void>
@@ -1712,6 +1951,41 @@ struct IteratorConceptSupport<Traits,
   using tag = typename Traits::iterator_concept;
 };
 
+template <>
+inline const std::string& RepeatedPtrIterator<const std::string>::operator*()
+    const {
+  auto value = reinterpret_cast<const TypeHandler::Type*>(*it_);
+  return *value->ToStringPtr();
+}
+
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+template <>
+inline MaybeArenaStringAccessor RepeatedPtrIterator<std::string>::operator*()
+    const {
+  auto value = reinterpret_cast<TypeHandler::Type*>(*it_);
+  if (value->IsTagged()) {
+    return MaybeArenaStringAccessor(arena_, value->ToStringPtr());
+  }
+  return MaybeArenaStringAccessor(nullptr, value->UnTaggedToStringPtr());
+}
+template <>
+inline MaybeArenaStringAccessor RepeatedPtrIterator<std::string>::operator->()
+    const {
+  return operator*();
+}
+#else   // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+template <>
+inline std::string& RepeatedPtrIterator<std::string>::operator*() const {
+  auto value = reinterpret_cast<TypeHandler::Type*>(*it_);
+  if (value->IsTagged()) {
+    auto string = Arena::Create<std::string>(arena_, *value->ToStringPtr());
+    *const_cast<void**>(it_) = string;
+    return *string;
+  }
+  return *value->UnTaggedToStringPtr();
+}
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+
 // Provides an iterator that operates on pointers to the underlying objects
 // rather than the objects themselves as RepeatedPtrIterator does.
 // Consider using this when working with stl algorithms that change
@@ -1830,12 +2104,12 @@ class RepeatedPtrOverPtrsIterator {
 template <typename Element>
 inline typename RepeatedPtrField<Element>::iterator
 RepeatedPtrField<Element>::begin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return iterator(raw_data());
+  return iterator(raw_data(), GetArena());
 }
 template <typename Element>
 inline typename RepeatedPtrField<Element>::const_iterator
 RepeatedPtrField<Element>::begin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return iterator(raw_data());
+  return iterator(raw_data(), nullptr);
 }
 template <typename Element>
 inline typename RepeatedPtrField<Element>::const_iterator
@@ -1845,12 +2119,12 @@ RepeatedPtrField<Element>::cbegin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
 template <typename Element>
 inline typename RepeatedPtrField<Element>::iterator
 RepeatedPtrField<Element>::end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return iterator(raw_data() + size());
+  return iterator(raw_data() + size(), GetArena());
 }
 template <typename Element>
 inline typename RepeatedPtrField<Element>::const_iterator
 RepeatedPtrField<Element>::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return iterator(raw_data() + size());
+  return iterator(raw_data() + size(), nullptr);
 }
 template <typename Element>
 inline typename RepeatedPtrField<Element>::const_iterator
@@ -1925,6 +2199,27 @@ class RepeatedPtrFieldBackInsertIterator {
  private:
   RepeatedPtrField<T>* field_;
 };
+template <>
+inline RepeatedPtrFieldBackInsertIterator<std::string>&
+RepeatedPtrFieldBackInsertIterator<std::string>::operator=(
+    const std::string& value) {
+  *field_->AddAccessor() = value;
+  return *this;
+}
+template <>
+inline RepeatedPtrFieldBackInsertIterator<std::string>&
+RepeatedPtrFieldBackInsertIterator<std::string>::operator=(
+    const std::string* const ptr_to_value) {
+  *field_->AddAccessor() = *ptr_to_value;
+  return *this;
+}
+template <>
+inline RepeatedPtrFieldBackInsertIterator<std::string>&
+RepeatedPtrFieldBackInsertIterator<std::string>::operator=(
+    std::string&& value) {
+  *field_->AddAccessor() = ::std::move(value);
+  return *this;
+}
 
 // A back inserter for RepeatedPtrFields that inserts by transferring ownership
 // of a pointer.
@@ -1960,8 +2255,9 @@ class AllocatedRepeatedPtrFieldBackInsertIterator {
 template <typename T>
 class UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator {
  public:
+  using TypeHandler = GenericTypeHandler<T>;
   using iterator_category = std::output_iterator_tag;
-  using value_type = T;
+  using value_type = typename TypeHandler::Type;
   using pointer = void;
   using reference = void;
   using difference_type = std::ptrdiff_t;
@@ -1970,8 +2266,8 @@ class UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator {
       RepeatedPtrField<T>* const mutable_field)
       : field_(mutable_field) {}
   UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator<T>& operator=(
-      T const* const ptr_to_value) {
-    field_->UnsafeArenaAddAllocated(const_cast<T*>(ptr_to_value));
+      value_type const* const ptr_to_value) {
+    field_->UnsafeArenaAddAllocated(const_cast<value_type*>(ptr_to_value));
     return *this;
   }
   UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator<T>& operator*() {
@@ -2038,7 +2334,6 @@ UnsafeArenaAllocatedRepeatedPtrFieldBackInserter(
       mutable_field);
 }
 
-
 namespace internal {
 // Size optimization for `memswap<N>` - supplied below N is used by every
 // `RepeatedPtrField<T>`.
diff --git a/src/google/protobuf/source_context.pb.h b/src/google/protobuf/source_context.pb.h
index 2ec4ff97b..735ab28ab 100644
--- a/src/google/protobuf/source_context.pb.h
+++ b/src/google/protobuf/source_context.pb.h
@@ -222,6 +222,7 @@ class PROTOBUF_EXPORT SourceContext final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
       const std::string& value);
   std::string* _internal_mutable_file_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_file_name_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.SourceContext)
@@ -290,7 +291,7 @@ inline PROTOBUF_ALWAYS_INLINE void SourceContext::set_file_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.SourceContext.file_name)
 }
 inline std::string* SourceContext::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_file_name();
+  auto _s = _internal_mutable_file_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.SourceContext.file_name)
   return _s;
 }
@@ -306,10 +307,18 @@ inline std::string* SourceContext::_internal_mutable_file_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.file_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor SourceContext::_internal_mutable_file_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.file_name_.MutableAccessor( GetArena());
+}
 inline std::string* SourceContext::release_file_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.SourceContext.file_name)
-  return _impl_.file_name_.Release();
+  auto* released = _impl_.file_name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.file_name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void SourceContext::set_allocated_file_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
diff --git a/src/google/protobuf/string_view_test.cc b/src/google/protobuf/string_view_test.cc
index d348f1fbe..62f248086 100644
--- a/src/google/protobuf/string_view_test.cc
+++ b/src/google/protobuf/string_view_test.cc
@@ -1,7 +1,6 @@
 #include <string>
 #include <type_traits>
 #include <utility>
-
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
 // clang-format off
@@ -245,7 +244,11 @@ TEST(StringViewFieldTest, RepeatedViewSetter) {
   EXPECT_EQ(message.repeated_string_size(), 3);
   EXPECT_THAT(message.repeated_string(), ElementsAre("000", "111", "222"));
 
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  for (auto it : *message.mutable_repeated_string()) {
+#else   // GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   for (auto& it : *message.mutable_repeated_string()) {
+#endif  // GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
     it.append(it);
   }
 
@@ -288,7 +291,11 @@ TEST(StringViewFieldTest, RepeatedSetAndGetByReflection) {
 
   // MutableRepeatedPtrField().
   PROTOBUF_IGNORE_DEPRECATION_START;
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  for (auto it :
+#else  // GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   for (auto& it :
+#endif // GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
        *reflection->MutableRepeatedPtrField<std::string>(&message, field)) {
     it.append(it);
   }
diff --git a/src/google/protobuf/struct.pb.h b/src/google/protobuf/struct.pb.h
index 162324466..5a0ca83da 100644
--- a/src/google/protobuf/struct.pb.h
+++ b/src/google/protobuf/struct.pb.h
@@ -725,6 +725,7 @@ class PROTOBUF_EXPORT Value final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
       const std::string& value);
   std::string* _internal_mutable_string_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_string_value_accessor();
 
   public:
   // bool bool_value = 4;
@@ -977,7 +978,7 @@ inline PROTOBUF_ALWAYS_INLINE void Value::set_string_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Value.string_value)
 }
 inline std::string* Value::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_string_value();
+  auto _s = _internal_mutable_string_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Value.string_value)
   return _s;
 }
@@ -1008,6 +1009,16 @@ inline std::string* Value::_internal_mutable_string_value() {
   }
   return _impl_.kind_.string_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Value::_internal_mutable_string_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  if (kind_case() != kStringValue) {
+    clear_kind();
+
+    set_has_string_value();
+    _impl_.kind_.string_value_.InitDefault();
+  }
+  return _impl_.kind_.string_value_.MutableAccessor( GetArena());
+}
 inline std::string* Value::release_string_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Value.string_value)
diff --git a/src/google/protobuf/type.pb.h b/src/google/protobuf/type.pb.h
index f44579c89..75736dc2f 100644
--- a/src/google/protobuf/type.pb.h
+++ b/src/google/protobuf/type.pb.h
@@ -357,6 +357,7 @@ class PROTOBUF_EXPORT Option final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // .google.protobuf.Any value = 2;
@@ -649,6 +650,7 @@ class PROTOBUF_EXPORT Field final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string type_url = 6;
@@ -665,6 +667,7 @@ class PROTOBUF_EXPORT Field final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_url(
       const std::string& value);
   std::string* _internal_mutable_type_url();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_type_url_accessor();
 
   public:
   // string json_name = 10;
@@ -681,6 +684,7 @@ class PROTOBUF_EXPORT Field final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_json_name(
       const std::string& value);
   std::string* _internal_mutable_json_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_json_name_accessor();
 
   public:
   // string default_value = 11;
@@ -697,6 +701,7 @@ class PROTOBUF_EXPORT Field final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(
       const std::string& value);
   std::string* _internal_mutable_default_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_default_value_accessor();
 
   public:
   // .google.protobuf.Field.Kind kind = 1;
@@ -967,6 +972,7 @@ class PROTOBUF_EXPORT EnumValue final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // int32 number = 2;
@@ -1233,6 +1239,7 @@ class PROTOBUF_EXPORT Type final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string edition = 7;
@@ -1249,6 +1256,7 @@ class PROTOBUF_EXPORT Type final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_edition(
       const std::string& value);
   std::string* _internal_mutable_edition();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_edition_accessor();
 
   public:
   // .google.protobuf.SourceContext source_context = 5;
@@ -1512,6 +1520,7 @@ class PROTOBUF_EXPORT Enum final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string edition = 6;
@@ -1528,6 +1537,7 @@ class PROTOBUF_EXPORT Enum final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_edition(
       const std::string& value);
   std::string* _internal_mutable_edition();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_edition_accessor();
 
   public:
   // .google.protobuf.SourceContext source_context = 4;
@@ -1627,7 +1637,7 @@ inline PROTOBUF_ALWAYS_INLINE void Type::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Type.name)
 }
 inline std::string* Type::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Type.name)
   return _s;
 }
@@ -1643,10 +1653,18 @@ inline std::string* Type::_internal_mutable_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Type::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Type::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Type.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Type::set_allocated_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -1721,7 +1739,7 @@ inline void Type::clear_oneofs() {
 }
 inline std::string* Type::add_oneofs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
   ::google::protobuf::internal::TSanWrite(&_impl_);
-  std::string* _s = _internal_mutable_oneofs()->Add();
+  auto _s = _internal_mutable_oneofs()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.Type.oneofs)
   return _s;
 }
@@ -1733,12 +1751,12 @@ inline const std::string& Type::oneofs(int index) const
 inline std::string* Type::mutable_oneofs(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.Type.oneofs)
-  return _internal_mutable_oneofs()->Mutable(index);
+  return _internal_mutable_oneofs()->MutableString(index);
 }
 template <typename Arg_, typename... Args_>
 inline void Type::set_oneofs(int index, Arg_&& value, Args_... args) {
   ::google::protobuf::internal::AssignToString(
-      *_internal_mutable_oneofs()->Mutable(index),
+      *_internal_mutable_oneofs()->MutableAccessor(index),
       std::forward<Arg_>(value), args... );
   // @@protoc_insertion_point(field_set:google.protobuf.Type.oneofs)
 }
@@ -1952,7 +1970,7 @@ inline PROTOBUF_ALWAYS_INLINE void Type::set_edition(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Type.edition)
 }
 inline std::string* Type::mutable_edition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_edition();
+  auto _s = _internal_mutable_edition();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Type.edition)
   return _s;
 }
@@ -1968,10 +1986,18 @@ inline std::string* Type::_internal_mutable_edition() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.edition_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Type::_internal_mutable_edition_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.edition_.MutableAccessor( GetArena());
+}
 inline std::string* Type::release_edition() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Type.edition)
-  return _impl_.edition_.Release();
+  auto* released = _impl_.edition_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.edition_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Type::set_allocated_edition(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2072,7 +2098,7 @@ inline PROTOBUF_ALWAYS_INLINE void Field::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Field.name)
 }
 inline std::string* Field::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Field.name)
   return _s;
 }
@@ -2088,10 +2114,18 @@ inline std::string* Field::_internal_mutable_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Field::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Field::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Field.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Field::set_allocated_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2122,7 +2156,7 @@ inline PROTOBUF_ALWAYS_INLINE void Field::set_type_url(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Field.type_url)
 }
 inline std::string* Field::mutable_type_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_type_url();
+  auto _s = _internal_mutable_type_url();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Field.type_url)
   return _s;
 }
@@ -2138,10 +2172,18 @@ inline std::string* Field::_internal_mutable_type_url() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.type_url_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Field::_internal_mutable_type_url_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.type_url_.MutableAccessor( GetArena());
+}
 inline std::string* Field::release_type_url() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Field.type_url)
-  return _impl_.type_url_.Release();
+  auto* released = _impl_.type_url_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.type_url_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Field::set_allocated_type_url(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2265,7 +2307,7 @@ inline PROTOBUF_ALWAYS_INLINE void Field::set_json_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Field.json_name)
 }
 inline std::string* Field::mutable_json_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_json_name();
+  auto _s = _internal_mutable_json_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Field.json_name)
   return _s;
 }
@@ -2281,10 +2323,18 @@ inline std::string* Field::_internal_mutable_json_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.json_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Field::_internal_mutable_json_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.json_name_.MutableAccessor( GetArena());
+}
 inline std::string* Field::release_json_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Field.json_name)
-  return _impl_.json_name_.Release();
+  auto* released = _impl_.json_name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.json_name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Field::set_allocated_json_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2315,7 +2365,7 @@ inline PROTOBUF_ALWAYS_INLINE void Field::set_default_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Field.default_value)
 }
 inline std::string* Field::mutable_default_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_default_value();
+  auto _s = _internal_mutable_default_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Field.default_value)
   return _s;
 }
@@ -2331,10 +2381,18 @@ inline std::string* Field::_internal_mutable_default_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.default_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Field::_internal_mutable_default_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.default_value_.MutableAccessor( GetArena());
+}
 inline std::string* Field::release_default_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Field.default_value)
-  return _impl_.default_value_.Release();
+  auto* released = _impl_.default_value_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.default_value_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Field::set_allocated_default_value(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2369,7 +2427,7 @@ inline PROTOBUF_ALWAYS_INLINE void Enum::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Enum.name)
 }
 inline std::string* Enum::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Enum.name)
   return _s;
 }
@@ -2385,10 +2443,18 @@ inline std::string* Enum::_internal_mutable_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Enum::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Enum::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Enum.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Enum::set_allocated_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2630,7 +2696,7 @@ inline PROTOBUF_ALWAYS_INLINE void Enum::set_edition(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Enum.edition)
 }
 inline std::string* Enum::mutable_edition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_edition();
+  auto _s = _internal_mutable_edition();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Enum.edition)
   return _s;
 }
@@ -2646,10 +2712,18 @@ inline std::string* Enum::_internal_mutable_edition() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.edition_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Enum::_internal_mutable_edition_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.edition_.MutableAccessor( GetArena());
+}
 inline std::string* Enum::release_edition() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Enum.edition)
-  return _impl_.edition_.Release();
+  auto* released = _impl_.edition_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.edition_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Enum::set_allocated_edition(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2684,7 +2758,7 @@ inline PROTOBUF_ALWAYS_INLINE void EnumValue::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.EnumValue.name)
 }
 inline std::string* EnumValue::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.EnumValue.name)
   return _s;
 }
@@ -2700,10 +2774,18 @@ inline std::string* EnumValue::_internal_mutable_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor EnumValue::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* EnumValue::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.EnumValue.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void EnumValue::set_allocated_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2809,7 +2891,7 @@ inline PROTOBUF_ALWAYS_INLINE void Option::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Option.name)
 }
 inline std::string* Option::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Option.name)
   return _s;
 }
@@ -2825,10 +2907,18 @@ inline std::string* Option::_internal_mutable_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Option::_internal_mutable_name_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Option::release_name() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.Option.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Option::set_allocated_name(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
diff --git a/src/google/protobuf/unittest_arenastring.proto b/src/google/protobuf/unittest_arenastring.proto
new file mode 100644
index 000000000..f1695f2d2
--- /dev/null
+++ b/src/google/protobuf/unittest_arenastring.proto
@@ -0,0 +1,35 @@
+syntax = "proto2";
+
+package proto2_arenastring_unittest;
+
+option cc_mutable_donated_string = false;
+
+message Proto2 {
+  optional string s = 1;
+  optional bytes b = 2;
+  optional bytes c = 3 [ctype = CORD];
+  required string qs = 4;
+  required bytes qb = 5;
+  required bytes qc = 6 [ctype = CORD];
+  optional string ds = 7 [default = "10086"];
+  optional bytes db = 8 [default = "10010"];
+  optional bytes dc = 9 [default = "10010", ctype = CORD];
+  repeated string rs = 10;
+  repeated bytes rb = 11;
+  oneof o {
+    string ons = 12;
+    bytes onb = 13;
+    bytes onc = 14 [ctype = CORD];
+  }
+  map<string, string> ms = 15;
+  extensions 100 to 199;
+};
+
+message Proto2Extension {
+  extend Proto2 {
+    optional string es = 100;
+    optional bytes eb = 101;
+    repeated string ers = 102;
+    repeated bytes erb = 103;
+  };
+};
diff --git a/src/google/protobuf/unittest_arenastring_mutable.proto b/src/google/protobuf/unittest_arenastring_mutable.proto
new file mode 100644
index 000000000..1722559b3
--- /dev/null
+++ b/src/google/protobuf/unittest_arenastring_mutable.proto
@@ -0,0 +1,35 @@
+syntax = "proto2";
+
+package proto2_arenastring_unittest;
+
+option cc_mutable_donated_string = true;
+
+message ArenaProto2 {
+  optional string s = 1;
+  optional bytes b = 2;
+  optional bytes c = 3 [ctype = CORD];
+  required string qs = 4;
+  required bytes qb = 5;
+  required bytes qc = 6 [ctype = CORD];
+  optional string ds = 7 [default = "10086"];
+  optional bytes db = 8 [default = "10010"];
+  optional bytes dc = 9 [default = "10010", ctype = CORD];
+  repeated string rs = 10;
+  repeated bytes rb = 11;
+  oneof o {
+    string ons = 12;
+    bytes onb = 13;
+    bytes onc = 14 [ctype = CORD];
+  }
+  map<string, string> ms = 15;
+  extensions 100 to 199;
+};
+
+message ArenaProto2Extension {
+  extend ArenaProto2 {
+    optional string es = 100;
+    optional bytes eb = 101;
+    repeated string ers = 102;
+    repeated bytes erb = 103;
+  };
+};
diff --git a/src/google/protobuf/unittest_proto3_arenastring.proto b/src/google/protobuf/unittest_proto3_arenastring.proto
new file mode 100644
index 000000000..56cbe0a26
--- /dev/null
+++ b/src/google/protobuf/unittest_proto3_arenastring.proto
@@ -0,0 +1,23 @@
+syntax = "proto3";
+
+package proto3_arenastring_unittest;
+
+option cc_mutable_donated_string = false;
+
+message Proto3 {
+  string s = 1;
+  bytes b = 2;
+  bytes c = 3 [ctype = CORD];
+  optional string os = 4;
+  optional bytes ob = 5;
+  optional bytes oc = 6 [ctype = CORD];
+  repeated string rs = 7;
+  repeated bytes rb = 8;
+  repeated bytes rc = 9 [ctype = CORD];
+  oneof o {
+    string ons = 10;
+    bytes onb = 11;
+    bytes onc = 12 [ctype = CORD];
+  }
+  map<string, string> ms = 13;
+};
diff --git a/src/google/protobuf/unittest_proto3_arenastring_mutable.proto b/src/google/protobuf/unittest_proto3_arenastring_mutable.proto
new file mode 100644
index 000000000..de3341685
--- /dev/null
+++ b/src/google/protobuf/unittest_proto3_arenastring_mutable.proto
@@ -0,0 +1,23 @@
+syntax = "proto3";
+
+package proto3_arenastring_unittest;
+
+option cc_mutable_donated_string = true;
+
+message ArenaProto3 {
+  string s = 1;
+  bytes b = 2;
+  // bytes c = 3 [ctype = CORD];
+  optional string os = 4;
+  optional bytes ob = 5;
+  // optional bytes oc = 6 [ctype = CORD];
+  repeated string rs = 7;
+  repeated bytes rb = 8;
+  // repeated bytes rc = 9 [ctype = CORD];
+  oneof o {
+    string ons = 10;
+    bytes onb = 11;
+    // bytes onc = 12 [ctype = CORD];
+  }
+  map<string, string> ms = 13;
+};
diff --git a/src/google/protobuf/wrappers.pb.h b/src/google/protobuf/wrappers.pb.h
index 5396021ca..f024a1ca3 100644
--- a/src/google/protobuf/wrappers.pb.h
+++ b/src/google/protobuf/wrappers.pb.h
@@ -618,6 +618,7 @@ class PROTOBUF_EXPORT StringValue final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
       const std::string& value);
   std::string* _internal_mutable_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_value_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.StringValue)
@@ -1554,6 +1555,7 @@ class PROTOBUF_EXPORT BytesValue final : public ::google::protobuf::Message
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
       const std::string& value);
   std::string* _internal_mutable_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_value_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.BytesValue)
@@ -1990,7 +1992,7 @@ inline PROTOBUF_ALWAYS_INLINE void StringValue::set_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.StringValue.value)
 }
 inline std::string* StringValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_value();
+  auto _s = _internal_mutable_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.StringValue.value)
   return _s;
 }
@@ -2006,10 +2008,18 @@ inline std::string* StringValue::_internal_mutable_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor StringValue::_internal_mutable_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.value_.MutableAccessor( GetArena());
+}
 inline std::string* StringValue::release_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.StringValue.value)
-  return _impl_.value_.Release();
+  auto* released = _impl_.value_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.value_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void StringValue::set_allocated_value(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
@@ -2044,7 +2054,7 @@ inline PROTOBUF_ALWAYS_INLINE void BytesValue::set_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.BytesValue.value)
 }
 inline std::string* BytesValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_value();
+  auto _s = _internal_mutable_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.BytesValue.value)
   return _s;
 }
@@ -2060,10 +2070,18 @@ inline std::string* BytesValue::_internal_mutable_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   return _impl_.value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor BytesValue::_internal_mutable_value_accessor() {
+  ::google::protobuf::internal::TSanWrite(&_impl_);
+  return _impl_.value_.MutableAccessor( GetArena());
+}
 inline std::string* BytesValue::release_value() {
   ::google::protobuf::internal::TSanWrite(&_impl_);
   // @@protoc_insertion_point(field_release:google.protobuf.BytesValue.value)
-  return _impl_.value_.Release();
+  auto* released = _impl_.value_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.value_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void BytesValue::set_allocated_value(std::string* value) {
   ::google::protobuf::internal::TSanWrite(&_impl_);
diff --git a/third_party/rules_ruby.patch b/third_party/rules_ruby.patch
new file mode 100644
index 000000000..886ca1c67
--- /dev/null
+++ b/third_party/rules_ruby.patch
@@ -0,0 +1,13 @@
+diff --git a/MODULE.bazel b/MODULE.bazel
+new file mode 100644
+index 0000000..746f414
+--- /dev/null
++++ b/MODULE.bazel
+@@ -0,0 +1,7 @@
++module(
++  name = "rules_ruby",
++)
++
++bazel_dep(name = "bazel_skylib", version = "1.3.0")
++bazel_dep(name = "platforms", version = "0.0.5")
++bazel_dep(name = "rules_pkg", version = "0.7.0")
