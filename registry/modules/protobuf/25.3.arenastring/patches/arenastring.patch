diff --git a/csharp/src/Google.Protobuf.Test/testprotos.pb b/csharp/src/Google.Protobuf.Test/testprotos.pb
index 9527755cf..a703ce140 100644
Binary files a/csharp/src/Google.Protobuf.Test/testprotos.pb and b/csharp/src/Google.Protobuf.Test/testprotos.pb differ
diff --git a/csharp/src/Google.Protobuf/Reflection/Descriptor.pb.cs b/csharp/src/Google.Protobuf/Reflection/Descriptor.pb.cs
index 2421d98c0..d1f6e72ce 100644
--- a/csharp/src/Google.Protobuf/Reflection/Descriptor.pb.cs
+++ b/csharp/src/Google.Protobuf/Reflection/Descriptor.pb.cs
@@ -99,7 +99,7 @@ namespace Google.Protobuf.Reflection {
             "CgtvdXRwdXRfdHlwZRgDIAEoCRIvCgdvcHRpb25zGAQgASgLMh4uZ29vZ2xl",
             "LnByb3RvYnVmLk1ldGhvZE9wdGlvbnMSHwoQY2xpZW50X3N0cmVhbWluZxgF",
             "IAEoCDoFZmFsc2USHwoQc2VydmVyX3N0cmVhbWluZxgGIAEoCDoFZmFsc2Ui",
-            "1AYKC0ZpbGVPcHRpb25zEhQKDGphdmFfcGFja2FnZRgBIAEoCRIcChRqYXZh",
+            "/gYKC0ZpbGVPcHRpb25zEhQKDGphdmFfcGFja2FnZRgBIAEoCRIcChRqYXZh",
             "X291dGVyX2NsYXNzbmFtZRgIIAEoCRIiChNqYXZhX211bHRpcGxlX2ZpbGVz",
             "GAogASgIOgVmYWxzZRIpCh1qYXZhX2dlbmVyYXRlX2VxdWFsc19hbmRfaGFz",
             "aBgUIAEoCEICGAESJQoWamF2YV9zdHJpbmdfY2hlY2tfdXRmOBgbIAEoCDoF",
@@ -109,134 +109,135 @@ namespace Google.Protobuf.Reflection {
             "ChVqYXZhX2dlbmVyaWNfc2VydmljZXMYESABKAg6BWZhbHNlEiIKE3B5X2dl",
             "bmVyaWNfc2VydmljZXMYEiABKAg6BWZhbHNlEiMKFHBocF9nZW5lcmljX3Nl",
             "cnZpY2VzGCogASgIOgVmYWxzZRIZCgpkZXByZWNhdGVkGBcgASgIOgVmYWxz",
-            "ZRIeChBjY19lbmFibGVfYXJlbmFzGB8gASgIOgR0cnVlEhkKEW9iamNfY2xh",
-            "c3NfcHJlZml4GCQgASgJEhgKEGNzaGFycF9uYW1lc3BhY2UYJSABKAkSFAoM",
-            "c3dpZnRfcHJlZml4GCcgASgJEhgKEHBocF9jbGFzc19wcmVmaXgYKCABKAkS",
-            "FQoNcGhwX25hbWVzcGFjZRgpIAEoCRIeChZwaHBfbWV0YWRhdGFfbmFtZXNw",
-            "YWNlGCwgASgJEhQKDHJ1YnlfcGFja2FnZRgtIAEoCRItCghmZWF0dXJlcxgy",
+            "ZRIeChBjY19lbmFibGVfYXJlbmFzGB8gASgIOgR0cnVlEigKGWNjX211dGFi",
+            "bGVfZG9uYXRlZF9zdHJpbmcYICABKAg6BWZhbHNlEhkKEW9iamNfY2xhc3Nf",
+            "cHJlZml4GCQgASgJEhgKEGNzaGFycF9uYW1lc3BhY2UYJSABKAkSFAoMc3dp",
+            "ZnRfcHJlZml4GCcgASgJEhgKEHBocF9jbGFzc19wcmVmaXgYKCABKAkSFQoN",
+            "cGhwX25hbWVzcGFjZRgpIAEoCRIeChZwaHBfbWV0YWRhdGFfbmFtZXNwYWNl",
+            "GCwgASgJEhQKDHJ1YnlfcGFja2FnZRgtIAEoCRItCghmZWF0dXJlcxgyIAEo",
+            "CzIbLmdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0EkMKFHVuaW50ZXJwcmV0",
+            "ZWRfb3B0aW9uGOcHIAMoCzIkLmdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJl",
+            "dGVkT3B0aW9uIjoKDE9wdGltaXplTW9kZRIJCgVTUEVFRBABEg0KCUNPREVf",
+            "U0laRRACEhAKDExJVEVfUlVOVElNRRADKgkI6AcQgICAgAJKBAgmECci5wIK",
+            "Dk1lc3NhZ2VPcHRpb25zEiYKF21lc3NhZ2Vfc2V0X3dpcmVfZm9ybWF0GAEg",
+            "ASgIOgVmYWxzZRIuCh9ub19zdGFuZGFyZF9kZXNjcmlwdG9yX2FjY2Vzc29y",
+            "GAIgASgIOgVmYWxzZRIZCgpkZXByZWNhdGVkGAMgASgIOgVmYWxzZRIRCglt",
+            "YXBfZW50cnkYByABKAgSMgomZGVwcmVjYXRlZF9sZWdhY3lfanNvbl9maWVs",
+            "ZF9jb25mbGljdHMYCyABKAhCAhgBEi0KCGZlYXR1cmVzGAwgASgLMhsuZ29v",
+            "Z2xlLnByb3RvYnVmLkZlYXR1cmVTZXQSQwoUdW5pbnRlcnByZXRlZF9vcHRp",
+            "b24Y5wcgAygLMiQuZ29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRp",
+            "b24qCQjoBxCAgICAAkoECAQQBUoECAUQBkoECAYQB0oECAgQCUoECAkQCiKN",
+            "CQoMRmllbGRPcHRpb25zEjoKBWN0eXBlGAEgASgOMiMuZ29vZ2xlLnByb3Rv",
+            "YnVmLkZpZWxkT3B0aW9ucy5DVHlwZToGU1RSSU5HEg4KBnBhY2tlZBgCIAEo",
+            "CBI/CgZqc3R5cGUYBiABKA4yJC5nb29nbGUucHJvdG9idWYuRmllbGRPcHRp",
+            "b25zLkpTVHlwZToJSlNfTk9STUFMEhMKBGxhenkYBSABKAg6BWZhbHNlEh4K",
+            "D3VudmVyaWZpZWRfbGF6eRgPIAEoCDoFZmFsc2USGQoKZGVwcmVjYXRlZBgD",
+            "IAEoCDoFZmFsc2USEwoEd2VhaxgKIAEoCDoFZmFsc2USGwoMZGVidWdfcmVk",
+            "YWN0GBAgASgIOgVmYWxzZRJACglyZXRlbnRpb24YESABKA4yLS5nb29nbGUu",
+            "cHJvdG9idWYuRmllbGRPcHRpb25zLk9wdGlvblJldGVudGlvbhI/Cgd0YXJn",
+            "ZXRzGBMgAygOMi4uZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5PcHRp",
+            "b25UYXJnZXRUeXBlEkYKEGVkaXRpb25fZGVmYXVsdHMYFCADKAsyLC5nb29n",
+            "bGUucHJvdG9idWYuRmllbGRPcHRpb25zLkVkaXRpb25EZWZhdWx0Ei0KCGZl",
+            "YXR1cmVzGBUgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQSQwoU",
+            "dW5pbnRlcnByZXRlZF9vcHRpb24Y5wcgAygLMiQuZ29vZ2xlLnByb3RvYnVm",
+            "LlVuaW50ZXJwcmV0ZWRPcHRpb24aSgoORWRpdGlvbkRlZmF1bHQSKQoHZWRp",
+            "dGlvbhgDIAEoDjIYLmdvb2dsZS5wcm90b2J1Zi5FZGl0aW9uEg0KBXZhbHVl",
+            "GAIgASgJIi8KBUNUeXBlEgoKBlNUUklORxAAEggKBENPUkQQARIQCgxTVFJJ",
+            "TkdfUElFQ0UQAiI1CgZKU1R5cGUSDQoJSlNfTk9STUFMEAASDQoJSlNfU1RS",
+            "SU5HEAESDQoJSlNfTlVNQkVSEAIiVQoPT3B0aW9uUmV0ZW50aW9uEhUKEVJF",
+            "VEVOVElPTl9VTktOT1dOEAASFQoRUkVURU5USU9OX1JVTlRJTUUQARIUChBS",
+            "RVRFTlRJT05fU09VUkNFEAIijAIKEE9wdGlvblRhcmdldFR5cGUSFwoTVEFS",
+            "R0VUX1RZUEVfVU5LTk9XThAAEhQKEFRBUkdFVF9UWVBFX0ZJTEUQARIfChtU",
+            "QVJHRVRfVFlQRV9FWFRFTlNJT05fUkFOR0UQAhIXChNUQVJHRVRfVFlQRV9N",
+            "RVNTQUdFEAMSFQoRVEFSR0VUX1RZUEVfRklFTEQQBBIVChFUQVJHRVRfVFlQ",
+            "RV9PTkVPRhAFEhQKEFRBUkdFVF9UWVBFX0VOVU0QBhIaChZUQVJHRVRfVFlQ",
+            "RV9FTlVNX0VOVFJZEAcSFwoTVEFSR0VUX1RZUEVfU0VSVklDRRAIEhYKElRB",
+            "UkdFVF9UWVBFX01FVEhPRBAJKgkI6AcQgICAgAJKBAgEEAVKBAgSEBMijQEK",
+            "DE9uZW9mT3B0aW9ucxItCghmZWF0dXJlcxgBIAEoCzIbLmdvb2dsZS5wcm90",
+            "b2J1Zi5GZWF0dXJlU2V0EkMKFHVuaW50ZXJwcmV0ZWRfb3B0aW9uGOcHIAMo",
+            "CzIkLmdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJldGVkT3B0aW9uKgkI6AcQ",
+            "gICAgAIi9gEKC0VudW1PcHRpb25zEhMKC2FsbG93X2FsaWFzGAIgASgIEhkK",
+            "CmRlcHJlY2F0ZWQYAyABKAg6BWZhbHNlEjIKJmRlcHJlY2F0ZWRfbGVnYWN5",
+            "X2pzb25fZmllbGRfY29uZmxpY3RzGAYgASgIQgIYARItCghmZWF0dXJlcxgH",
             "IAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0EkMKFHVuaW50ZXJw",
             "cmV0ZWRfb3B0aW9uGOcHIAMoCzIkLmdvb2dsZS5wcm90b2J1Zi5VbmludGVy",
-            "cHJldGVkT3B0aW9uIjoKDE9wdGltaXplTW9kZRIJCgVTUEVFRBABEg0KCUNP",
-            "REVfU0laRRACEhAKDExJVEVfUlVOVElNRRADKgkI6AcQgICAgAJKBAgmECci",
-            "5wIKDk1lc3NhZ2VPcHRpb25zEiYKF21lc3NhZ2Vfc2V0X3dpcmVfZm9ybWF0",
-            "GAEgASgIOgVmYWxzZRIuCh9ub19zdGFuZGFyZF9kZXNjcmlwdG9yX2FjY2Vz",
-            "c29yGAIgASgIOgVmYWxzZRIZCgpkZXByZWNhdGVkGAMgASgIOgVmYWxzZRIR",
-            "CgltYXBfZW50cnkYByABKAgSMgomZGVwcmVjYXRlZF9sZWdhY3lfanNvbl9m",
-            "aWVsZF9jb25mbGljdHMYCyABKAhCAhgBEi0KCGZlYXR1cmVzGAwgASgLMhsu",
-            "Z29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQSQwoUdW5pbnRlcnByZXRlZF9v",
-            "cHRpb24Y5wcgAygLMiQuZ29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRP",
-            "cHRpb24qCQjoBxCAgICAAkoECAQQBUoECAUQBkoECAYQB0oECAgQCUoECAkQ",
-            "CiKNCQoMRmllbGRPcHRpb25zEjoKBWN0eXBlGAEgASgOMiMuZ29vZ2xlLnBy",
-            "b3RvYnVmLkZpZWxkT3B0aW9ucy5DVHlwZToGU1RSSU5HEg4KBnBhY2tlZBgC",
-            "IAEoCBI/CgZqc3R5cGUYBiABKA4yJC5nb29nbGUucHJvdG9idWYuRmllbGRP",
-            "cHRpb25zLkpTVHlwZToJSlNfTk9STUFMEhMKBGxhenkYBSABKAg6BWZhbHNl",
-            "Eh4KD3VudmVyaWZpZWRfbGF6eRgPIAEoCDoFZmFsc2USGQoKZGVwcmVjYXRl",
-            "ZBgDIAEoCDoFZmFsc2USEwoEd2VhaxgKIAEoCDoFZmFsc2USGwoMZGVidWdf",
-            "cmVkYWN0GBAgASgIOgVmYWxzZRJACglyZXRlbnRpb24YESABKA4yLS5nb29n",
-            "bGUucHJvdG9idWYuRmllbGRPcHRpb25zLk9wdGlvblJldGVudGlvbhI/Cgd0",
-            "YXJnZXRzGBMgAygOMi4uZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5P",
-            "cHRpb25UYXJnZXRUeXBlEkYKEGVkaXRpb25fZGVmYXVsdHMYFCADKAsyLC5n",
-            "b29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkVkaXRpb25EZWZhdWx0Ei0K",
-            "CGZlYXR1cmVzGBUgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQS",
-            "QwoUdW5pbnRlcnByZXRlZF9vcHRpb24Y5wcgAygLMiQuZ29vZ2xlLnByb3Rv",
-            "YnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24aSgoORWRpdGlvbkRlZmF1bHQSKQoH",
-            "ZWRpdGlvbhgDIAEoDjIYLmdvb2dsZS5wcm90b2J1Zi5FZGl0aW9uEg0KBXZh",
-            "bHVlGAIgASgJIi8KBUNUeXBlEgoKBlNUUklORxAAEggKBENPUkQQARIQCgxT",
-            "VFJJTkdfUElFQ0UQAiI1CgZKU1R5cGUSDQoJSlNfTk9STUFMEAASDQoJSlNf",
-            "U1RSSU5HEAESDQoJSlNfTlVNQkVSEAIiVQoPT3B0aW9uUmV0ZW50aW9uEhUK",
-            "EVJFVEVOVElPTl9VTktOT1dOEAASFQoRUkVURU5USU9OX1JVTlRJTUUQARIU",
-            "ChBSRVRFTlRJT05fU09VUkNFEAIijAIKEE9wdGlvblRhcmdldFR5cGUSFwoT",
-            "VEFSR0VUX1RZUEVfVU5LTk9XThAAEhQKEFRBUkdFVF9UWVBFX0ZJTEUQARIf",
-            "ChtUQVJHRVRfVFlQRV9FWFRFTlNJT05fUkFOR0UQAhIXChNUQVJHRVRfVFlQ",
-            "RV9NRVNTQUdFEAMSFQoRVEFSR0VUX1RZUEVfRklFTEQQBBIVChFUQVJHRVRf",
-            "VFlQRV9PTkVPRhAFEhQKEFRBUkdFVF9UWVBFX0VOVU0QBhIaChZUQVJHRVRf",
-            "VFlQRV9FTlVNX0VOVFJZEAcSFwoTVEFSR0VUX1RZUEVfU0VSVklDRRAIEhYK",
-            "ElRBUkdFVF9UWVBFX01FVEhPRBAJKgkI6AcQgICAgAJKBAgEEAVKBAgSEBMi",
-            "jQEKDE9uZW9mT3B0aW9ucxItCghmZWF0dXJlcxgBIAEoCzIbLmdvb2dsZS5w",
-            "cm90b2J1Zi5GZWF0dXJlU2V0EkMKFHVuaW50ZXJwcmV0ZWRfb3B0aW9uGOcH",
+            "cHJldGVkT3B0aW9uKgkI6AcQgICAgAJKBAgFEAYiyQEKEEVudW1WYWx1ZU9w",
+            "dGlvbnMSGQoKZGVwcmVjYXRlZBgBIAEoCDoFZmFsc2USLQoIZmVhdHVyZXMY",
+            "AiABKAsyGy5nb29nbGUucHJvdG9idWYuRmVhdHVyZVNldBIbCgxkZWJ1Z19y",
+            "ZWRhY3QYAyABKAg6BWZhbHNlEkMKFHVuaW50ZXJwcmV0ZWRfb3B0aW9uGOcH",
             "IAMoCzIkLmdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJldGVkT3B0aW9uKgkI",
-            "6AcQgICAgAIi9gEKC0VudW1PcHRpb25zEhMKC2FsbG93X2FsaWFzGAIgASgI",
-            "EhkKCmRlcHJlY2F0ZWQYAyABKAg6BWZhbHNlEjIKJmRlcHJlY2F0ZWRfbGVn",
-            "YWN5X2pzb25fZmllbGRfY29uZmxpY3RzGAYgASgIQgIYARItCghmZWF0dXJl",
-            "cxgHIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0EkMKFHVuaW50",
-            "ZXJwcmV0ZWRfb3B0aW9uGOcHIAMoCzIkLmdvb2dsZS5wcm90b2J1Zi5Vbmlu",
-            "dGVycHJldGVkT3B0aW9uKgkI6AcQgICAgAJKBAgFEAYiyQEKEEVudW1WYWx1",
-            "ZU9wdGlvbnMSGQoKZGVwcmVjYXRlZBgBIAEoCDoFZmFsc2USLQoIZmVhdHVy",
-            "ZXMYAiABKAsyGy5nb29nbGUucHJvdG9idWYuRmVhdHVyZVNldBIbCgxkZWJ1",
-            "Z19yZWRhY3QYAyABKAg6BWZhbHNlEkMKFHVuaW50ZXJwcmV0ZWRfb3B0aW9u",
-            "GOcHIAMoCzIkLmdvb2dsZS5wcm90b2J1Zi5VbmludGVycHJldGVkT3B0aW9u",
-            "KgkI6AcQgICAgAIiqgEKDlNlcnZpY2VPcHRpb25zEi0KCGZlYXR1cmVzGCIg",
-            "ASgLMhsuZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQSGQoKZGVwcmVjYXRl",
-            "ZBghIAEoCDoFZmFsc2USQwoUdW5pbnRlcnByZXRlZF9vcHRpb24Y5wcgAygL",
-            "MiQuZ29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24qCQjoBxCA",
-            "gICAAiLcAgoNTWV0aG9kT3B0aW9ucxIZCgpkZXByZWNhdGVkGCEgASgIOgVm",
-            "YWxzZRJfChFpZGVtcG90ZW5jeV9sZXZlbBgiIAEoDjIvLmdvb2dsZS5wcm90",
-            "b2J1Zi5NZXRob2RPcHRpb25zLklkZW1wb3RlbmN5TGV2ZWw6E0lERU1QT1RF",
-            "TkNZX1VOS05PV04SLQoIZmVhdHVyZXMYIyABKAsyGy5nb29nbGUucHJvdG9i",
-            "dWYuRmVhdHVyZVNldBJDChR1bmludGVycHJldGVkX29wdGlvbhjnByADKAsy",
-            "JC5nb29nbGUucHJvdG9idWYuVW5pbnRlcnByZXRlZE9wdGlvbiJQChBJZGVt",
-            "cG90ZW5jeUxldmVsEhcKE0lERU1QT1RFTkNZX1VOS05PV04QABITCg9OT19T",
-            "SURFX0VGRkVDVFMQARIOCgpJREVNUE9URU5UEAIqCQjoBxCAgICAAiKeAgoT",
-            "VW5pbnRlcnByZXRlZE9wdGlvbhI7CgRuYW1lGAIgAygLMi0uZ29vZ2xlLnBy",
-            "b3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24uTmFtZVBhcnQSGAoQaWRlbnRp",
-            "Zmllcl92YWx1ZRgDIAEoCRIaChJwb3NpdGl2ZV9pbnRfdmFsdWUYBCABKAQS",
-            "GgoSbmVnYXRpdmVfaW50X3ZhbHVlGAUgASgDEhQKDGRvdWJsZV92YWx1ZRgG",
-            "IAEoARIUCgxzdHJpbmdfdmFsdWUYByABKAwSFwoPYWdncmVnYXRlX3ZhbHVl",
-            "GAggASgJGjMKCE5hbWVQYXJ0EhEKCW5hbWVfcGFydBgBIAIoCRIUCgxpc19l",
-            "eHRlbnNpb24YAiACKAginQkKCkZlYXR1cmVTZXQSfAoOZmllbGRfcHJlc2Vu",
-            "Y2UYASABKA4yKS5nb29nbGUucHJvdG9idWYuRmVhdHVyZVNldC5GaWVsZFBy",
-            "ZXNlbmNlQjmIAQGYAQSYAQGiAQ0SCEVYUExJQ0lUGOYHogENEghJTVBMSUNJ",
-            "VBjnB6IBDRIIRVhQTElDSVQY6AcSXAoJZW51bV90eXBlGAIgASgOMiQuZ29v",
-            "Z2xlLnByb3RvYnVmLkZlYXR1cmVTZXQuRW51bVR5cGVCI4gBAZgBBpgBAaIB",
-            "CxIGQ0xPU0VEGOYHogEJEgRPUEVOGOcHEnsKF3JlcGVhdGVkX2ZpZWxkX2Vu",
-            "Y29kaW5nGAMgASgOMjEuZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQuUmVw",
-            "ZWF0ZWRGaWVsZEVuY29kaW5nQieIAQGYAQSYAQGiAQ0SCEVYUEFOREVEGOYH",
-            "ogELEgZQQUNLRUQY5wcSaAoPdXRmOF92YWxpZGF0aW9uGAQgASgOMiouZ29v",
-            "Z2xlLnByb3RvYnVmLkZlYXR1cmVTZXQuVXRmOFZhbGlkYXRpb25CI4gBAZgB",
-            "BJgBAaIBCRIETk9ORRjmB6IBCxIGVkVSSUZZGOcHEmcKEG1lc3NhZ2VfZW5j",
-            "b2RpbmcYBSABKA4yKy5nb29nbGUucHJvdG9idWYuRmVhdHVyZVNldC5NZXNz",
-            "YWdlRW5jb2RpbmdCIIgBAZgBBJgBAaIBFBIPTEVOR1RIX1BSRUZJWEVEGOYH",
-            "EnAKC2pzb25fZm9ybWF0GAYgASgOMiYuZ29vZ2xlLnByb3RvYnVmLkZlYXR1",
-            "cmVTZXQuSnNvbkZvcm1hdEIziAEBmAEDmAEGmAEBogEXEhJMRUdBQ1lfQkVT",
-            "VF9FRkZPUlQY5geiAQoSBUFMTE9XGOcHIlwKDUZpZWxkUHJlc2VuY2USGgoW",
-            "RklFTERfUFJFU0VOQ0VfVU5LTk9XThAAEgwKCEVYUExJQ0lUEAESDAoISU1Q",
-            "TElDSVQQAhITCg9MRUdBQ1lfUkVRVUlSRUQQAyI3CghFbnVtVHlwZRIVChFF",
-            "TlVNX1RZUEVfVU5LTk9XThAAEggKBE9QRU4QARIKCgZDTE9TRUQQAiJWChVS",
-            "ZXBlYXRlZEZpZWxkRW5jb2RpbmcSIwofUkVQRUFURURfRklFTERfRU5DT0RJ",
-            "TkdfVU5LTk9XThAAEgoKBlBBQ0tFRBABEgwKCEVYUEFOREVEEAIiQwoOVXRm",
-            "OFZhbGlkYXRpb24SGwoXVVRGOF9WQUxJREFUSU9OX1VOS05PV04QABIICgRO",
-            "T05FEAESCgoGVkVSSUZZEAIiUwoPTWVzc2FnZUVuY29kaW5nEhwKGE1FU1NB",
-            "R0VfRU5DT0RJTkdfVU5LTk9XThAAEhMKD0xFTkdUSF9QUkVGSVhFRBABEg0K",
-            "CURFTElNSVRFRBACIkgKCkpzb25Gb3JtYXQSFwoTSlNPTl9GT1JNQVRfVU5L",
-            "Tk9XThAAEgkKBUFMTE9XEAESFgoSTEVHQUNZX0JFU1RfRUZGT1JUEAIqBgjo",
-            "BxDpByoGCOkHEOoHKgYIi04QkE5KBgjnBxDoByLAAgoSRmVhdHVyZVNldERl",
-            "ZmF1bHRzEk4KCGRlZmF1bHRzGAEgAygLMjwuZ29vZ2xlLnByb3RvYnVmLkZl",
-            "YXR1cmVTZXREZWZhdWx0cy5GZWF0dXJlU2V0RWRpdGlvbkRlZmF1bHQSMQoP",
-            "bWluaW11bV9lZGl0aW9uGAQgASgOMhguZ29vZ2xlLnByb3RvYnVmLkVkaXRp",
-            "b24SMQoPbWF4aW11bV9lZGl0aW9uGAUgASgOMhguZ29vZ2xlLnByb3RvYnVm",
-            "LkVkaXRpb24adAoYRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0EikKB2VkaXRp",
-            "b24YAyABKA4yGC5nb29nbGUucHJvdG9idWYuRWRpdGlvbhItCghmZWF0dXJl",
-            "cxgCIAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0ItUBCg5Tb3Vy",
-            "Y2VDb2RlSW5mbxI6Cghsb2NhdGlvbhgBIAMoCzIoLmdvb2dsZS5wcm90b2J1",
-            "Zi5Tb3VyY2VDb2RlSW5mby5Mb2NhdGlvbhqGAQoITG9jYXRpb24SEAoEcGF0",
-            "aBgBIAMoBUICEAESEAoEc3BhbhgCIAMoBUICEAESGAoQbGVhZGluZ19jb21t",
-            "ZW50cxgDIAEoCRIZChF0cmFpbGluZ19jb21tZW50cxgEIAEoCRIhChlsZWFk",
-            "aW5nX2RldGFjaGVkX2NvbW1lbnRzGAYgAygJIpwCChFHZW5lcmF0ZWRDb2Rl",
-            "SW5mbxJBCgphbm5vdGF0aW9uGAEgAygLMi0uZ29vZ2xlLnByb3RvYnVmLkdl",
-            "bmVyYXRlZENvZGVJbmZvLkFubm90YXRpb24awwEKCkFubm90YXRpb24SEAoE",
-            "cGF0aBgBIAMoBUICEAESEwoLc291cmNlX2ZpbGUYAiABKAkSDQoFYmVnaW4Y",
-            "AyABKAUSCwoDZW5kGAQgASgFEkgKCHNlbWFudGljGAUgASgOMjYuZ29vZ2xl",
-            "LnByb3RvYnVmLkdlbmVyYXRlZENvZGVJbmZvLkFubm90YXRpb24uU2VtYW50",
-            "aWMiKAoIU2VtYW50aWMSCAoETk9ORRAAEgcKA1NFVBABEgkKBUFMSUFTEAIq",
-            "6gEKB0VkaXRpb24SEwoPRURJVElPTl9VTktOT1dOEAASEwoORURJVElPTl9Q",
-            "Uk9UTzIQ5gcSEwoORURJVElPTl9QUk9UTzMQ5wcSEQoMRURJVElPTl8yMDIz",
-            "EOgHEhcKE0VESVRJT05fMV9URVNUX09OTFkQARIXChNFRElUSU9OXzJfVEVT",
-            "VF9PTkxZEAISHQoXRURJVElPTl85OTk5N19URVNUX09OTFkQnY0GEh0KF0VE",
-            "SVRJT05fOTk5OThfVEVTVF9PTkxZEJ6NBhIdChdFRElUSU9OXzk5OTk5X1RF",
-            "U1RfT05MWRCfjQZCfgoTY29tLmdvb2dsZS5wcm90b2J1ZkIQRGVzY3JpcHRv",
-            "clByb3Rvc0gBWi1nb29nbGUuZ29sYW5nLm9yZy9wcm90b2J1Zi90eXBlcy9k",
-            "ZXNjcmlwdG9ycGL4AQGiAgNHUEKqAhpHb29nbGUuUHJvdG9idWYuUmVmbGVj",
-            "dGlvbg=="));
+            "6AcQgICAgAIiqgEKDlNlcnZpY2VPcHRpb25zEi0KCGZlYXR1cmVzGCIgASgL",
+            "MhsuZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQSGQoKZGVwcmVjYXRlZBgh",
+            "IAEoCDoFZmFsc2USQwoUdW5pbnRlcnByZXRlZF9vcHRpb24Y5wcgAygLMiQu",
+            "Z29vZ2xlLnByb3RvYnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24qCQjoBxCAgICA",
+            "AiLcAgoNTWV0aG9kT3B0aW9ucxIZCgpkZXByZWNhdGVkGCEgASgIOgVmYWxz",
+            "ZRJfChFpZGVtcG90ZW5jeV9sZXZlbBgiIAEoDjIvLmdvb2dsZS5wcm90b2J1",
+            "Zi5NZXRob2RPcHRpb25zLklkZW1wb3RlbmN5TGV2ZWw6E0lERU1QT1RFTkNZ",
+            "X1VOS05PV04SLQoIZmVhdHVyZXMYIyABKAsyGy5nb29nbGUucHJvdG9idWYu",
+            "RmVhdHVyZVNldBJDChR1bmludGVycHJldGVkX29wdGlvbhjnByADKAsyJC5n",
+            "b29nbGUucHJvdG9idWYuVW5pbnRlcnByZXRlZE9wdGlvbiJQChBJZGVtcG90",
+            "ZW5jeUxldmVsEhcKE0lERU1QT1RFTkNZX1VOS05PV04QABITCg9OT19TSURF",
+            "X0VGRkVDVFMQARIOCgpJREVNUE9URU5UEAIqCQjoBxCAgICAAiKeAgoTVW5p",
+            "bnRlcnByZXRlZE9wdGlvbhI7CgRuYW1lGAIgAygLMi0uZ29vZ2xlLnByb3Rv",
+            "YnVmLlVuaW50ZXJwcmV0ZWRPcHRpb24uTmFtZVBhcnQSGAoQaWRlbnRpZmll",
+            "cl92YWx1ZRgDIAEoCRIaChJwb3NpdGl2ZV9pbnRfdmFsdWUYBCABKAQSGgoS",
+            "bmVnYXRpdmVfaW50X3ZhbHVlGAUgASgDEhQKDGRvdWJsZV92YWx1ZRgGIAEo",
+            "ARIUCgxzdHJpbmdfdmFsdWUYByABKAwSFwoPYWdncmVnYXRlX3ZhbHVlGAgg",
+            "ASgJGjMKCE5hbWVQYXJ0EhEKCW5hbWVfcGFydBgBIAIoCRIUCgxpc19leHRl",
+            "bnNpb24YAiACKAginQkKCkZlYXR1cmVTZXQSfAoOZmllbGRfcHJlc2VuY2UY",
+            "ASABKA4yKS5nb29nbGUucHJvdG9idWYuRmVhdHVyZVNldC5GaWVsZFByZXNl",
+            "bmNlQjmIAQGYAQSYAQGiAQ0SCEVYUExJQ0lUGOYHogENEghJTVBMSUNJVBjn",
+            "B6IBDRIIRVhQTElDSVQY6AcSXAoJZW51bV90eXBlGAIgASgOMiQuZ29vZ2xl",
+            "LnByb3RvYnVmLkZlYXR1cmVTZXQuRW51bVR5cGVCI4gBAZgBBpgBAaIBCxIG",
+            "Q0xPU0VEGOYHogEJEgRPUEVOGOcHEnsKF3JlcGVhdGVkX2ZpZWxkX2VuY29k",
+            "aW5nGAMgASgOMjEuZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVTZXQuUmVwZWF0",
+            "ZWRGaWVsZEVuY29kaW5nQieIAQGYAQSYAQGiAQ0SCEVYUEFOREVEGOYHogEL",
+            "EgZQQUNLRUQY5wcSaAoPdXRmOF92YWxpZGF0aW9uGAQgASgOMiouZ29vZ2xl",
+            "LnByb3RvYnVmLkZlYXR1cmVTZXQuVXRmOFZhbGlkYXRpb25CI4gBAZgBBJgB",
+            "AaIBCRIETk9ORRjmB6IBCxIGVkVSSUZZGOcHEmcKEG1lc3NhZ2VfZW5jb2Rp",
+            "bmcYBSABKA4yKy5nb29nbGUucHJvdG9idWYuRmVhdHVyZVNldC5NZXNzYWdl",
+            "RW5jb2RpbmdCIIgBAZgBBJgBAaIBFBIPTEVOR1RIX1BSRUZJWEVEGOYHEnAK",
+            "C2pzb25fZm9ybWF0GAYgASgOMiYuZ29vZ2xlLnByb3RvYnVmLkZlYXR1cmVT",
+            "ZXQuSnNvbkZvcm1hdEIziAEBmAEDmAEGmAEBogEXEhJMRUdBQ1lfQkVTVF9F",
+            "RkZPUlQY5geiAQoSBUFMTE9XGOcHIlwKDUZpZWxkUHJlc2VuY2USGgoWRklF",
+            "TERfUFJFU0VOQ0VfVU5LTk9XThAAEgwKCEVYUExJQ0lUEAESDAoISU1QTElD",
+            "SVQQAhITCg9MRUdBQ1lfUkVRVUlSRUQQAyI3CghFbnVtVHlwZRIVChFFTlVN",
+            "X1RZUEVfVU5LTk9XThAAEggKBE9QRU4QARIKCgZDTE9TRUQQAiJWChVSZXBl",
+            "YXRlZEZpZWxkRW5jb2RpbmcSIwofUkVQRUFURURfRklFTERfRU5DT0RJTkdf",
+            "VU5LTk9XThAAEgoKBlBBQ0tFRBABEgwKCEVYUEFOREVEEAIiQwoOVXRmOFZh",
+            "bGlkYXRpb24SGwoXVVRGOF9WQUxJREFUSU9OX1VOS05PV04QABIICgROT05F",
+            "EAESCgoGVkVSSUZZEAIiUwoPTWVzc2FnZUVuY29kaW5nEhwKGE1FU1NBR0Vf",
+            "RU5DT0RJTkdfVU5LTk9XThAAEhMKD0xFTkdUSF9QUkVGSVhFRBABEg0KCURF",
+            "TElNSVRFRBACIkgKCkpzb25Gb3JtYXQSFwoTSlNPTl9GT1JNQVRfVU5LTk9X",
+            "ThAAEgkKBUFMTE9XEAESFgoSTEVHQUNZX0JFU1RfRUZGT1JUEAIqBgjoBxDp",
+            "ByoGCOkHEOoHKgYIi04QkE5KBgjnBxDoByLAAgoSRmVhdHVyZVNldERlZmF1",
+            "bHRzEk4KCGRlZmF1bHRzGAEgAygLMjwuZ29vZ2xlLnByb3RvYnVmLkZlYXR1",
+            "cmVTZXREZWZhdWx0cy5GZWF0dXJlU2V0RWRpdGlvbkRlZmF1bHQSMQoPbWlu",
+            "aW11bV9lZGl0aW9uGAQgASgOMhguZ29vZ2xlLnByb3RvYnVmLkVkaXRpb24S",
+            "MQoPbWF4aW11bV9lZGl0aW9uGAUgASgOMhguZ29vZ2xlLnByb3RvYnVmLkVk",
+            "aXRpb24adAoYRmVhdHVyZVNldEVkaXRpb25EZWZhdWx0EikKB2VkaXRpb24Y",
+            "AyABKA4yGC5nb29nbGUucHJvdG9idWYuRWRpdGlvbhItCghmZWF0dXJlcxgC",
+            "IAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5GZWF0dXJlU2V0ItUBCg5Tb3VyY2VD",
+            "b2RlSW5mbxI6Cghsb2NhdGlvbhgBIAMoCzIoLmdvb2dsZS5wcm90b2J1Zi5T",
+            "b3VyY2VDb2RlSW5mby5Mb2NhdGlvbhqGAQoITG9jYXRpb24SEAoEcGF0aBgB",
+            "IAMoBUICEAESEAoEc3BhbhgCIAMoBUICEAESGAoQbGVhZGluZ19jb21tZW50",
+            "cxgDIAEoCRIZChF0cmFpbGluZ19jb21tZW50cxgEIAEoCRIhChlsZWFkaW5n",
+            "X2RldGFjaGVkX2NvbW1lbnRzGAYgAygJIpwCChFHZW5lcmF0ZWRDb2RlSW5m",
+            "bxJBCgphbm5vdGF0aW9uGAEgAygLMi0uZ29vZ2xlLnByb3RvYnVmLkdlbmVy",
+            "YXRlZENvZGVJbmZvLkFubm90YXRpb24awwEKCkFubm90YXRpb24SEAoEcGF0",
+            "aBgBIAMoBUICEAESEwoLc291cmNlX2ZpbGUYAiABKAkSDQoFYmVnaW4YAyAB",
+            "KAUSCwoDZW5kGAQgASgFEkgKCHNlbWFudGljGAUgASgOMjYuZ29vZ2xlLnBy",
+            "b3RvYnVmLkdlbmVyYXRlZENvZGVJbmZvLkFubm90YXRpb24uU2VtYW50aWMi",
+            "KAoIU2VtYW50aWMSCAoETk9ORRAAEgcKA1NFVBABEgkKBUFMSUFTEAIq6gEK",
+            "B0VkaXRpb24SEwoPRURJVElPTl9VTktOT1dOEAASEwoORURJVElPTl9QUk9U",
+            "TzIQ5gcSEwoORURJVElPTl9QUk9UTzMQ5wcSEQoMRURJVElPTl8yMDIzEOgH",
+            "EhcKE0VESVRJT05fMV9URVNUX09OTFkQARIXChNFRElUSU9OXzJfVEVTVF9P",
+            "TkxZEAISHQoXRURJVElPTl85OTk5N19URVNUX09OTFkQnY0GEh0KF0VESVRJ",
+            "T05fOTk5OThfVEVTVF9PTkxZEJ6NBhIdChdFRElUSU9OXzk5OTk5X1RFU1Rf",
+            "T05MWRCfjQZCfgoTY29tLmdvb2dsZS5wcm90b2J1ZkIQRGVzY3JpcHRvclBy",
+            "b3Rvc0gBWi1nb29nbGUuZ29sYW5nLm9yZy9wcm90b2J1Zi90eXBlcy9kZXNj",
+            "cmlwdG9ycGL4AQGiAgNHUEKqAhpHb29nbGUuUHJvdG9idWYuUmVmbGVjdGlv",
+            "bg=="));
       descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
           new pbr::FileDescriptor[] { },
           new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Google.Protobuf.Reflection.Edition), }, null, new pbr::GeneratedClrTypeInfo[] {
@@ -251,7 +252,7 @@ namespace Google.Protobuf.Reflection {
             new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.EnumValueDescriptorProto), global::Google.Protobuf.Reflection.EnumValueDescriptorProto.Parser, new[]{ "Name", "Number", "Options" }, null, null, null, null),
             new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.ServiceDescriptorProto), global::Google.Protobuf.Reflection.ServiceDescriptorProto.Parser, new[]{ "Name", "Method", "Options" }, null, null, null, null),
             new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.MethodDescriptorProto), global::Google.Protobuf.Reflection.MethodDescriptorProto.Parser, new[]{ "Name", "InputType", "OutputType", "Options", "ClientStreaming", "ServerStreaming" }, null, null, null, null),
-            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.FileOptions), global::Google.Protobuf.Reflection.FileOptions.Parser, new[]{ "JavaPackage", "JavaOuterClassname", "JavaMultipleFiles", "JavaGenerateEqualsAndHash", "JavaStringCheckUtf8", "OptimizeFor", "GoPackage", "CcGenericServices", "JavaGenericServices", "PyGenericServices", "PhpGenericServices", "Deprecated", "CcEnableArenas", "ObjcClassPrefix", "CsharpNamespace", "SwiftPrefix", "PhpClassPrefix", "PhpNamespace", "PhpMetadataNamespace", "RubyPackage", "Features", "UninterpretedOption" }, null, new[]{ typeof(global::Google.Protobuf.Reflection.FileOptions.Types.OptimizeMode) }, null, null),
+            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.FileOptions), global::Google.Protobuf.Reflection.FileOptions.Parser, new[]{ "JavaPackage", "JavaOuterClassname", "JavaMultipleFiles", "JavaGenerateEqualsAndHash", "JavaStringCheckUtf8", "OptimizeFor", "GoPackage", "CcGenericServices", "JavaGenericServices", "PyGenericServices", "PhpGenericServices", "Deprecated", "CcEnableArenas", "CcMutableDonatedString", "ObjcClassPrefix", "CsharpNamespace", "SwiftPrefix", "PhpClassPrefix", "PhpNamespace", "PhpMetadataNamespace", "RubyPackage", "Features", "UninterpretedOption" }, null, new[]{ typeof(global::Google.Protobuf.Reflection.FileOptions.Types.OptimizeMode) }, null, null),
             new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.MessageOptions), global::Google.Protobuf.Reflection.MessageOptions.Parser, new[]{ "MessageSetWireFormat", "NoStandardDescriptorAccessor", "Deprecated", "MapEntry", "DeprecatedLegacyJsonFieldConflicts", "Features", "UninterpretedOption" }, null, null, null, null),
             new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.FieldOptions), global::Google.Protobuf.Reflection.FieldOptions.Parser, new[]{ "Ctype", "Packed", "Jstype", "Lazy", "UnverifiedLazy", "Deprecated", "Weak", "DebugRedact", "Retention", "Targets", "EditionDefaults", "Features", "UninterpretedOption" }, null, new[]{ typeof(global::Google.Protobuf.Reflection.FieldOptions.Types.CType), typeof(global::Google.Protobuf.Reflection.FieldOptions.Types.JSType), typeof(global::Google.Protobuf.Reflection.FieldOptions.Types.OptionRetention), typeof(global::Google.Protobuf.Reflection.FieldOptions.Types.OptionTargetType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.FieldOptions.Types.EditionDefault), global::Google.Protobuf.Reflection.FieldOptions.Types.EditionDefault.Parser, new[]{ "Edition", "Value" }, null, null, null, null)}),
             new pbr::GeneratedClrTypeInfo(typeof(global::Google.Protobuf.Reflection.OneofOptions), global::Google.Protobuf.Reflection.OneofOptions.Parser, new[]{ "Features", "UninterpretedOption" }, null, null, null, null),
@@ -5867,6 +5868,7 @@ namespace Google.Protobuf.Reflection {
       phpGenericServices_ = other.phpGenericServices_;
       deprecated_ = other.deprecated_;
       ccEnableArenas_ = other.ccEnableArenas_;
+      ccMutableDonatedString_ = other.ccMutableDonatedString_;
       objcClassPrefix_ = other.objcClassPrefix_;
       csharpNamespace_ = other.csharpNamespace_;
       swiftPrefix_ = other.swiftPrefix_;
@@ -6215,9 +6217,9 @@ namespace Google.Protobuf.Reflection {
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
     [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
     public bool PhpGenericServices {
-      get { if ((_hasBits0 & 512) != 0) { return phpGenericServices_; } else { return PhpGenericServicesDefaultValue; } }
+      get { if ((_hasBits0 & 1024) != 0) { return phpGenericServices_; } else { return PhpGenericServicesDefaultValue; } }
       set {
-        _hasBits0 |= 512;
+        _hasBits0 |= 1024;
         phpGenericServices_ = value;
       }
     }
@@ -6225,13 +6227,13 @@ namespace Google.Protobuf.Reflection {
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
     [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
     public bool HasPhpGenericServices {
-      get { return (_hasBits0 & 512) != 0; }
+      get { return (_hasBits0 & 1024) != 0; }
     }
     /// <summary>Clears the value of the "php_generic_services" field</summary>
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
     [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
     public void ClearPhpGenericServices() {
-      _hasBits0 &= ~512;
+      _hasBits0 &= ~1024;
     }
 
     /// <summary>Field number for the "deprecated" field.</summary>
@@ -6298,6 +6300,38 @@ namespace Google.Protobuf.Reflection {
       _hasBits0 &= ~256;
     }
 
+    /// <summary>Field number for the "cc_mutable_donated_string" field.</summary>
+    public const int CcMutableDonatedStringFieldNumber = 32;
+    private readonly static bool CcMutableDonatedStringDefaultValue = false;
+
+    private bool ccMutableDonatedString_;
+    /// <summary>
+    /// 增加新开关，控制生成代码的mutable_xxx接口行为和返回值
+    /// false: 默认，将donated状态的string转换为heap allocated，通过std::string*返回
+    /// true: 保持当前string的donated状态，通过MaybeArenaStringAccessor返回
+    /// </summary>
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
+    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
+    public bool CcMutableDonatedString {
+      get { if ((_hasBits0 & 512) != 0) { return ccMutableDonatedString_; } else { return CcMutableDonatedStringDefaultValue; } }
+      set {
+        _hasBits0 |= 512;
+        ccMutableDonatedString_ = value;
+      }
+    }
+    /// <summary>Gets whether the "cc_mutable_donated_string" field is set</summary>
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
+    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
+    public bool HasCcMutableDonatedString {
+      get { return (_hasBits0 & 512) != 0; }
+    }
+    /// <summary>Clears the value of the "cc_mutable_donated_string" field</summary>
+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
+    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
+    public void ClearCcMutableDonatedString() {
+      _hasBits0 &= ~512;
+    }
+
     /// <summary>Field number for the "objc_class_prefix" field.</summary>
     public const int ObjcClassPrefixFieldNumber = 36;
     private readonly static string ObjcClassPrefixDefaultValue = "";
@@ -6570,6 +6604,7 @@ namespace Google.Protobuf.Reflection {
       if (PhpGenericServices != other.PhpGenericServices) return false;
       if (Deprecated != other.Deprecated) return false;
       if (CcEnableArenas != other.CcEnableArenas) return false;
+      if (CcMutableDonatedString != other.CcMutableDonatedString) return false;
       if (ObjcClassPrefix != other.ObjcClassPrefix) return false;
       if (CsharpNamespace != other.CsharpNamespace) return false;
       if (SwiftPrefix != other.SwiftPrefix) return false;
@@ -6602,6 +6637,7 @@ namespace Google.Protobuf.Reflection {
       if (HasPhpGenericServices) hash ^= PhpGenericServices.GetHashCode();
       if (HasDeprecated) hash ^= Deprecated.GetHashCode();
       if (HasCcEnableArenas) hash ^= CcEnableArenas.GetHashCode();
+      if (HasCcMutableDonatedString) hash ^= CcMutableDonatedString.GetHashCode();
       if (HasObjcClassPrefix) hash ^= ObjcClassPrefix.GetHashCode();
       if (HasCsharpNamespace) hash ^= CsharpNamespace.GetHashCode();
       if (HasSwiftPrefix) hash ^= SwiftPrefix.GetHashCode();
@@ -6680,6 +6716,10 @@ namespace Google.Protobuf.Reflection {
         output.WriteRawTag(248, 1);
         output.WriteBool(CcEnableArenas);
       }
+      if (HasCcMutableDonatedString) {
+        output.WriteRawTag(128, 2);
+        output.WriteBool(CcMutableDonatedString);
+      }
       if (HasObjcClassPrefix) {
         output.WriteRawTag(162, 2);
         output.WriteString(ObjcClassPrefix);
@@ -6778,6 +6818,10 @@ namespace Google.Protobuf.Reflection {
         output.WriteRawTag(248, 1);
         output.WriteBool(CcEnableArenas);
       }
+      if (HasCcMutableDonatedString) {
+        output.WriteRawTag(128, 2);
+        output.WriteBool(CcMutableDonatedString);
+      }
       if (HasObjcClassPrefix) {
         output.WriteRawTag(162, 2);
         output.WriteString(ObjcClassPrefix);
@@ -6867,6 +6911,9 @@ namespace Google.Protobuf.Reflection {
       if (HasCcEnableArenas) {
         size += 2 + 1;
       }
+      if (HasCcMutableDonatedString) {
+        size += 2 + 1;
+      }
       if (HasObjcClassPrefix) {
         size += 2 + pb::CodedOutputStream.ComputeStringSize(ObjcClassPrefix);
       }
@@ -6946,6 +6993,9 @@ namespace Google.Protobuf.Reflection {
       if (other.HasCcEnableArenas) {
         CcEnableArenas = other.CcEnableArenas;
       }
+      if (other.HasCcMutableDonatedString) {
+        CcMutableDonatedString = other.CcMutableDonatedString;
+      }
       if (other.HasObjcClassPrefix) {
         ObjcClassPrefix = other.ObjcClassPrefix;
       }
@@ -7040,6 +7090,10 @@ namespace Google.Protobuf.Reflection {
             CcEnableArenas = input.ReadBool();
             break;
           }
+          case 256: {
+            CcMutableDonatedString = input.ReadBool();
+            break;
+          }
           case 290: {
             ObjcClassPrefix = input.ReadString();
             break;
@@ -7148,6 +7202,10 @@ namespace Google.Protobuf.Reflection {
             CcEnableArenas = input.ReadBool();
             break;
           }
+          case 256: {
+            CcMutableDonatedString = input.ReadBool();
+            break;
+          }
           case 290: {
             ObjcClassPrefix = input.ReadString();
             break;
diff --git a/php/ext/google/protobuf/wkt.inc b/php/ext/google/protobuf/wkt.inc
index 4579c7e30..929602208 100644
--- a/php/ext/google/protobuf/wkt.inc
+++ b/php/ext/google/protobuf/wkt.inc
@@ -1501,12 +1501,12 @@ static void google_protobuf_NullValue_ModuleInit() {
 
 zend_class_entry* GPBMetadata_Google_Protobuf_Type_ce;
 
-const char google_protobuf_type_proto_descriptor [1592] = {
+const char google_protobuf_type_proto_descriptor [1647] = {
 '\n', '\032', 'g', 'o', 'o', 'g', 'l', 'e', '/', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '/', 't', 'y', 'p', 'e', '.', 'p', 'r', 
 'o', 't', 'o', '\022', '\017', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '\032', '\031', 'g', 'o', 'o', 
 'g', 'l', 'e', '/', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '/', 'a', 'n', 'y', '.', 'p', 'r', 'o', 't', 'o', '\032', '$', 'g', 
 'o', 'o', 'g', 'l', 'e', '/', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '/', 's', 'o', 'u', 'r', 'c', 'e', '_', 'c', 'o', 'n', 
-'t', 'e', 'x', 't', '.', 'p', 'r', 'o', 't', 'o', '\"', '\327', '\001', '\n', '\004', 'T', 'y', 'p', 'e', '\022', '\014', '\n', '\004', 'n', 'a', 
+'t', 'e', 'x', 't', '.', 'p', 'r', 'o', 't', 'o', '\"', '\350', '\001', '\n', '\004', 'T', 'y', 'p', 'e', '\022', '\014', '\n', '\004', 'n', 'a', 
 'm', 'e', '\030', '\001', ' ', '\001', '(', '\t', '\022', '&', '\n', '\006', 'f', 'i', 'e', 'l', 'd', 's', '\030', '\002', ' ', '\003', '(', '\013', '2', 
 '\026', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'F', 'i', 'e', 'l', 'd', '\022', '\016', 
 '\n', '\006', 'o', 'n', 'e', 'o', 'f', 's', '\030', '\003', ' ', '\003', '(', '\t', '\022', '(', '\n', '\007', 'o', 'p', 't', 'i', 'o', 'n', 's', 
@@ -1515,57 +1515,59 @@ const char google_protobuf_type_proto_descriptor [1592] = {
 '\005', ' ', '\001', '(', '\013', '2', '\036', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'S', 
 'o', 'u', 'r', 'c', 'e', 'C', 'o', 'n', 't', 'e', 'x', 't', '\022', '\'', '\n', '\006', 's', 'y', 'n', 't', 'a', 'x', '\030', '\006', ' ', 
 '\001', '(', '\016', '2', '\027', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'S', 'y', 'n', 
-'t', 'a', 'x', '\"', '\325', '\005', '\n', '\005', 'F', 'i', 'e', 'l', 'd', '\022', ')', '\n', '\004', 'k', 'i', 'n', 'd', '\030', '\001', ' ', '\001', 
-'(', '\016', '2', '\033', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'F', 'i', 'e', 'l', 
-'d', '.', 'K', 'i', 'n', 'd', '\022', '7', '\n', '\013', 'c', 'a', 'r', 'd', 'i', 'n', 'a', 'l', 'i', 't', 'y', '\030', '\002', ' ', '\001', 
-'(', '\016', '2', '\"', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'F', 'i', 'e', 'l', 
-'d', '.', 'C', 'a', 'r', 'd', 'i', 'n', 'a', 'l', 'i', 't', 'y', '\022', '\016', '\n', '\006', 'n', 'u', 'm', 'b', 'e', 'r', '\030', '\003', 
-' ', '\001', '(', '\005', '\022', '\014', '\n', '\004', 'n', 'a', 'm', 'e', '\030', '\004', ' ', '\001', '(', '\t', '\022', '\020', '\n', '\010', 't', 'y', 'p', 
-'e', '_', 'u', 'r', 'l', '\030', '\006', ' ', '\001', '(', '\t', '\022', '\023', '\n', '\013', 'o', 'n', 'e', 'o', 'f', '_', 'i', 'n', 'd', 'e', 
-'x', '\030', '\007', ' ', '\001', '(', '\005', '\022', '\016', '\n', '\006', 'p', 'a', 'c', 'k', 'e', 'd', '\030', '\010', ' ', '\001', '(', '\010', '\022', '(', 
-'\n', '\007', 'o', 'p', 't', 'i', 'o', 'n', 's', '\030', '\t', ' ', '\003', '(', '\013', '2', '\027', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 
-'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'O', 'p', 't', 'i', 'o', 'n', '\022', '\021', '\n', '\t', 'j', 's', 'o', 'n', '_', 'n', 
-'a', 'm', 'e', '\030', '\n', ' ', '\001', '(', '\t', '\022', '\025', '\n', '\r', 'd', 'e', 'f', 'a', 'u', 'l', 't', '_', 'v', 'a', 'l', 'u', 
-'e', '\030', '\013', ' ', '\001', '(', '\t', '\"', '\310', '\002', '\n', '\004', 'K', 'i', 'n', 'd', '\022', '\020', '\n', '\014', 'T', 'Y', 'P', 'E', '_', 
-'U', 'N', 'K', 'N', 'O', 'W', 'N', '\020', '\000', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'D', 'O', 'U', 'B', 'L', 'E', '\020', 
-'\001', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 'E', '_', 'F', 'L', 'O', 'A', 'T', '\020', '\002', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 'E', 
-'_', 'I', 'N', 'T', '6', '4', '\020', '\003', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'U', 'I', 'N', 'T', '6', '4', '\020', '\004', 
-'\022', '\016', '\n', '\n', 'T', 'Y', 'P', 'E', '_', 'I', 'N', 'T', '3', '2', '\020', '\005', '\022', '\020', '\n', '\014', 'T', 'Y', 'P', 'E', '_', 
-'F', 'I', 'X', 'E', 'D', '6', '4', '\020', '\006', '\022', '\020', '\n', '\014', 'T', 'Y', 'P', 'E', '_', 'F', 'I', 'X', 'E', 'D', '3', '2', 
-'\020', '\007', '\022', '\r', '\n', '\t', 'T', 'Y', 'P', 'E', '_', 'B', 'O', 'O', 'L', '\020', '\010', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', 
-'_', 'S', 'T', 'R', 'I', 'N', 'G', '\020', '\t', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 'E', '_', 'G', 'R', 'O', 'U', 'P', '\020', '\n', 
-'\022', '\020', '\n', '\014', 'T', 'Y', 'P', 'E', '_', 'M', 'E', 'S', 'S', 'A', 'G', 'E', '\020', '\013', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 
-'E', '_', 'B', 'Y', 'T', 'E', 'S', '\020', '\014', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'U', 'I', 'N', 'T', '3', '2', '\020', 
-'\r', '\022', '\r', '\n', '\t', 'T', 'Y', 'P', 'E', '_', 'E', 'N', 'U', 'M', '\020', '\016', '\022', '\021', '\n', '\r', 'T', 'Y', 'P', 'E', '_', 
-'S', 'F', 'I', 'X', 'E', 'D', '3', '2', '\020', '\017', '\022', '\021', '\n', '\r', 'T', 'Y', 'P', 'E', '_', 'S', 'F', 'I', 'X', 'E', 'D', 
-'6', '4', '\020', '\020', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'S', 'I', 'N', 'T', '3', '2', '\020', '\021', '\022', '\017', '\n', '\013', 
-'T', 'Y', 'P', 'E', '_', 'S', 'I', 'N', 'T', '6', '4', '\020', '\022', '\"', 't', '\n', '\013', 'C', 'a', 'r', 'd', 'i', 'n', 'a', 'l', 
-'i', 't', 'y', '\022', '\027', '\n', '\023', 'C', 'A', 'R', 'D', 'I', 'N', 'A', 'L', 'I', 'T', 'Y', '_', 'U', 'N', 'K', 'N', 'O', 'W', 
-'N', '\020', '\000', '\022', '\030', '\n', '\024', 'C', 'A', 'R', 'D', 'I', 'N', 'A', 'L', 'I', 'T', 'Y', '_', 'O', 'P', 'T', 'I', 'O', 'N', 
-'A', 'L', '\020', '\001', '\022', '\030', '\n', '\024', 'C', 'A', 'R', 'D', 'I', 'N', 'A', 'L', 'I', 'T', 'Y', '_', 'R', 'E', 'Q', 'U', 'I', 
-'R', 'E', 'D', '\020', '\002', '\022', '\030', '\n', '\024', 'C', 'A', 'R', 'D', 'I', 'N', 'A', 'L', 'I', 'T', 'Y', '_', 'R', 'E', 'P', 'E', 
-'A', 'T', 'E', 'D', '\020', '\003', '\"', '\316', '\001', '\n', '\004', 'E', 'n', 'u', 'm', '\022', '\014', '\n', '\004', 'n', 'a', 'm', 'e', '\030', '\001', 
-' ', '\001', '(', '\t', '\022', '-', '\n', '\t', 'e', 'n', 'u', 'm', 'v', 'a', 'l', 'u', 'e', '\030', '\002', ' ', '\003', '(', '\013', '2', '\032', 
-'.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'E', 'n', 'u', 'm', 'V', 'a', 'l', 'u', 
-'e', '\022', '(', '\n', '\007', 'o', 'p', 't', 'i', 'o', 'n', 's', '\030', '\003', ' ', '\003', '(', '\013', '2', '\027', '.', 'g', 'o', 'o', 'g', 
-'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'O', 'p', 't', 'i', 'o', 'n', '\022', '6', '\n', '\016', 's', 'o', 'u', 
-'r', 'c', 'e', '_', 'c', 'o', 'n', 't', 'e', 'x', 't', '\030', '\004', ' ', '\001', '(', '\013', '2', '\036', '.', 'g', 'o', 'o', 'g', 'l', 
-'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'S', 'o', 'u', 'r', 'c', 'e', 'C', 'o', 'n', 't', 'e', 'x', 't', '\022', 
-'\'', '\n', '\006', 's', 'y', 'n', 't', 'a', 'x', '\030', '\005', ' ', '\001', '(', '\016', '2', '\027', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 
-'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'S', 'y', 'n', 't', 'a', 'x', '\"', 'S', '\n', '\t', 'E', 'n', 'u', 'm', 'V', 'a', 
-'l', 'u', 'e', '\022', '\014', '\n', '\004', 'n', 'a', 'm', 'e', '\030', '\001', ' ', '\001', '(', '\t', '\022', '\016', '\n', '\006', 'n', 'u', 'm', 'b', 
-'e', 'r', '\030', '\002', ' ', '\001', '(', '\005', '\022', '(', '\n', '\007', 'o', 'p', 't', 'i', 'o', 'n', 's', '\030', '\003', ' ', '\003', '(', '\013', 
-'2', '\027', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'O', 'p', 't', 'i', 'o', 'n', 
-'\"', ';', '\n', '\006', 'O', 'p', 't', 'i', 'o', 'n', '\022', '\014', '\n', '\004', 'n', 'a', 'm', 'e', '\030', '\001', ' ', '\001', '(', '\t', '\022', 
-'#', '\n', '\005', 'v', 'a', 'l', 'u', 'e', '\030', '\002', ' ', '\001', '(', '\013', '2', '\024', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 
-'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'A', 'n', 'y', '*', '.', '\n', '\006', 'S', 'y', 'n', 't', 'a', 'x', '\022', '\021', '\n', '\r', 
-'S', 'Y', 'N', 'T', 'A', 'X', '_', 'P', 'R', 'O', 'T', 'O', '2', '\020', '\000', '\022', '\021', '\n', '\r', 'S', 'Y', 'N', 'T', 'A', 'X', 
-'_', 'P', 'R', 'O', 'T', 'O', '3', '\020', '\001', 'B', '{', '\n', '\023', 'c', 'o', 'm', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 
-'r', 'o', 't', 'o', 'b', 'u', 'f', 'B', '\t', 'T', 'y', 'p', 'e', 'P', 'r', 'o', 't', 'o', 'P', '\001', 'Z', '-', 'g', 'o', 'o', 
-'g', 'l', 'e', '.', 'g', 'o', 'l', 'a', 'n', 'g', '.', 'o', 'r', 'g', '/', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '/', 't', 
-'y', 'p', 'e', 's', '/', 'k', 'n', 'o', 'w', 'n', '/', 't', 'y', 'p', 'e', 'p', 'b', '\370', '\001', '\001', '\242', '\002', '\003', 'G', 'P', 
-'B', '\252', '\002', '\036', 'G', 'o', 'o', 'g', 'l', 'e', '.', 'P', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'W', 'e', 'l', 'l', 'K', 
-'n', 'o', 'w', 'n', 'T', 'y', 'p', 'e', 's', 'b', '\006', 'p', 'r', 'o', 't', 'o', '3', 
+'t', 'a', 'x', '\022', '\017', '\n', '\007', 'e', 'd', 'i', 't', 'i', 'o', 'n', '\030', '\007', ' ', '\001', '(', '\t', '\"', '\325', '\005', '\n', '\005', 
+'F', 'i', 'e', 'l', 'd', '\022', ')', '\n', '\004', 'k', 'i', 'n', 'd', '\030', '\001', ' ', '\001', '(', '\016', '2', '\033', '.', 'g', 'o', 'o', 
+'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'F', 'i', 'e', 'l', 'd', '.', 'K', 'i', 'n', 'd', '\022', '7', 
+'\n', '\013', 'c', 'a', 'r', 'd', 'i', 'n', 'a', 'l', 'i', 't', 'y', '\030', '\002', ' ', '\001', '(', '\016', '2', '\"', '.', 'g', 'o', 'o', 
+'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'F', 'i', 'e', 'l', 'd', '.', 'C', 'a', 'r', 'd', 'i', 'n', 
+'a', 'l', 'i', 't', 'y', '\022', '\016', '\n', '\006', 'n', 'u', 'm', 'b', 'e', 'r', '\030', '\003', ' ', '\001', '(', '\005', '\022', '\014', '\n', '\004', 
+'n', 'a', 'm', 'e', '\030', '\004', ' ', '\001', '(', '\t', '\022', '\020', '\n', '\010', 't', 'y', 'p', 'e', '_', 'u', 'r', 'l', '\030', '\006', ' ', 
+'\001', '(', '\t', '\022', '\023', '\n', '\013', 'o', 'n', 'e', 'o', 'f', '_', 'i', 'n', 'd', 'e', 'x', '\030', '\007', ' ', '\001', '(', '\005', '\022', 
+'\016', '\n', '\006', 'p', 'a', 'c', 'k', 'e', 'd', '\030', '\010', ' ', '\001', '(', '\010', '\022', '(', '\n', '\007', 'o', 'p', 't', 'i', 'o', 'n', 
+'s', '\030', '\t', ' ', '\003', '(', '\013', '2', '\027', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', 
+'.', 'O', 'p', 't', 'i', 'o', 'n', '\022', '\021', '\n', '\t', 'j', 's', 'o', 'n', '_', 'n', 'a', 'm', 'e', '\030', '\n', ' ', '\001', '(', 
+'\t', '\022', '\025', '\n', '\r', 'd', 'e', 'f', 'a', 'u', 'l', 't', '_', 'v', 'a', 'l', 'u', 'e', '\030', '\013', ' ', '\001', '(', '\t', '\"', 
+'\310', '\002', '\n', '\004', 'K', 'i', 'n', 'd', '\022', '\020', '\n', '\014', 'T', 'Y', 'P', 'E', '_', 'U', 'N', 'K', 'N', 'O', 'W', 'N', '\020', 
+'\000', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'D', 'O', 'U', 'B', 'L', 'E', '\020', '\001', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 
+'E', '_', 'F', 'L', 'O', 'A', 'T', '\020', '\002', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 'E', '_', 'I', 'N', 'T', '6', '4', '\020', '\003', 
+'\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'U', 'I', 'N', 'T', '6', '4', '\020', '\004', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 'E', 
+'_', 'I', 'N', 'T', '3', '2', '\020', '\005', '\022', '\020', '\n', '\014', 'T', 'Y', 'P', 'E', '_', 'F', 'I', 'X', 'E', 'D', '6', '4', '\020', 
+'\006', '\022', '\020', '\n', '\014', 'T', 'Y', 'P', 'E', '_', 'F', 'I', 'X', 'E', 'D', '3', '2', '\020', '\007', '\022', '\r', '\n', '\t', 'T', 'Y', 
+'P', 'E', '_', 'B', 'O', 'O', 'L', '\020', '\010', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'S', 'T', 'R', 'I', 'N', 'G', '\020', 
+'\t', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 'E', '_', 'G', 'R', 'O', 'U', 'P', '\020', '\n', '\022', '\020', '\n', '\014', 'T', 'Y', 'P', 'E', 
+'_', 'M', 'E', 'S', 'S', 'A', 'G', 'E', '\020', '\013', '\022', '\016', '\n', '\n', 'T', 'Y', 'P', 'E', '_', 'B', 'Y', 'T', 'E', 'S', '\020', 
+'\014', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'U', 'I', 'N', 'T', '3', '2', '\020', '\r', '\022', '\r', '\n', '\t', 'T', 'Y', 'P', 
+'E', '_', 'E', 'N', 'U', 'M', '\020', '\016', '\022', '\021', '\n', '\r', 'T', 'Y', 'P', 'E', '_', 'S', 'F', 'I', 'X', 'E', 'D', '3', '2', 
+'\020', '\017', '\022', '\021', '\n', '\r', 'T', 'Y', 'P', 'E', '_', 'S', 'F', 'I', 'X', 'E', 'D', '6', '4', '\020', '\020', '\022', '\017', '\n', '\013', 
+'T', 'Y', 'P', 'E', '_', 'S', 'I', 'N', 'T', '3', '2', '\020', '\021', '\022', '\017', '\n', '\013', 'T', 'Y', 'P', 'E', '_', 'S', 'I', 'N', 
+'T', '6', '4', '\020', '\022', '\"', 't', '\n', '\013', 'C', 'a', 'r', 'd', 'i', 'n', 'a', 'l', 'i', 't', 'y', '\022', '\027', '\n', '\023', 'C', 
+'A', 'R', 'D', 'I', 'N', 'A', 'L', 'I', 'T', 'Y', '_', 'U', 'N', 'K', 'N', 'O', 'W', 'N', '\020', '\000', '\022', '\030', '\n', '\024', 'C', 
+'A', 'R', 'D', 'I', 'N', 'A', 'L', 'I', 'T', 'Y', '_', 'O', 'P', 'T', 'I', 'O', 'N', 'A', 'L', '\020', '\001', '\022', '\030', '\n', '\024', 
+'C', 'A', 'R', 'D', 'I', 'N', 'A', 'L', 'I', 'T', 'Y', '_', 'R', 'E', 'Q', 'U', 'I', 'R', 'E', 'D', '\020', '\002', '\022', '\030', '\n', 
+'\024', 'C', 'A', 'R', 'D', 'I', 'N', 'A', 'L', 'I', 'T', 'Y', '_', 'R', 'E', 'P', 'E', 'A', 'T', 'E', 'D', '\020', '\003', '\"', '\337', 
+'\001', '\n', '\004', 'E', 'n', 'u', 'm', '\022', '\014', '\n', '\004', 'n', 'a', 'm', 'e', '\030', '\001', ' ', '\001', '(', '\t', '\022', '-', '\n', '\t', 
+'e', 'n', 'u', 'm', 'v', 'a', 'l', 'u', 'e', '\030', '\002', ' ', '\003', '(', '\013', '2', '\032', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 
+'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'E', 'n', 'u', 'm', 'V', 'a', 'l', 'u', 'e', '\022', '(', '\n', '\007', 'o', 'p', 't', 
+'i', 'o', 'n', 's', '\030', '\003', ' ', '\003', '(', '\013', '2', '\027', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 
+'b', 'u', 'f', '.', 'O', 'p', 't', 'i', 'o', 'n', '\022', '6', '\n', '\016', 's', 'o', 'u', 'r', 'c', 'e', '_', 'c', 'o', 'n', 't', 
+'e', 'x', 't', '\030', '\004', ' ', '\001', '(', '\013', '2', '\036', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 
+'u', 'f', '.', 'S', 'o', 'u', 'r', 'c', 'e', 'C', 'o', 'n', 't', 'e', 'x', 't', '\022', '\'', '\n', '\006', 's', 'y', 'n', 't', 'a', 
+'x', '\030', '\005', ' ', '\001', '(', '\016', '2', '\027', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', 
+'.', 'S', 'y', 'n', 't', 'a', 'x', '\022', '\017', '\n', '\007', 'e', 'd', 'i', 't', 'i', 'o', 'n', '\030', '\006', ' ', '\001', '(', '\t', '\"', 
+'S', '\n', '\t', 'E', 'n', 'u', 'm', 'V', 'a', 'l', 'u', 'e', '\022', '\014', '\n', '\004', 'n', 'a', 'm', 'e', '\030', '\001', ' ', '\001', '(', 
+'\t', '\022', '\016', '\n', '\006', 'n', 'u', 'm', 'b', 'e', 'r', '\030', '\002', ' ', '\001', '(', '\005', '\022', '(', '\n', '\007', 'o', 'p', 't', 'i', 
+'o', 'n', 's', '\030', '\003', ' ', '\003', '(', '\013', '2', '\027', '.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 
+'u', 'f', '.', 'O', 'p', 't', 'i', 'o', 'n', '\"', ';', '\n', '\006', 'O', 'p', 't', 'i', 'o', 'n', '\022', '\014', '\n', '\004', 'n', 'a', 
+'m', 'e', '\030', '\001', ' ', '\001', '(', '\t', '\022', '#', '\n', '\005', 'v', 'a', 'l', 'u', 'e', '\030', '\002', ' ', '\001', '(', '\013', '2', '\024', 
+'.', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 'A', 'n', 'y', '*', 'C', '\n', '\006', 'S', 
+'y', 'n', 't', 'a', 'x', '\022', '\021', '\n', '\r', 'S', 'Y', 'N', 'T', 'A', 'X', '_', 'P', 'R', 'O', 'T', 'O', '2', '\020', '\000', '\022', 
+'\021', '\n', '\r', 'S', 'Y', 'N', 'T', 'A', 'X', '_', 'P', 'R', 'O', 'T', 'O', '3', '\020', '\001', '\022', '\023', '\n', '\017', 'S', 'Y', 'N', 
+'T', 'A', 'X', '_', 'E', 'D', 'I', 'T', 'I', 'O', 'N', 'S', '\020', '\002', 'B', '{', '\n', '\023', 'c', 'o', 'm', '.', 'g', 'o', 'o', 
+'g', 'l', 'e', '.', 'p', 'r', 'o', 't', 'o', 'b', 'u', 'f', 'B', '\t', 'T', 'y', 'p', 'e', 'P', 'r', 'o', 't', 'o', 'P', '\001', 
+'Z', '-', 'g', 'o', 'o', 'g', 'l', 'e', '.', 'g', 'o', 'l', 'a', 'n', 'g', '.', 'o', 'r', 'g', '/', 'p', 'r', 'o', 't', 'o', 
+'b', 'u', 'f', '/', 't', 'y', 'p', 'e', 's', '/', 'k', 'n', 'o', 'w', 'n', '/', 't', 'y', 'p', 'e', 'p', 'b', '\370', '\001', '\001', 
+'\242', '\002', '\003', 'G', 'P', 'B', '\252', '\002', '\036', 'G', 'o', 'o', 'g', 'l', 'e', '.', 'P', 'r', 'o', 't', 'o', 'b', 'u', 'f', '.', 
+'W', 'e', 'l', 'l', 'K', 'n', 'o', 'w', 'n', 'T', 'y', 'p', 'e', 's', 'b', '\006', 'p', 'r', 'o', 't', 'o', '3', 
 };
 
 static void google_protobuf_type_proto_AddDescriptor() {
@@ -1735,6 +1737,28 @@ static PHP_METHOD(google_protobuf_Type, setSyntax) {
   RETURN_COPY(getThis());
 }
 
+static PHP_METHOD(google_protobuf_Type, getEdition) {
+  Message* intern = (Message*)Z_OBJ_P(getThis());
+  const upb_FieldDef *f = upb_MessageDef_FindFieldByName(
+      intern->desc->msgdef, "edition");
+  zval ret;
+  Message_get(intern, f, &ret);
+  RETURN_COPY_VALUE(&ret);
+}
+
+static PHP_METHOD(google_protobuf_Type, setEdition) {
+  Message* intern = (Message*)Z_OBJ_P(getThis());
+  const upb_FieldDef *f = upb_MessageDef_FindFieldByName(
+      intern->desc->msgdef, "edition");
+  zval *val;
+  if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &val)
+      == FAILURE) {
+    return;
+  }
+  Message_set(intern, f, val);
+  RETURN_COPY(getThis());
+}
+
 static zend_function_entry google_protobuf_Type_phpmethods[] = {
   PHP_ME(google_protobuf_Type, __construct, arginfo_construct, ZEND_ACC_PUBLIC)
   PHP_ME(google_protobuf_Type, getName, arginfo_void, ZEND_ACC_PUBLIC)
@@ -1749,6 +1773,8 @@ static zend_function_entry google_protobuf_Type_phpmethods[] = {
   PHP_ME(google_protobuf_Type, setSourceContext, arginfo_setter, ZEND_ACC_PUBLIC)
   PHP_ME(google_protobuf_Type, getSyntax, arginfo_void, ZEND_ACC_PUBLIC)
   PHP_ME(google_protobuf_Type, setSyntax, arginfo_setter, ZEND_ACC_PUBLIC)
+  PHP_ME(google_protobuf_Type, getEdition, arginfo_void, ZEND_ACC_PUBLIC)
+  PHP_ME(google_protobuf_Type, setEdition, arginfo_setter, ZEND_ACC_PUBLIC)
   ZEND_FE_END
 };
 
@@ -2319,6 +2345,28 @@ static PHP_METHOD(google_protobuf_Enum, setSyntax) {
   RETURN_COPY(getThis());
 }
 
+static PHP_METHOD(google_protobuf_Enum, getEdition) {
+  Message* intern = (Message*)Z_OBJ_P(getThis());
+  const upb_FieldDef *f = upb_MessageDef_FindFieldByName(
+      intern->desc->msgdef, "edition");
+  zval ret;
+  Message_get(intern, f, &ret);
+  RETURN_COPY_VALUE(&ret);
+}
+
+static PHP_METHOD(google_protobuf_Enum, setEdition) {
+  Message* intern = (Message*)Z_OBJ_P(getThis());
+  const upb_FieldDef *f = upb_MessageDef_FindFieldByName(
+      intern->desc->msgdef, "edition");
+  zval *val;
+  if (zend_parse_parameters(ZEND_NUM_ARGS(), "z", &val)
+      == FAILURE) {
+    return;
+  }
+  Message_set(intern, f, val);
+  RETURN_COPY(getThis());
+}
+
 static zend_function_entry google_protobuf_Enum_phpmethods[] = {
   PHP_ME(google_protobuf_Enum, __construct, arginfo_construct, ZEND_ACC_PUBLIC)
   PHP_ME(google_protobuf_Enum, getName, arginfo_void, ZEND_ACC_PUBLIC)
@@ -2331,6 +2379,8 @@ static zend_function_entry google_protobuf_Enum_phpmethods[] = {
   PHP_ME(google_protobuf_Enum, setSourceContext, arginfo_setter, ZEND_ACC_PUBLIC)
   PHP_ME(google_protobuf_Enum, getSyntax, arginfo_void, ZEND_ACC_PUBLIC)
   PHP_ME(google_protobuf_Enum, setSyntax, arginfo_setter, ZEND_ACC_PUBLIC)
+  PHP_ME(google_protobuf_Enum, getEdition, arginfo_void, ZEND_ACC_PUBLIC)
+  PHP_ME(google_protobuf_Enum, setEdition, arginfo_setter, ZEND_ACC_PUBLIC)
   ZEND_FE_END
 };
 
@@ -2582,6 +2632,8 @@ static void google_protobuf_Syntax_ModuleInit() {
                                    strlen("SYNTAX_PROTO2"), 0);
   zend_declare_class_constant_long(google_protobuf_Syntax_ce, "SYNTAX_PROTO3",
                                    strlen("SYNTAX_PROTO3"), 1);
+  zend_declare_class_constant_long(google_protobuf_Syntax_ce, "SYNTAX_EDITIONS",
+                                   strlen("SYNTAX_EDITIONS"), 2);
 }
 
 /* google/protobuf/timestamp.proto */
diff --git a/php/src/GPBMetadata/Google/Protobuf/Internal/Descriptor.php b/php/src/GPBMetadata/Google/Protobuf/Internal/Descriptor.php
index 4247c0954..d02c326ae 100644
--- a/php/src/GPBMetadata/Google/Protobuf/Internal/Descriptor.php
+++ b/php/src/GPBMetadata/Google/Protobuf/Internal/Descriptor.php
@@ -31,7 +31,7 @@ class Descriptor
             ->optional('options', \Google\Protobuf\Internal\GPBType::MESSAGE, 8, 'google.protobuf.internal.FileOptions')
             ->optional('source_code_info', \Google\Protobuf\Internal\GPBType::MESSAGE, 9, 'google.protobuf.internal.SourceCodeInfo')
             ->optional('syntax', \Google\Protobuf\Internal\GPBType::STRING, 12)
-            ->optional('edition', \Google\Protobuf\Internal\GPBType::STRING, 13)
+            ->optional('edition', \Google\Protobuf\Internal\GPBType::ENUM, 14, 'google.protobuf.internal.Edition')
             ->finalizeToPool();
 
         $pool->addMessage('google.protobuf.internal.DescriptorProto', \Google\Protobuf\Internal\DescriptorProto::class)
@@ -60,6 +60,22 @@ class Descriptor
 
         $pool->addMessage('google.protobuf.internal.ExtensionRangeOptions', \Google\Protobuf\Internal\ExtensionRangeOptions::class)
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
+            ->repeated('declaration', \Google\Protobuf\Internal\GPBType::MESSAGE, 2, 'google.protobuf.internal.ExtensionRangeOptions.Declaration')
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 50, 'google.protobuf.internal.FeatureSet')
+            ->optional('verification', \Google\Protobuf\Internal\GPBType::ENUM, 3, 'google.protobuf.internal.ExtensionRangeOptions.VerificationState')
+            ->finalizeToPool();
+
+        $pool->addMessage('google.protobuf.internal.ExtensionRangeOptions.Declaration', \Google\Protobuf\Internal\ExtensionRangeOptions\Declaration::class)
+            ->optional('number', \Google\Protobuf\Internal\GPBType::INT32, 1)
+            ->optional('full_name', \Google\Protobuf\Internal\GPBType::STRING, 2)
+            ->optional('type', \Google\Protobuf\Internal\GPBType::STRING, 3)
+            ->optional('reserved', \Google\Protobuf\Internal\GPBType::BOOL, 5)
+            ->optional('repeated', \Google\Protobuf\Internal\GPBType::BOOL, 6)
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.ExtensionRangeOptions.VerificationState', \Google\Protobuf\Internal\VerificationState::class)
+            ->value("DECLARATION", 0)
+            ->value("UNVERIFIED", 1)
             ->finalizeToPool();
 
         $pool->addMessage('google.protobuf.internal.FieldDescriptorProto', \Google\Protobuf\Internal\FieldDescriptorProto::class)
@@ -99,8 +115,8 @@ class Descriptor
 
         $pool->addEnum('google.protobuf.internal.FieldDescriptorProto.Label', \Google\Protobuf\Internal\Label::class)
             ->value("LABEL_OPTIONAL", 1)
-            ->value("LABEL_REQUIRED", 2)
             ->value("LABEL_REPEATED", 3)
+            ->value("LABEL_REQUIRED", 2)
             ->finalizeToPool();
 
         $pool->addMessage('google.protobuf.internal.OneofDescriptorProto', \Google\Protobuf\Internal\OneofDescriptorProto::class)
@@ -156,6 +172,7 @@ class Descriptor
             ->optional('php_generic_services', \Google\Protobuf\Internal\GPBType::BOOL, 42)
             ->optional('deprecated', \Google\Protobuf\Internal\GPBType::BOOL, 23)
             ->optional('cc_enable_arenas', \Google\Protobuf\Internal\GPBType::BOOL, 31)
+            ->optional('cc_mutable_donated_string', \Google\Protobuf\Internal\GPBType::BOOL, 32)
             ->optional('objc_class_prefix', \Google\Protobuf\Internal\GPBType::STRING, 36)
             ->optional('csharp_namespace', \Google\Protobuf\Internal\GPBType::STRING, 37)
             ->optional('swift_prefix', \Google\Protobuf\Internal\GPBType::STRING, 39)
@@ -163,6 +180,7 @@ class Descriptor
             ->optional('php_namespace', \Google\Protobuf\Internal\GPBType::STRING, 41)
             ->optional('php_metadata_namespace', \Google\Protobuf\Internal\GPBType::STRING, 44)
             ->optional('ruby_package', \Google\Protobuf\Internal\GPBType::STRING, 45)
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 50, 'google.protobuf.internal.FeatureSet')
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
             ->finalizeToPool();
 
@@ -178,6 +196,7 @@ class Descriptor
             ->optional('deprecated', \Google\Protobuf\Internal\GPBType::BOOL, 3)
             ->optional('map_entry', \Google\Protobuf\Internal\GPBType::BOOL, 7)
             ->optional('deprecated_legacy_json_field_conflicts', \Google\Protobuf\Internal\GPBType::BOOL, 11)
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 12, 'google.protobuf.internal.FeatureSet')
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
             ->finalizeToPool();
 
@@ -189,9 +208,19 @@ class Descriptor
             ->optional('unverified_lazy', \Google\Protobuf\Internal\GPBType::BOOL, 15)
             ->optional('deprecated', \Google\Protobuf\Internal\GPBType::BOOL, 3)
             ->optional('weak', \Google\Protobuf\Internal\GPBType::BOOL, 10)
+            ->optional('debug_redact', \Google\Protobuf\Internal\GPBType::BOOL, 16)
+            ->optional('retention', \Google\Protobuf\Internal\GPBType::ENUM, 17, 'google.protobuf.internal.FieldOptions.OptionRetention')
+            ->repeated('targets', \Google\Protobuf\Internal\GPBType::ENUM, 19, 'google.protobuf.internal.FieldOptions.OptionTargetType')
+            ->repeated('edition_defaults', \Google\Protobuf\Internal\GPBType::MESSAGE, 20, 'google.protobuf.internal.FieldOptions.EditionDefault')
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 21, 'google.protobuf.internal.FeatureSet')
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
             ->finalizeToPool();
 
+        $pool->addMessage('google.protobuf.internal.FieldOptions.EditionDefault', \Google\Protobuf\Internal\FieldOptions\EditionDefault::class)
+            ->optional('edition', \Google\Protobuf\Internal\GPBType::ENUM, 3, 'google.protobuf.internal.Edition')
+            ->optional('value', \Google\Protobuf\Internal\GPBType::STRING, 2)
+            ->finalizeToPool();
+
         $pool->addEnum('google.protobuf.internal.FieldOptions.CType', \Google\Protobuf\Internal\CType::class)
             ->value("STRING", 0)
             ->value("CORD", 1)
@@ -204,7 +233,27 @@ class Descriptor
             ->value("JS_NUMBER", 2)
             ->finalizeToPool();
 
+        $pool->addEnum('google.protobuf.internal.FieldOptions.OptionRetention', \Google\Protobuf\Internal\OptionRetention::class)
+            ->value("RETENTION_UNKNOWN", 0)
+            ->value("RETENTION_RUNTIME", 1)
+            ->value("RETENTION_SOURCE", 2)
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.FieldOptions.OptionTargetType', \Google\Protobuf\Internal\OptionTargetType::class)
+            ->value("TARGET_TYPE_UNKNOWN", 0)
+            ->value("TARGET_TYPE_FILE", 1)
+            ->value("TARGET_TYPE_EXTENSION_RANGE", 2)
+            ->value("TARGET_TYPE_MESSAGE", 3)
+            ->value("TARGET_TYPE_FIELD", 4)
+            ->value("TARGET_TYPE_ONEOF", 5)
+            ->value("TARGET_TYPE_ENUM", 6)
+            ->value("TARGET_TYPE_ENUM_ENTRY", 7)
+            ->value("TARGET_TYPE_SERVICE", 8)
+            ->value("TARGET_TYPE_METHOD", 9)
+            ->finalizeToPool();
+
         $pool->addMessage('google.protobuf.internal.OneofOptions', \Google\Protobuf\Internal\OneofOptions::class)
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 1, 'google.protobuf.internal.FeatureSet')
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
             ->finalizeToPool();
 
@@ -212,15 +261,19 @@ class Descriptor
             ->optional('allow_alias', \Google\Protobuf\Internal\GPBType::BOOL, 2)
             ->optional('deprecated', \Google\Protobuf\Internal\GPBType::BOOL, 3)
             ->optional('deprecated_legacy_json_field_conflicts', \Google\Protobuf\Internal\GPBType::BOOL, 6)
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 7, 'google.protobuf.internal.FeatureSet')
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
             ->finalizeToPool();
 
         $pool->addMessage('google.protobuf.internal.EnumValueOptions', \Google\Protobuf\Internal\EnumValueOptions::class)
             ->optional('deprecated', \Google\Protobuf\Internal\GPBType::BOOL, 1)
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 2, 'google.protobuf.internal.FeatureSet')
+            ->optional('debug_redact', \Google\Protobuf\Internal\GPBType::BOOL, 3)
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
             ->finalizeToPool();
 
         $pool->addMessage('google.protobuf.internal.ServiceOptions', \Google\Protobuf\Internal\ServiceOptions::class)
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 34, 'google.protobuf.internal.FeatureSet')
             ->optional('deprecated', \Google\Protobuf\Internal\GPBType::BOOL, 33)
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
             ->finalizeToPool();
@@ -228,6 +281,7 @@ class Descriptor
         $pool->addMessage('google.protobuf.internal.MethodOptions', \Google\Protobuf\Internal\MethodOptions::class)
             ->optional('deprecated', \Google\Protobuf\Internal\GPBType::BOOL, 33)
             ->optional('idempotency_level', \Google\Protobuf\Internal\GPBType::ENUM, 34, 'google.protobuf.internal.MethodOptions.IdempotencyLevel')
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 35, 'google.protobuf.internal.FeatureSet')
             ->repeated('uninterpreted_option', \Google\Protobuf\Internal\GPBType::MESSAGE, 999, 'google.protobuf.internal.UninterpretedOption')
             ->finalizeToPool();
 
@@ -252,6 +306,63 @@ class Descriptor
             ->required('is_extension', \Google\Protobuf\Internal\GPBType::BOOL, 2)
             ->finalizeToPool();
 
+        $pool->addMessage('google.protobuf.internal.FeatureSet', \Google\Protobuf\Internal\FeatureSet::class)
+            ->optional('field_presence', \Google\Protobuf\Internal\GPBType::ENUM, 1, 'google.protobuf.internal.FeatureSet.FieldPresence')
+            ->optional('enum_type', \Google\Protobuf\Internal\GPBType::ENUM, 2, 'google.protobuf.internal.FeatureSet.EnumType')
+            ->optional('repeated_field_encoding', \Google\Protobuf\Internal\GPBType::ENUM, 3, 'google.protobuf.internal.FeatureSet.RepeatedFieldEncoding')
+            ->optional('utf8_validation', \Google\Protobuf\Internal\GPBType::ENUM, 4, 'google.protobuf.internal.FeatureSet.Utf8Validation')
+            ->optional('message_encoding', \Google\Protobuf\Internal\GPBType::ENUM, 5, 'google.protobuf.internal.FeatureSet.MessageEncoding')
+            ->optional('json_format', \Google\Protobuf\Internal\GPBType::ENUM, 6, 'google.protobuf.internal.FeatureSet.JsonFormat')
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.FeatureSet.FieldPresence', \Google\Protobuf\Internal\FieldPresence::class)
+            ->value("FIELD_PRESENCE_UNKNOWN", 0)
+            ->value("EXPLICIT", 1)
+            ->value("IMPLICIT", 2)
+            ->value("LEGACY_REQUIRED", 3)
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.FeatureSet.EnumType', \Google\Protobuf\Internal\EnumType::class)
+            ->value("ENUM_TYPE_UNKNOWN", 0)
+            ->value("OPEN", 1)
+            ->value("CLOSED", 2)
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.FeatureSet.RepeatedFieldEncoding', \Google\Protobuf\Internal\RepeatedFieldEncoding::class)
+            ->value("REPEATED_FIELD_ENCODING_UNKNOWN", 0)
+            ->value("PACKED", 1)
+            ->value("EXPANDED", 2)
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.FeatureSet.Utf8Validation', \Google\Protobuf\Internal\Utf8Validation::class)
+            ->value("UTF8_VALIDATION_UNKNOWN", 0)
+            ->value("NONE", 1)
+            ->value("VERIFY", 2)
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.FeatureSet.MessageEncoding', \Google\Protobuf\Internal\MessageEncoding::class)
+            ->value("MESSAGE_ENCODING_UNKNOWN", 0)
+            ->value("LENGTH_PREFIXED", 1)
+            ->value("DELIMITED", 2)
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.FeatureSet.JsonFormat', \Google\Protobuf\Internal\JsonFormat::class)
+            ->value("JSON_FORMAT_UNKNOWN", 0)
+            ->value("ALLOW", 1)
+            ->value("LEGACY_BEST_EFFORT", 2)
+            ->finalizeToPool();
+
+        $pool->addMessage('google.protobuf.internal.FeatureSetDefaults', \Google\Protobuf\Internal\FeatureSetDefaults::class)
+            ->repeated('defaults', \Google\Protobuf\Internal\GPBType::MESSAGE, 1, 'google.protobuf.internal.FeatureSetDefaults.FeatureSetEditionDefault')
+            ->optional('minimum_edition', \Google\Protobuf\Internal\GPBType::ENUM, 4, 'google.protobuf.internal.Edition')
+            ->optional('maximum_edition', \Google\Protobuf\Internal\GPBType::ENUM, 5, 'google.protobuf.internal.Edition')
+            ->finalizeToPool();
+
+        $pool->addMessage('google.protobuf.internal.FeatureSetDefaults.FeatureSetEditionDefault', \Google\Protobuf\Internal\FeatureSetDefaults\FeatureSetEditionDefault::class)
+            ->optional('edition', \Google\Protobuf\Internal\GPBType::ENUM, 3, 'google.protobuf.internal.Edition')
+            ->optional('features', \Google\Protobuf\Internal\GPBType::MESSAGE, 2, 'google.protobuf.internal.FeatureSet')
+            ->finalizeToPool();
+
         $pool->addMessage('google.protobuf.internal.SourceCodeInfo', \Google\Protobuf\Internal\SourceCodeInfo::class)
             ->repeated('location', \Google\Protobuf\Internal\GPBType::MESSAGE, 1, 'google.protobuf.internal.SourceCodeInfo.Location')
             ->finalizeToPool();
@@ -273,6 +384,25 @@ class Descriptor
             ->optional('source_file', \Google\Protobuf\Internal\GPBType::STRING, 2)
             ->optional('begin', \Google\Protobuf\Internal\GPBType::INT32, 3)
             ->optional('end', \Google\Protobuf\Internal\GPBType::INT32, 4)
+            ->optional('semantic', \Google\Protobuf\Internal\GPBType::ENUM, 5, 'google.protobuf.internal.GeneratedCodeInfo.Annotation.Semantic')
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.GeneratedCodeInfo.Annotation.Semantic', \Google\Protobuf\Internal\Semantic::class)
+            ->value("NONE", 0)
+            ->value("SET", 1)
+            ->value("ALIAS", 2)
+            ->finalizeToPool();
+
+        $pool->addEnum('google.protobuf.internal.Edition', \Google\Protobuf\Internal\Edition::class)
+            ->value("EDITION_UNKNOWN", 0)
+            ->value("EDITION_PROTO2", 998)
+            ->value("EDITION_PROTO3", 999)
+            ->value("EDITION_2023", 1000)
+            ->value("EDITION_1_TEST_ONLY", 1)
+            ->value("EDITION_2_TEST_ONLY", 2)
+            ->value("EDITION_99997_TEST_ONLY", 99997)
+            ->value("EDITION_99998_TEST_ONLY", 99998)
+            ->value("EDITION_99999_TEST_ONLY", 99999)
             ->finalizeToPool();
 
         $pool->finish();
diff --git a/php/src/GPBMetadata/Google/Protobuf/Type.php b/php/src/GPBMetadata/Google/Protobuf/Type.php
index 7d0bfbb53..32a6a4d1a 100644
Binary files a/php/src/GPBMetadata/Google/Protobuf/Type.php and b/php/src/GPBMetadata/Google/Protobuf/Type.php differ
diff --git a/php/src/Google/Protobuf/Any.php b/php/src/Google/Protobuf/Any.php
index feea41aad..30a7f7aaa 100644
--- a/php/src/Google/Protobuf/Any.php
+++ b/php/src/Google/Protobuf/Any.php
@@ -32,7 +32,7 @@ use Google\Protobuf\Internal\GPBUtil;
  *     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
  *       foo = any.unpack(Foo.getDefaultInstance());
  *     }
- * Example 3: Pack and unpack a message in Python.
+ *  Example 3: Pack and unpack a message in Python.
  *     foo = Foo(...)
  *     any = Any()
  *     any.Pack(foo)
@@ -40,7 +40,7 @@ use Google\Protobuf\Internal\GPBUtil;
  *     if any.Is(Foo.DESCRIPTOR):
  *       any.Unpack(foo)
  *       ...
- * Example 4: Pack and unpack a message in Go
+ *  Example 4: Pack and unpack a message in Go
  *      foo := &pb.Foo{...}
  *      any, err := anypb.New(foo)
  *      if err != nil {
@@ -57,6 +57,7 @@ use Google\Protobuf\Internal\GPBUtil;
  * in the type URL, for example "foo.bar.com/x/y.z" will yield type
  * name "y.z".
  * JSON
+ * ====
  * The JSON representation of an `Any` value uses the regular
  * representation of the deserialized, embedded message, with an
  * additional field `&#64;type` which contains the type URL. Example:
@@ -104,7 +105,8 @@ class Any extends \Google\Protobuf\Internal\AnyBase
      *   breaking changes.)
      * Note: this functionality is not currently available in the official
      * protobuf release, and it is not used for type URLs beginning with
-     * type.googleapis.com.
+     * type.googleapis.com. As of May 2023, there are no widely used type server
+     * implementations and no plans to implement one.
      * Schemes other than `http`, `https` (or the empty scheme) might be
      * used with implementation specific semantics.
      *
@@ -145,7 +147,8 @@ class Any extends \Google\Protobuf\Internal\AnyBase
      *             breaking changes.)
      *           Note: this functionality is not currently available in the official
      *           protobuf release, and it is not used for type URLs beginning with
-     *           type.googleapis.com.
+     *           type.googleapis.com. As of May 2023, there are no widely used type server
+     *           implementations and no plans to implement one.
      *           Schemes other than `http`, `https` (or the empty scheme) might be
      *           used with implementation specific semantics.
      *     @type string $value
@@ -178,7 +181,8 @@ class Any extends \Google\Protobuf\Internal\AnyBase
      *   breaking changes.)
      * Note: this functionality is not currently available in the official
      * protobuf release, and it is not used for type URLs beginning with
-     * type.googleapis.com.
+     * type.googleapis.com. As of May 2023, there are no widely used type server
+     * implementations and no plans to implement one.
      * Schemes other than `http`, `https` (or the empty scheme) might be
      * used with implementation specific semantics.
      *
@@ -211,7 +215,8 @@ class Any extends \Google\Protobuf\Internal\AnyBase
      *   breaking changes.)
      * Note: this functionality is not currently available in the official
      * protobuf release, and it is not used for type URLs beginning with
-     * type.googleapis.com.
+     * type.googleapis.com. As of May 2023, there are no widely used type server
+     * implementations and no plans to implement one.
      * Schemes other than `http`, `https` (or the empty scheme) might be
      * used with implementation specific semantics.
      *
diff --git a/php/src/Google/Protobuf/Enum.php b/php/src/Google/Protobuf/Enum.php
index 185e54e03..7fde7b2e8 100644
--- a/php/src/Google/Protobuf/Enum.php
+++ b/php/src/Google/Protobuf/Enum.php
@@ -45,6 +45,12 @@ class Enum extends \Google\Protobuf\Internal\Message
      * Generated from protobuf field <code>.google.protobuf.Syntax syntax = 5;</code>
      */
     protected $syntax = 0;
+    /**
+     * The source edition string, only valid when syntax is SYNTAX_EDITIONS.
+     *
+     * Generated from protobuf field <code>string edition = 6;</code>
+     */
+    protected $edition = '';
 
     /**
      * Constructor.
@@ -62,6 +68,8 @@ class Enum extends \Google\Protobuf\Internal\Message
      *           The source context.
      *     @type int $syntax
      *           The source syntax.
+     *     @type string $edition
+     *           The source edition string, only valid when syntax is SYNTAX_EDITIONS.
      * }
      */
     public function __construct($data = NULL) {
@@ -209,5 +217,31 @@ class Enum extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * The source edition string, only valid when syntax is SYNTAX_EDITIONS.
+     *
+     * Generated from protobuf field <code>string edition = 6;</code>
+     * @return string
+     */
+    public function getEdition()
+    {
+        return $this->edition;
+    }
+
+    /**
+     * The source edition string, only valid when syntax is SYNTAX_EDITIONS.
+     *
+     * Generated from protobuf field <code>string edition = 6;</code>
+     * @param string $var
+     * @return $this
+     */
+    public function setEdition($var)
+    {
+        GPBUtil::checkString($var, True);
+        $this->edition = $var;
+
+        return $this;
+    }
+
 }
 
diff --git a/php/src/Google/Protobuf/Internal/Edition.php b/php/src/Google/Protobuf/Internal/Edition.php
new file mode 100644
index 000000000..4edbdba36
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/Edition.php
@@ -0,0 +1,99 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal;
+
+use UnexpectedValueException;
+
+/**
+ * The full set of known editions.
+ *
+ * Protobuf type <code>google.protobuf.Edition</code>
+ */
+class Edition
+{
+    /**
+     * A placeholder for an unknown edition value.
+     *
+     * Generated from protobuf enum <code>EDITION_UNKNOWN = 0;</code>
+     */
+    const EDITION_UNKNOWN = 0;
+    /**
+     * Legacy syntax "editions".  These pre-date editions, but behave much like
+     * distinct editions.  These can't be used to specify the edition of proto
+     * files, but feature definitions must supply proto2/proto3 defaults for
+     * backwards compatibility.
+     *
+     * Generated from protobuf enum <code>EDITION_PROTO2 = 998;</code>
+     */
+    const EDITION_PROTO2 = 998;
+    /**
+     * Generated from protobuf enum <code>EDITION_PROTO3 = 999;</code>
+     */
+    const EDITION_PROTO3 = 999;
+    /**
+     * Editions that have been released.  The specific values are arbitrary and
+     * should not be depended on, but they will always be time-ordered for easy
+     * comparison.
+     *
+     * Generated from protobuf enum <code>EDITION_2023 = 1000;</code>
+     */
+    const EDITION_2023 = 1000;
+    /**
+     * Placeholder editions for testing feature resolution.  These should not be
+     * used or relyed on outside of tests.
+     *
+     * Generated from protobuf enum <code>EDITION_1_TEST_ONLY = 1;</code>
+     */
+    const EDITION_1_TEST_ONLY = 1;
+    /**
+     * Generated from protobuf enum <code>EDITION_2_TEST_ONLY = 2;</code>
+     */
+    const EDITION_2_TEST_ONLY = 2;
+    /**
+     * Generated from protobuf enum <code>EDITION_99997_TEST_ONLY = 99997;</code>
+     */
+    const EDITION_99997_TEST_ONLY = 99997;
+    /**
+     * Generated from protobuf enum <code>EDITION_99998_TEST_ONLY = 99998;</code>
+     */
+    const EDITION_99998_TEST_ONLY = 99998;
+    /**
+     * Generated from protobuf enum <code>EDITION_99999_TEST_ONLY = 99999;</code>
+     */
+    const EDITION_99999_TEST_ONLY = 99999;
+
+    private static $valueToName = [
+        self::EDITION_UNKNOWN => 'EDITION_UNKNOWN',
+        self::EDITION_PROTO2 => 'EDITION_PROTO2',
+        self::EDITION_PROTO3 => 'EDITION_PROTO3',
+        self::EDITION_2023 => 'EDITION_2023',
+        self::EDITION_1_TEST_ONLY => 'EDITION_1_TEST_ONLY',
+        self::EDITION_2_TEST_ONLY => 'EDITION_2_TEST_ONLY',
+        self::EDITION_99997_TEST_ONLY => 'EDITION_99997_TEST_ONLY',
+        self::EDITION_99998_TEST_ONLY => 'EDITION_99998_TEST_ONLY',
+        self::EDITION_99999_TEST_ONLY => 'EDITION_99999_TEST_ONLY',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
diff --git a/php/src/Google/Protobuf/Internal/EnumOptions.php b/php/src/Google/Protobuf/Internal/EnumOptions.php
index 80cb7f275..9eac99e3d 100644
--- a/php/src/Google/Protobuf/Internal/EnumOptions.php
+++ b/php/src/Google/Protobuf/Internal/EnumOptions.php
@@ -43,6 +43,12 @@ class EnumOptions extends \Google\Protobuf\Internal\Message
      * @deprecated
      */
     protected $deprecated_legacy_json_field_conflicts = null;
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 7;</code>
+     */
+    protected $features = null;
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
@@ -71,6 +77,8 @@ class EnumOptions extends \Google\Protobuf\Internal\Message
      *           well.
      *           TODO Remove this legacy behavior once downstream teams have
      *           had time to migrate.
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
      *     @type array<\Google\Protobuf\Internal\UninterpretedOption>|\Google\Protobuf\Internal\RepeatedField $uninterpreted_option
      *           The parser stores options it doesn't recognize here. See above.
      * }
@@ -212,6 +220,42 @@ class EnumOptions extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 7;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 7;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
diff --git a/php/src/Google/Protobuf/Internal/EnumValueOptions.php b/php/src/Google/Protobuf/Internal/EnumValueOptions.php
index 2db7fceea..c3e292db5 100644
--- a/php/src/Google/Protobuf/Internal/EnumValueOptions.php
+++ b/php/src/Google/Protobuf/Internal/EnumValueOptions.php
@@ -24,6 +24,20 @@ class EnumValueOptions extends \Google\Protobuf\Internal\Message
      * Generated from protobuf field <code>optional bool deprecated = 1 [default = false];</code>
      */
     protected $deprecated = null;
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 2;</code>
+     */
+    protected $features = null;
+    /**
+     * Indicate that fields annotated with this enum value should not be printed
+     * out when using debug formats, e.g. when the field contains sensitive
+     * credentials.
+     *
+     * Generated from protobuf field <code>optional bool debug_redact = 3 [default = false];</code>
+     */
+    protected $debug_redact = null;
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
@@ -42,6 +56,12 @@ class EnumValueOptions extends \Google\Protobuf\Internal\Message
      *           Depending on the target platform, this can emit Deprecated annotations
      *           for the enum value, or it will be completely ignored; in the very least,
      *           this is a formalization for deprecating enum values.
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
+     *     @type bool $debug_redact
+     *           Indicate that fields annotated with this enum value should not be printed
+     *           out when using debug formats, e.g. when the field contains sensitive
+     *           credentials.
      *     @type array<\Google\Protobuf\Internal\UninterpretedOption>|\Google\Protobuf\Internal\RepeatedField $uninterpreted_option
      *           The parser stores options it doesn't recognize here. See above.
      * }
@@ -93,6 +113,82 @@ class EnumValueOptions extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 2;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 2;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
+    /**
+     * Indicate that fields annotated with this enum value should not be printed
+     * out when using debug formats, e.g. when the field contains sensitive
+     * credentials.
+     *
+     * Generated from protobuf field <code>optional bool debug_redact = 3 [default = false];</code>
+     * @return bool
+     */
+    public function getDebugRedact()
+    {
+        return isset($this->debug_redact) ? $this->debug_redact : false;
+    }
+
+    public function hasDebugRedact()
+    {
+        return isset($this->debug_redact);
+    }
+
+    public function clearDebugRedact()
+    {
+        unset($this->debug_redact);
+    }
+
+    /**
+     * Indicate that fields annotated with this enum value should not be printed
+     * out when using debug formats, e.g. when the field contains sensitive
+     * credentials.
+     *
+     * Generated from protobuf field <code>optional bool debug_redact = 3 [default = false];</code>
+     * @param bool $var
+     * @return $this
+     */
+    public function setDebugRedact($var)
+    {
+        GPBUtil::checkBool($var);
+        $this->debug_redact = $var;
+
+        return $this;
+    }
+
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
diff --git a/php/src/Google/Protobuf/Internal/ExtensionRangeOptions.php b/php/src/Google/Protobuf/Internal/ExtensionRangeOptions.php
index 245173c3d..068294fc6 100644
--- a/php/src/Google/Protobuf/Internal/ExtensionRangeOptions.php
+++ b/php/src/Google/Protobuf/Internal/ExtensionRangeOptions.php
@@ -21,6 +21,28 @@ class ExtensionRangeOptions extends \Google\Protobuf\Internal\Message
      * Generated from protobuf field <code>repeated .google.protobuf.UninterpretedOption uninterpreted_option = 999;</code>
      */
     private $uninterpreted_option;
+    /**
+     * For external users: DO NOT USE. We are in the process of open sourcing
+     * extension declaration and executing internal cleanups before it can be
+     * used externally.
+     *
+     * Generated from protobuf field <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
+     */
+    private $declaration;
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 50;</code>
+     */
+    protected $features = null;
+    /**
+     * The verification state of the range.
+     * TODO: flip the default to DECLARATION once all empty ranges
+     * are marked as UNVERIFIED.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
+     */
+    protected $verification = null;
 
     /**
      * Constructor.
@@ -30,6 +52,16 @@ class ExtensionRangeOptions extends \Google\Protobuf\Internal\Message
      *
      *     @type array<\Google\Protobuf\Internal\UninterpretedOption>|\Google\Protobuf\Internal\RepeatedField $uninterpreted_option
      *           The parser stores options it doesn't recognize here. See above.
+     *     @type array<\Google\Protobuf\Internal\ExtensionRangeOptions\Declaration>|\Google\Protobuf\Internal\RepeatedField $declaration
+     *           For external users: DO NOT USE. We are in the process of open sourcing
+     *           extension declaration and executing internal cleanups before it can be
+     *           used externally.
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
+     *     @type int $verification
+     *           The verification state of the range.
+     *           TODO: flip the default to DECLARATION once all empty ranges
+     *           are marked as UNVERIFIED.
      * }
      */
     public function __construct($data = NULL) {
@@ -63,5 +95,111 @@ class ExtensionRangeOptions extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * For external users: DO NOT USE. We are in the process of open sourcing
+     * extension declaration and executing internal cleanups before it can be
+     * used externally.
+     *
+     * Generated from protobuf field <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
+     * @return \Google\Protobuf\Internal\RepeatedField
+     */
+    public function getDeclaration()
+    {
+        return $this->declaration;
+    }
+
+    /**
+     * For external users: DO NOT USE. We are in the process of open sourcing
+     * extension declaration and executing internal cleanups before it can be
+     * used externally.
+     *
+     * Generated from protobuf field <code>repeated .google.protobuf.ExtensionRangeOptions.Declaration declaration = 2 [retention = RETENTION_SOURCE];</code>
+     * @param array<\Google\Protobuf\Internal\ExtensionRangeOptions\Declaration>|\Google\Protobuf\Internal\RepeatedField $var
+     * @return $this
+     */
+    public function setDeclaration($var)
+    {
+        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Google\Protobuf\Internal\ExtensionRangeOptions\Declaration::class);
+        $this->declaration = $arr;
+
+        return $this;
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 50;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 50;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
+    /**
+     * The verification state of the range.
+     * TODO: flip the default to DECLARATION once all empty ranges
+     * are marked as UNVERIFIED.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
+     * @return int
+     */
+    public function getVerification()
+    {
+        return isset($this->verification) ? $this->verification : 0;
+    }
+
+    public function hasVerification()
+    {
+        return isset($this->verification);
+    }
+
+    public function clearVerification()
+    {
+        unset($this->verification);
+    }
+
+    /**
+     * The verification state of the range.
+     * TODO: flip the default to DECLARATION once all empty ranges
+     * are marked as UNVERIFIED.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.ExtensionRangeOptions.VerificationState verification = 3 [default = UNVERIFIED];</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setVerification($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\ExtensionRangeOptions\VerificationState::class);
+        $this->verification = $var;
+
+        return $this;
+    }
+
 }
 
diff --git a/php/src/Google/Protobuf/Internal/ExtensionRangeOptions/Declaration.php b/php/src/Google/Protobuf/Internal/ExtensionRangeOptions/Declaration.php
new file mode 100644
index 000000000..49207045b
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/ExtensionRangeOptions/Declaration.php
@@ -0,0 +1,280 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\ExtensionRangeOptions;
+
+use Google\Protobuf\Internal\GPBType;
+use Google\Protobuf\Internal\GPBWire;
+use Google\Protobuf\Internal\RepeatedField;
+use Google\Protobuf\Internal\InputStream;
+use Google\Protobuf\Internal\GPBUtil;
+
+/**
+ * Generated from protobuf message <code>google.protobuf.ExtensionRangeOptions.Declaration</code>
+ */
+class Declaration extends \Google\Protobuf\Internal\Message
+{
+    /**
+     * The extension number declared within the extension range.
+     *
+     * Generated from protobuf field <code>optional int32 number = 1;</code>
+     */
+    protected $number = null;
+    /**
+     * The fully-qualified name of the extension field. There must be a leading
+     * dot in front of the full name.
+     *
+     * Generated from protobuf field <code>optional string full_name = 2;</code>
+     */
+    protected $full_name = null;
+    /**
+     * The fully-qualified type name of the extension field. Unlike
+     * Metadata.type, Declaration.type must have a leading dot for messages
+     * and enums.
+     *
+     * Generated from protobuf field <code>optional string type = 3;</code>
+     */
+    protected $type = null;
+    /**
+     * If true, indicates that the number is reserved in the extension range,
+     * and any extension field with the number will fail to compile. Set this
+     * when a declared extension field is deleted.
+     *
+     * Generated from protobuf field <code>optional bool reserved = 5;</code>
+     */
+    protected $reserved = null;
+    /**
+     * If true, indicates that the extension must be defined as repeated.
+     * Otherwise the extension must be defined as optional.
+     *
+     * Generated from protobuf field <code>optional bool repeated = 6;</code>
+     */
+    protected $repeated = null;
+
+    /**
+     * Constructor.
+     *
+     * @param array $data {
+     *     Optional. Data for populating the Message object.
+     *
+     *     @type int $number
+     *           The extension number declared within the extension range.
+     *     @type string $full_name
+     *           The fully-qualified name of the extension field. There must be a leading
+     *           dot in front of the full name.
+     *     @type string $type
+     *           The fully-qualified type name of the extension field. Unlike
+     *           Metadata.type, Declaration.type must have a leading dot for messages
+     *           and enums.
+     *     @type bool $reserved
+     *           If true, indicates that the number is reserved in the extension range,
+     *           and any extension field with the number will fail to compile. Set this
+     *           when a declared extension field is deleted.
+     *     @type bool $repeated
+     *           If true, indicates that the extension must be defined as repeated.
+     *           Otherwise the extension must be defined as optional.
+     * }
+     */
+    public function __construct($data = NULL) {
+        \GPBMetadata\Google\Protobuf\Internal\Descriptor::initOnce();
+        parent::__construct($data);
+    }
+
+    /**
+     * The extension number declared within the extension range.
+     *
+     * Generated from protobuf field <code>optional int32 number = 1;</code>
+     * @return int
+     */
+    public function getNumber()
+    {
+        return isset($this->number) ? $this->number : 0;
+    }
+
+    public function hasNumber()
+    {
+        return isset($this->number);
+    }
+
+    public function clearNumber()
+    {
+        unset($this->number);
+    }
+
+    /**
+     * The extension number declared within the extension range.
+     *
+     * Generated from protobuf field <code>optional int32 number = 1;</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setNumber($var)
+    {
+        GPBUtil::checkInt32($var);
+        $this->number = $var;
+
+        return $this;
+    }
+
+    /**
+     * The fully-qualified name of the extension field. There must be a leading
+     * dot in front of the full name.
+     *
+     * Generated from protobuf field <code>optional string full_name = 2;</code>
+     * @return string
+     */
+    public function getFullName()
+    {
+        return isset($this->full_name) ? $this->full_name : '';
+    }
+
+    public function hasFullName()
+    {
+        return isset($this->full_name);
+    }
+
+    public function clearFullName()
+    {
+        unset($this->full_name);
+    }
+
+    /**
+     * The fully-qualified name of the extension field. There must be a leading
+     * dot in front of the full name.
+     *
+     * Generated from protobuf field <code>optional string full_name = 2;</code>
+     * @param string $var
+     * @return $this
+     */
+    public function setFullName($var)
+    {
+        GPBUtil::checkString($var, True);
+        $this->full_name = $var;
+
+        return $this;
+    }
+
+    /**
+     * The fully-qualified type name of the extension field. Unlike
+     * Metadata.type, Declaration.type must have a leading dot for messages
+     * and enums.
+     *
+     * Generated from protobuf field <code>optional string type = 3;</code>
+     * @return string
+     */
+    public function getType()
+    {
+        return isset($this->type) ? $this->type : '';
+    }
+
+    public function hasType()
+    {
+        return isset($this->type);
+    }
+
+    public function clearType()
+    {
+        unset($this->type);
+    }
+
+    /**
+     * The fully-qualified type name of the extension field. Unlike
+     * Metadata.type, Declaration.type must have a leading dot for messages
+     * and enums.
+     *
+     * Generated from protobuf field <code>optional string type = 3;</code>
+     * @param string $var
+     * @return $this
+     */
+    public function setType($var)
+    {
+        GPBUtil::checkString($var, True);
+        $this->type = $var;
+
+        return $this;
+    }
+
+    /**
+     * If true, indicates that the number is reserved in the extension range,
+     * and any extension field with the number will fail to compile. Set this
+     * when a declared extension field is deleted.
+     *
+     * Generated from protobuf field <code>optional bool reserved = 5;</code>
+     * @return bool
+     */
+    public function getReserved()
+    {
+        return isset($this->reserved) ? $this->reserved : false;
+    }
+
+    public function hasReserved()
+    {
+        return isset($this->reserved);
+    }
+
+    public function clearReserved()
+    {
+        unset($this->reserved);
+    }
+
+    /**
+     * If true, indicates that the number is reserved in the extension range,
+     * and any extension field with the number will fail to compile. Set this
+     * when a declared extension field is deleted.
+     *
+     * Generated from protobuf field <code>optional bool reserved = 5;</code>
+     * @param bool $var
+     * @return $this
+     */
+    public function setReserved($var)
+    {
+        GPBUtil::checkBool($var);
+        $this->reserved = $var;
+
+        return $this;
+    }
+
+    /**
+     * If true, indicates that the extension must be defined as repeated.
+     * Otherwise the extension must be defined as optional.
+     *
+     * Generated from protobuf field <code>optional bool repeated = 6;</code>
+     * @return bool
+     */
+    public function getRepeated()
+    {
+        return isset($this->repeated) ? $this->repeated : false;
+    }
+
+    public function hasRepeated()
+    {
+        return isset($this->repeated);
+    }
+
+    public function clearRepeated()
+    {
+        unset($this->repeated);
+    }
+
+    /**
+     * If true, indicates that the extension must be defined as repeated.
+     * Otherwise the extension must be defined as optional.
+     *
+     * Generated from protobuf field <code>optional bool repeated = 6;</code>
+     * @param bool $var
+     * @return $this
+     */
+    public function setRepeated($var)
+    {
+        GPBUtil::checkBool($var);
+        $this->repeated = $var;
+
+        return $this;
+    }
+
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(Declaration::class, \Google\Protobuf\Internal\ExtensionRangeOptions_Declaration::class);
+
diff --git a/php/src/Google/Protobuf/Internal/ExtensionRangeOptions/VerificationState.php b/php/src/Google/Protobuf/Internal/ExtensionRangeOptions/VerificationState.php
new file mode 100644
index 000000000..8eaf8794d
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/ExtensionRangeOptions/VerificationState.php
@@ -0,0 +1,55 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\ExtensionRangeOptions;
+
+use UnexpectedValueException;
+
+/**
+ * The verification state of the extension range.
+ *
+ * Protobuf type <code>google.protobuf.ExtensionRangeOptions.VerificationState</code>
+ */
+class VerificationState
+{
+    /**
+     * All the extensions of the range must be declared.
+     *
+     * Generated from protobuf enum <code>DECLARATION = 0;</code>
+     */
+    const DECLARATION = 0;
+    /**
+     * Generated from protobuf enum <code>UNVERIFIED = 1;</code>
+     */
+    const UNVERIFIED = 1;
+
+    private static $valueToName = [
+        self::DECLARATION => 'DECLARATION',
+        self::UNVERIFIED => 'UNVERIFIED',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(VerificationState::class, \Google\Protobuf\Internal\ExtensionRangeOptions_VerificationState::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSet.php b/php/src/Google/Protobuf/Internal/FeatureSet.php
new file mode 100644
index 000000000..5be4a6f6f
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSet.php
@@ -0,0 +1,262 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal;
+
+use Google\Protobuf\Internal\GPBType;
+use Google\Protobuf\Internal\GPBWire;
+use Google\Protobuf\Internal\RepeatedField;
+use Google\Protobuf\Internal\InputStream;
+use Google\Protobuf\Internal\GPBUtil;
+
+/**
+ * TODO Enums in C++ gencode (and potentially other languages) are
+ * not well scoped.  This means that each of the feature enums below can clash
+ * with each other.  The short names we've chosen maximize call-site
+ * readability, but leave us very open to this scenario.  A future feature will
+ * be designed and implemented to handle this, hopefully before we ever hit a
+ * conflict here.
+ *
+ * Generated from protobuf message <code>google.protobuf.FeatureSet</code>
+ */
+class FeatureSet extends \Google\Protobuf\Internal\Message
+{
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     */
+    protected $field_presence = null;
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     */
+    protected $enum_type = null;
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     */
+    protected $repeated_field_encoding = null;
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.Utf8Validation utf8_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     */
+    protected $utf8_validation = null;
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     */
+    protected $message_encoding = null;
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     */
+    protected $json_format = null;
+
+    /**
+     * Constructor.
+     *
+     * @param array $data {
+     *     Optional. Data for populating the Message object.
+     *
+     *     @type int $field_presence
+     *     @type int $enum_type
+     *     @type int $repeated_field_encoding
+     *     @type int $utf8_validation
+     *     @type int $message_encoding
+     *     @type int $json_format
+     * }
+     */
+    public function __construct($data = NULL) {
+        \GPBMetadata\Google\Protobuf\Internal\Descriptor::initOnce();
+        parent::__construct($data);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @return int
+     */
+    public function getFieldPresence()
+    {
+        return isset($this->field_presence) ? $this->field_presence : 0;
+    }
+
+    public function hasFieldPresence()
+    {
+        return isset($this->field_presence);
+    }
+
+    public function clearFieldPresence()
+    {
+        unset($this->field_presence);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.FieldPresence field_presence = 1 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setFieldPresence($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\FeatureSet\FieldPresence::class);
+        $this->field_presence = $var;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @return int
+     */
+    public function getEnumType()
+    {
+        return isset($this->enum_type) ? $this->enum_type : 0;
+    }
+
+    public function hasEnumType()
+    {
+        return isset($this->enum_type);
+    }
+
+    public function clearEnumType()
+    {
+        unset($this->enum_type);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.EnumType enum_type = 2 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setEnumType($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\FeatureSet\EnumType::class);
+        $this->enum_type = $var;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @return int
+     */
+    public function getRepeatedFieldEncoding()
+    {
+        return isset($this->repeated_field_encoding) ? $this->repeated_field_encoding : 0;
+    }
+
+    public function hasRepeatedFieldEncoding()
+    {
+        return isset($this->repeated_field_encoding);
+    }
+
+    public function clearRepeatedFieldEncoding()
+    {
+        unset($this->repeated_field_encoding);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.RepeatedFieldEncoding repeated_field_encoding = 3 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setRepeatedFieldEncoding($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\FeatureSet\RepeatedFieldEncoding::class);
+        $this->repeated_field_encoding = $var;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.Utf8Validation utf8_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @return int
+     */
+    public function getUtf8Validation()
+    {
+        return isset($this->utf8_validation) ? $this->utf8_validation : 0;
+    }
+
+    public function hasUtf8Validation()
+    {
+        return isset($this->utf8_validation);
+    }
+
+    public function clearUtf8Validation()
+    {
+        unset($this->utf8_validation);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.Utf8Validation utf8_validation = 4 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setUtf8Validation($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\FeatureSet\Utf8Validation::class);
+        $this->utf8_validation = $var;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @return int
+     */
+    public function getMessageEncoding()
+    {
+        return isset($this->message_encoding) ? $this->message_encoding : 0;
+    }
+
+    public function hasMessageEncoding()
+    {
+        return isset($this->message_encoding);
+    }
+
+    public function clearMessageEncoding()
+    {
+        unset($this->message_encoding);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.MessageEncoding message_encoding = 5 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_FIELD, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setMessageEncoding($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\FeatureSet\MessageEncoding::class);
+        $this->message_encoding = $var;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @return int
+     */
+    public function getJsonFormat()
+    {
+        return isset($this->json_format) ? $this->json_format : 0;
+    }
+
+    public function hasJsonFormat()
+    {
+        return isset($this->json_format);
+    }
+
+    public function clearJsonFormat()
+    {
+        unset($this->json_format);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet.JsonFormat json_format = 6 [retention = RETENTION_RUNTIME, targets = TARGET_TYPE_MESSAGE, targets = TARGET_TYPE_ENUM, targets = TARGET_TYPE_FILE, edition_defaults = {</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setJsonFormat($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\FeatureSet\JsonFormat::class);
+        $this->json_format = $var;
+
+        return $this;
+    }
+
+}
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSet/EnumType.php b/php/src/Google/Protobuf/Internal/FeatureSet/EnumType.php
new file mode 100644
index 000000000..d9f722dd7
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSet/EnumType.php
@@ -0,0 +1,56 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FeatureSet;
+
+use UnexpectedValueException;
+
+/**
+ * Protobuf type <code>google.protobuf.FeatureSet.EnumType</code>
+ */
+class EnumType
+{
+    /**
+     * Generated from protobuf enum <code>ENUM_TYPE_UNKNOWN = 0;</code>
+     */
+    const ENUM_TYPE_UNKNOWN = 0;
+    /**
+     * Generated from protobuf enum <code>OPEN = 1;</code>
+     */
+    const OPEN = 1;
+    /**
+     * Generated from protobuf enum <code>CLOSED = 2;</code>
+     */
+    const CLOSED = 2;
+
+    private static $valueToName = [
+        self::ENUM_TYPE_UNKNOWN => 'ENUM_TYPE_UNKNOWN',
+        self::OPEN => 'OPEN',
+        self::CLOSED => 'CLOSED',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(EnumType::class, \Google\Protobuf\Internal\FeatureSet_EnumType::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSet/FieldPresence.php b/php/src/Google/Protobuf/Internal/FeatureSet/FieldPresence.php
new file mode 100644
index 000000000..8e6a0a9a0
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSet/FieldPresence.php
@@ -0,0 +1,61 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FeatureSet;
+
+use UnexpectedValueException;
+
+/**
+ * Protobuf type <code>google.protobuf.FeatureSet.FieldPresence</code>
+ */
+class FieldPresence
+{
+    /**
+     * Generated from protobuf enum <code>FIELD_PRESENCE_UNKNOWN = 0;</code>
+     */
+    const FIELD_PRESENCE_UNKNOWN = 0;
+    /**
+     * Generated from protobuf enum <code>EXPLICIT = 1;</code>
+     */
+    const EXPLICIT = 1;
+    /**
+     * Generated from protobuf enum <code>IMPLICIT = 2;</code>
+     */
+    const IMPLICIT = 2;
+    /**
+     * Generated from protobuf enum <code>LEGACY_REQUIRED = 3;</code>
+     */
+    const LEGACY_REQUIRED = 3;
+
+    private static $valueToName = [
+        self::FIELD_PRESENCE_UNKNOWN => 'FIELD_PRESENCE_UNKNOWN',
+        self::EXPLICIT => 'EXPLICIT',
+        self::IMPLICIT => 'IMPLICIT',
+        self::LEGACY_REQUIRED => 'LEGACY_REQUIRED',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(FieldPresence::class, \Google\Protobuf\Internal\FeatureSet_FieldPresence::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSet/JsonFormat.php b/php/src/Google/Protobuf/Internal/FeatureSet/JsonFormat.php
new file mode 100644
index 000000000..771afcaca
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSet/JsonFormat.php
@@ -0,0 +1,56 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FeatureSet;
+
+use UnexpectedValueException;
+
+/**
+ * Protobuf type <code>google.protobuf.FeatureSet.JsonFormat</code>
+ */
+class JsonFormat
+{
+    /**
+     * Generated from protobuf enum <code>JSON_FORMAT_UNKNOWN = 0;</code>
+     */
+    const JSON_FORMAT_UNKNOWN = 0;
+    /**
+     * Generated from protobuf enum <code>ALLOW = 1;</code>
+     */
+    const ALLOW = 1;
+    /**
+     * Generated from protobuf enum <code>LEGACY_BEST_EFFORT = 2;</code>
+     */
+    const LEGACY_BEST_EFFORT = 2;
+
+    private static $valueToName = [
+        self::JSON_FORMAT_UNKNOWN => 'JSON_FORMAT_UNKNOWN',
+        self::ALLOW => 'ALLOW',
+        self::LEGACY_BEST_EFFORT => 'LEGACY_BEST_EFFORT',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(JsonFormat::class, \Google\Protobuf\Internal\FeatureSet_JsonFormat::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSet/MessageEncoding.php b/php/src/Google/Protobuf/Internal/FeatureSet/MessageEncoding.php
new file mode 100644
index 000000000..7c1aa04de
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSet/MessageEncoding.php
@@ -0,0 +1,56 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FeatureSet;
+
+use UnexpectedValueException;
+
+/**
+ * Protobuf type <code>google.protobuf.FeatureSet.MessageEncoding</code>
+ */
+class MessageEncoding
+{
+    /**
+     * Generated from protobuf enum <code>MESSAGE_ENCODING_UNKNOWN = 0;</code>
+     */
+    const MESSAGE_ENCODING_UNKNOWN = 0;
+    /**
+     * Generated from protobuf enum <code>LENGTH_PREFIXED = 1;</code>
+     */
+    const LENGTH_PREFIXED = 1;
+    /**
+     * Generated from protobuf enum <code>DELIMITED = 2;</code>
+     */
+    const DELIMITED = 2;
+
+    private static $valueToName = [
+        self::MESSAGE_ENCODING_UNKNOWN => 'MESSAGE_ENCODING_UNKNOWN',
+        self::LENGTH_PREFIXED => 'LENGTH_PREFIXED',
+        self::DELIMITED => 'DELIMITED',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(MessageEncoding::class, \Google\Protobuf\Internal\FeatureSet_MessageEncoding::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSet/RepeatedFieldEncoding.php b/php/src/Google/Protobuf/Internal/FeatureSet/RepeatedFieldEncoding.php
new file mode 100644
index 000000000..a1bdf749d
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSet/RepeatedFieldEncoding.php
@@ -0,0 +1,56 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FeatureSet;
+
+use UnexpectedValueException;
+
+/**
+ * Protobuf type <code>google.protobuf.FeatureSet.RepeatedFieldEncoding</code>
+ */
+class RepeatedFieldEncoding
+{
+    /**
+     * Generated from protobuf enum <code>REPEATED_FIELD_ENCODING_UNKNOWN = 0;</code>
+     */
+    const REPEATED_FIELD_ENCODING_UNKNOWN = 0;
+    /**
+     * Generated from protobuf enum <code>PACKED = 1;</code>
+     */
+    const PACKED = 1;
+    /**
+     * Generated from protobuf enum <code>EXPANDED = 2;</code>
+     */
+    const EXPANDED = 2;
+
+    private static $valueToName = [
+        self::REPEATED_FIELD_ENCODING_UNKNOWN => 'REPEATED_FIELD_ENCODING_UNKNOWN',
+        self::PACKED => 'PACKED',
+        self::EXPANDED => 'EXPANDED',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(RepeatedFieldEncoding::class, \Google\Protobuf\Internal\FeatureSet_RepeatedFieldEncoding::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSet/Utf8Validation.php b/php/src/Google/Protobuf/Internal/FeatureSet/Utf8Validation.php
new file mode 100644
index 000000000..ec1fcc8bb
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSet/Utf8Validation.php
@@ -0,0 +1,56 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FeatureSet;
+
+use UnexpectedValueException;
+
+/**
+ * Protobuf type <code>google.protobuf.FeatureSet.Utf8Validation</code>
+ */
+class Utf8Validation
+{
+    /**
+     * Generated from protobuf enum <code>UTF8_VALIDATION_UNKNOWN = 0;</code>
+     */
+    const UTF8_VALIDATION_UNKNOWN = 0;
+    /**
+     * Generated from protobuf enum <code>NONE = 1;</code>
+     */
+    const NONE = 1;
+    /**
+     * Generated from protobuf enum <code>VERIFY = 2;</code>
+     */
+    const VERIFY = 2;
+
+    private static $valueToName = [
+        self::UTF8_VALIDATION_UNKNOWN => 'UTF8_VALIDATION_UNKNOWN',
+        self::NONE => 'NONE',
+        self::VERIFY => 'VERIFY',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(Utf8Validation::class, \Google\Protobuf\Internal\FeatureSet_Utf8Validation::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSetDefaults.php b/php/src/Google/Protobuf/Internal/FeatureSetDefaults.php
new file mode 100644
index 000000000..dd9da7ae8
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSetDefaults.php
@@ -0,0 +1,161 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal;
+
+use Google\Protobuf\Internal\GPBType;
+use Google\Protobuf\Internal\GPBWire;
+use Google\Protobuf\Internal\RepeatedField;
+use Google\Protobuf\Internal\InputStream;
+use Google\Protobuf\Internal\GPBUtil;
+
+/**
+ * A compiled specification for the defaults of a set of features.  These
+ * messages are generated from FeatureSet extensions and can be used to seed
+ * feature resolution. The resolution with this object becomes a simple search
+ * for the closest matching edition, followed by proto merges.
+ *
+ * Generated from protobuf message <code>google.protobuf.FeatureSetDefaults</code>
+ */
+class FeatureSetDefaults extends \Google\Protobuf\Internal\Message
+{
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault defaults = 1;</code>
+     */
+    private $defaults;
+    /**
+     * The minimum supported edition (inclusive) when this was constructed.
+     * Editions before this will not have defaults.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.Edition minimum_edition = 4;</code>
+     */
+    protected $minimum_edition = null;
+    /**
+     * The maximum known edition (inclusive) when this was constructed. Editions
+     * after this will not have reliable defaults.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.Edition maximum_edition = 5;</code>
+     */
+    protected $maximum_edition = null;
+
+    /**
+     * Constructor.
+     *
+     * @param array $data {
+     *     Optional. Data for populating the Message object.
+     *
+     *     @type array<\Google\Protobuf\Internal\FeatureSetDefaults\FeatureSetEditionDefault>|\Google\Protobuf\Internal\RepeatedField $defaults
+     *     @type int $minimum_edition
+     *           The minimum supported edition (inclusive) when this was constructed.
+     *           Editions before this will not have defaults.
+     *     @type int $maximum_edition
+     *           The maximum known edition (inclusive) when this was constructed. Editions
+     *           after this will not have reliable defaults.
+     * }
+     */
+    public function __construct($data = NULL) {
+        \GPBMetadata\Google\Protobuf\Internal\Descriptor::initOnce();
+        parent::__construct($data);
+    }
+
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault defaults = 1;</code>
+     * @return \Google\Protobuf\Internal\RepeatedField
+     */
+    public function getDefaults()
+    {
+        return $this->defaults;
+    }
+
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault defaults = 1;</code>
+     * @param array<\Google\Protobuf\Internal\FeatureSetDefaults\FeatureSetEditionDefault>|\Google\Protobuf\Internal\RepeatedField $var
+     * @return $this
+     */
+    public function setDefaults($var)
+    {
+        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Google\Protobuf\Internal\FeatureSetDefaults\FeatureSetEditionDefault::class);
+        $this->defaults = $arr;
+
+        return $this;
+    }
+
+    /**
+     * The minimum supported edition (inclusive) when this was constructed.
+     * Editions before this will not have defaults.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.Edition minimum_edition = 4;</code>
+     * @return int
+     */
+    public function getMinimumEdition()
+    {
+        return isset($this->minimum_edition) ? $this->minimum_edition : 0;
+    }
+
+    public function hasMinimumEdition()
+    {
+        return isset($this->minimum_edition);
+    }
+
+    public function clearMinimumEdition()
+    {
+        unset($this->minimum_edition);
+    }
+
+    /**
+     * The minimum supported edition (inclusive) when this was constructed.
+     * Editions before this will not have defaults.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.Edition minimum_edition = 4;</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setMinimumEdition($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\Edition::class);
+        $this->minimum_edition = $var;
+
+        return $this;
+    }
+
+    /**
+     * The maximum known edition (inclusive) when this was constructed. Editions
+     * after this will not have reliable defaults.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.Edition maximum_edition = 5;</code>
+     * @return int
+     */
+    public function getMaximumEdition()
+    {
+        return isset($this->maximum_edition) ? $this->maximum_edition : 0;
+    }
+
+    public function hasMaximumEdition()
+    {
+        return isset($this->maximum_edition);
+    }
+
+    public function clearMaximumEdition()
+    {
+        unset($this->maximum_edition);
+    }
+
+    /**
+     * The maximum known edition (inclusive) when this was constructed. Editions
+     * after this will not have reliable defaults.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.Edition maximum_edition = 5;</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setMaximumEdition($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\Edition::class);
+        $this->maximum_edition = $var;
+
+        return $this;
+    }
+
+}
+
diff --git a/php/src/Google/Protobuf/Internal/FeatureSetDefaults/FeatureSetEditionDefault.php b/php/src/Google/Protobuf/Internal/FeatureSetDefaults/FeatureSetEditionDefault.php
new file mode 100644
index 000000000..06bad8bfb
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FeatureSetDefaults/FeatureSetEditionDefault.php
@@ -0,0 +1,115 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FeatureSetDefaults;
+
+use Google\Protobuf\Internal\GPBType;
+use Google\Protobuf\Internal\GPBWire;
+use Google\Protobuf\Internal\RepeatedField;
+use Google\Protobuf\Internal\InputStream;
+use Google\Protobuf\Internal\GPBUtil;
+
+/**
+ * A map from every known edition with a unique set of defaults to its
+ * defaults. Not all editions may be contained here.  For a given edition,
+ * the defaults at the closest matching edition ordered at or before it should
+ * be used.  This field must be in strict ascending order by edition.
+ *
+ * Generated from protobuf message <code>google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault</code>
+ */
+class FeatureSetEditionDefault extends \Google\Protobuf\Internal\Message
+{
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 3;</code>
+     */
+    protected $edition = null;
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 2;</code>
+     */
+    protected $features = null;
+
+    /**
+     * Constructor.
+     *
+     * @param array $data {
+     *     Optional. Data for populating the Message object.
+     *
+     *     @type int $edition
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     * }
+     */
+    public function __construct($data = NULL) {
+        \GPBMetadata\Google\Protobuf\Internal\Descriptor::initOnce();
+        parent::__construct($data);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 3;</code>
+     * @return int
+     */
+    public function getEdition()
+    {
+        return isset($this->edition) ? $this->edition : 0;
+    }
+
+    public function hasEdition()
+    {
+        return isset($this->edition);
+    }
+
+    public function clearEdition()
+    {
+        unset($this->edition);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 3;</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setEdition($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\Edition::class);
+        $this->edition = $var;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 2;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 2;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(FeatureSetEditionDefault::class, \Google\Protobuf\Internal\FeatureSetDefaults_FeatureSetEditionDefault::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FieldDescriptorProto/Label.php b/php/src/Google/Protobuf/Internal/FieldDescriptorProto/Label.php
index a54b228f1..6c0e5a5be 100644
--- a/php/src/Google/Protobuf/Internal/FieldDescriptorProto/Label.php
+++ b/php/src/Google/Protobuf/Internal/FieldDescriptorProto/Label.php
@@ -17,19 +17,23 @@ class Label
      * Generated from protobuf enum <code>LABEL_OPTIONAL = 1;</code>
      */
     const LABEL_OPTIONAL = 1;
-    /**
-     * Generated from protobuf enum <code>LABEL_REQUIRED = 2;</code>
-     */
-    const LABEL_REQUIRED = 2;
     /**
      * Generated from protobuf enum <code>LABEL_REPEATED = 3;</code>
      */
     const LABEL_REPEATED = 3;
+    /**
+     * The required label is only allowed in google.protobuf.  In proto3 and Editions
+     * it's explicitly prohibited.  In Editions, the `field_presence` feature
+     * can be used to get this behavior.
+     *
+     * Generated from protobuf enum <code>LABEL_REQUIRED = 2;</code>
+     */
+    const LABEL_REQUIRED = 2;
 
     private static $valueToName = [
         self::LABEL_OPTIONAL => 'LABEL_OPTIONAL',
-        self::LABEL_REQUIRED => 'LABEL_REQUIRED',
         self::LABEL_REPEATED => 'LABEL_REPEATED',
+        self::LABEL_REQUIRED => 'LABEL_REQUIRED',
     ];
 
     public static function name($value)
diff --git a/php/src/Google/Protobuf/Internal/FieldDescriptorProto/Type.php b/php/src/Google/Protobuf/Internal/FieldDescriptorProto/Type.php
index 6072e9990..14ff28b57 100644
--- a/php/src/Google/Protobuf/Internal/FieldDescriptorProto/Type.php
+++ b/php/src/Google/Protobuf/Internal/FieldDescriptorProto/Type.php
@@ -58,9 +58,10 @@ class Type
     const TYPE_STRING = 9;
     /**
      * Tag-delimited aggregate.
-     * Group type is deprecated and not supported in proto3. However, Proto3
+     * Group type is deprecated and not supported after google.protobuf. However, Proto3
      * implementations should still be able to parse the group wire format and
-     * treat group fields as unknown fields.
+     * treat group fields as unknown fields.  In Editions, the group wire format
+     * can be enabled via the `message_encoding` feature.
      *
      * Generated from protobuf enum <code>TYPE_GROUP = 10;</code>
      */
diff --git a/php/src/Google/Protobuf/Internal/FieldOptions.php b/php/src/Google/Protobuf/Internal/FieldOptions.php
index ea32e7f2a..cb13602f4 100644
--- a/php/src/Google/Protobuf/Internal/FieldOptions.php
+++ b/php/src/Google/Protobuf/Internal/FieldOptions.php
@@ -18,8 +18,10 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
     /**
      * The ctype option instructs the C++ code generator to use a different
      * representation of the field than it normally would.  See the specific
-     * options below.  This option is not yet implemented in the open source
-     * release -- sorry, we'll try to include it in a future version!
+     * options below.  This option is only implemented to support use of
+     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
+     * type "bytes" in the open source release -- sorry, we'll try to include
+     * other types in a future version!
      *
      * Generated from protobuf field <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
      */
@@ -29,7 +31,9 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
      * a more efficient representation on the wire. Rather than repeatedly
      * writing the tag and type for each element, the entire array is encoded as
      * a single length-delimited blob. In proto3, only explicit setting it to
-     * false will avoid using packed encoding.
+     * false will avoid using packed encoding.  This option is prohibited in
+     * Editions, but the `repeated_field_encoding` feature can be used to control
+     * the behavior.
      *
      * Generated from protobuf field <code>optional bool packed = 2;</code>
      */
@@ -103,6 +107,31 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
      * Generated from protobuf field <code>optional bool weak = 10 [default = false];</code>
      */
     protected $weak = null;
+    /**
+     * Indicate that the field value should not be printed out when using debug
+     * formats, e.g. when the field contains sensitive credentials.
+     *
+     * Generated from protobuf field <code>optional bool debug_redact = 16 [default = false];</code>
+     */
+    protected $debug_redact = null;
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
+     */
+    protected $retention = null;
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
+     */
+    private $targets;
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
+     */
+    private $edition_defaults;
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 21;</code>
+     */
+    protected $features = null;
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
@@ -119,14 +148,18 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
      *     @type int $ctype
      *           The ctype option instructs the C++ code generator to use a different
      *           representation of the field than it normally would.  See the specific
-     *           options below.  This option is not yet implemented in the open source
-     *           release -- sorry, we'll try to include it in a future version!
+     *           options below.  This option is only implemented to support use of
+     *           [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
+     *           type "bytes" in the open source release -- sorry, we'll try to include
+     *           other types in a future version!
      *     @type bool $packed
      *           The packed option can be enabled for repeated primitive fields to enable
      *           a more efficient representation on the wire. Rather than repeatedly
      *           writing the tag and type for each element, the entire array is encoded as
      *           a single length-delimited blob. In proto3, only explicit setting it to
-     *           false will avoid using packed encoding.
+     *           false will avoid using packed encoding.  This option is prohibited in
+     *           Editions, but the `repeated_field_encoding` feature can be used to control
+     *           the behavior.
      *     @type int $jstype
      *           The jstype option determines the JavaScript type used for values of the
      *           field.  The option is permitted only for 64 bit integral and fixed types
@@ -176,6 +209,14 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
      *           is a formalization for deprecating fields.
      *     @type bool $weak
      *           For Google-internal migration only. Do not use.
+     *     @type bool $debug_redact
+     *           Indicate that the field value should not be printed out when using debug
+     *           formats, e.g. when the field contains sensitive credentials.
+     *     @type int $retention
+     *     @type array<int>|\Google\Protobuf\Internal\RepeatedField $targets
+     *     @type array<\Google\Protobuf\Internal\FieldOptions\EditionDefault>|\Google\Protobuf\Internal\RepeatedField $edition_defaults
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
      *     @type array<\Google\Protobuf\Internal\UninterpretedOption>|\Google\Protobuf\Internal\RepeatedField $uninterpreted_option
      *           The parser stores options it doesn't recognize here. See above.
      * }
@@ -188,8 +229,10 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
     /**
      * The ctype option instructs the C++ code generator to use a different
      * representation of the field than it normally would.  See the specific
-     * options below.  This option is not yet implemented in the open source
-     * release -- sorry, we'll try to include it in a future version!
+     * options below.  This option is only implemented to support use of
+     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
+     * type "bytes" in the open source release -- sorry, we'll try to include
+     * other types in a future version!
      *
      * Generated from protobuf field <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
      * @return int
@@ -212,8 +255,10 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
     /**
      * The ctype option instructs the C++ code generator to use a different
      * representation of the field than it normally would.  See the specific
-     * options below.  This option is not yet implemented in the open source
-     * release -- sorry, we'll try to include it in a future version!
+     * options below.  This option is only implemented to support use of
+     * [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
+     * type "bytes" in the open source release -- sorry, we'll try to include
+     * other types in a future version!
      *
      * Generated from protobuf field <code>optional .google.protobuf.FieldOptions.CType ctype = 1 [default = STRING];</code>
      * @param int $var
@@ -232,7 +277,9 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
      * a more efficient representation on the wire. Rather than repeatedly
      * writing the tag and type for each element, the entire array is encoded as
      * a single length-delimited blob. In proto3, only explicit setting it to
-     * false will avoid using packed encoding.
+     * false will avoid using packed encoding.  This option is prohibited in
+     * Editions, but the `repeated_field_encoding` feature can be used to control
+     * the behavior.
      *
      * Generated from protobuf field <code>optional bool packed = 2;</code>
      * @return bool
@@ -257,7 +304,9 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
      * a more efficient representation on the wire. Rather than repeatedly
      * writing the tag and type for each element, the entire array is encoded as
      * a single length-delimited blob. In proto3, only explicit setting it to
-     * false will avoid using packed encoding.
+     * false will avoid using packed encoding.  This option is prohibited in
+     * Editions, but the `repeated_field_encoding` feature can be used to control
+     * the behavior.
      *
      * Generated from protobuf field <code>optional bool packed = 2;</code>
      * @param bool $var
@@ -529,6 +578,156 @@ class FieldOptions extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * Indicate that the field value should not be printed out when using debug
+     * formats, e.g. when the field contains sensitive credentials.
+     *
+     * Generated from protobuf field <code>optional bool debug_redact = 16 [default = false];</code>
+     * @return bool
+     */
+    public function getDebugRedact()
+    {
+        return isset($this->debug_redact) ? $this->debug_redact : false;
+    }
+
+    public function hasDebugRedact()
+    {
+        return isset($this->debug_redact);
+    }
+
+    public function clearDebugRedact()
+    {
+        unset($this->debug_redact);
+    }
+
+    /**
+     * Indicate that the field value should not be printed out when using debug
+     * formats, e.g. when the field contains sensitive credentials.
+     *
+     * Generated from protobuf field <code>optional bool debug_redact = 16 [default = false];</code>
+     * @param bool $var
+     * @return $this
+     */
+    public function setDebugRedact($var)
+    {
+        GPBUtil::checkBool($var);
+        $this->debug_redact = $var;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
+     * @return int
+     */
+    public function getRetention()
+    {
+        return isset($this->retention) ? $this->retention : 0;
+    }
+
+    public function hasRetention()
+    {
+        return isset($this->retention);
+    }
+
+    public function clearRetention()
+    {
+        unset($this->retention);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.FieldOptions.OptionRetention retention = 17;</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setRetention($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\FieldOptions\OptionRetention::class);
+        $this->retention = $var;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
+     * @return \Google\Protobuf\Internal\RepeatedField
+     */
+    public function getTargets()
+    {
+        return $this->targets;
+    }
+
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FieldOptions.OptionTargetType targets = 19;</code>
+     * @param array<int>|\Google\Protobuf\Internal\RepeatedField $var
+     * @return $this
+     */
+    public function setTargets($var)
+    {
+        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::ENUM, \Google\Protobuf\Internal\FieldOptions\OptionTargetType::class);
+        $this->targets = $arr;
+
+        return $this;
+    }
+
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
+     * @return \Google\Protobuf\Internal\RepeatedField
+     */
+    public function getEditionDefaults()
+    {
+        return $this->edition_defaults;
+    }
+
+    /**
+     * Generated from protobuf field <code>repeated .google.protobuf.FieldOptions.EditionDefault edition_defaults = 20;</code>
+     * @param array<\Google\Protobuf\Internal\FieldOptions\EditionDefault>|\Google\Protobuf\Internal\RepeatedField $var
+     * @return $this
+     */
+    public function setEditionDefaults($var)
+    {
+        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Google\Protobuf\Internal\FieldOptions\EditionDefault::class);
+        $this->edition_defaults = $arr;
+
+        return $this;
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 21;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 21;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
diff --git a/php/src/Google/Protobuf/Internal/FieldOptions/CType.php b/php/src/Google/Protobuf/Internal/FieldOptions/CType.php
index ba9eb4adb..18a811c87 100644
--- a/php/src/Google/Protobuf/Internal/FieldOptions/CType.php
+++ b/php/src/Google/Protobuf/Internal/FieldOptions/CType.php
@@ -18,6 +18,13 @@ class CType
      */
     const STRING = 0;
     /**
+     * The option [ctype=CORD] may be applied to a non-repeated field of type
+     * "bytes". It indicates that in C++, the data should be stored in a Cord
+     * instead of a string.  For very large strings, this may reduce memory
+     * fragmentation. It may also allow better performance when parsing from a
+     * Cord, or when parsing with aliasing enabled, as the parsed Cord may then
+     * alias the original buffer.
+     *
      * Generated from protobuf enum <code>CORD = 1;</code>
      */
     const CORD = 1;
diff --git a/php/src/Google/Protobuf/Internal/FieldOptions/EditionDefault.php b/php/src/Google/Protobuf/Internal/FieldOptions/EditionDefault.php
new file mode 100644
index 000000000..02a4e1bd0
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FieldOptions/EditionDefault.php
@@ -0,0 +1,117 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FieldOptions;
+
+use Google\Protobuf\Internal\GPBType;
+use Google\Protobuf\Internal\GPBWire;
+use Google\Protobuf\Internal\RepeatedField;
+use Google\Protobuf\Internal\InputStream;
+use Google\Protobuf\Internal\GPBUtil;
+
+/**
+ * Generated from protobuf message <code>google.protobuf.FieldOptions.EditionDefault</code>
+ */
+class EditionDefault extends \Google\Protobuf\Internal\Message
+{
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 3;</code>
+     */
+    protected $edition = null;
+    /**
+     * Textproto value.
+     *
+     * Generated from protobuf field <code>optional string value = 2;</code>
+     */
+    protected $value = null;
+
+    /**
+     * Constructor.
+     *
+     * @param array $data {
+     *     Optional. Data for populating the Message object.
+     *
+     *     @type int $edition
+     *     @type string $value
+     *           Textproto value.
+     * }
+     */
+    public function __construct($data = NULL) {
+        \GPBMetadata\Google\Protobuf\Internal\Descriptor::initOnce();
+        parent::__construct($data);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 3;</code>
+     * @return int
+     */
+    public function getEdition()
+    {
+        return isset($this->edition) ? $this->edition : 0;
+    }
+
+    public function hasEdition()
+    {
+        return isset($this->edition);
+    }
+
+    public function clearEdition()
+    {
+        unset($this->edition);
+    }
+
+    /**
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 3;</code>
+     * @param int $var
+     * @return $this
+     */
+    public function setEdition($var)
+    {
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\Edition::class);
+        $this->edition = $var;
+
+        return $this;
+    }
+
+    /**
+     * Textproto value.
+     *
+     * Generated from protobuf field <code>optional string value = 2;</code>
+     * @return string
+     */
+    public function getValue()
+    {
+        return isset($this->value) ? $this->value : '';
+    }
+
+    public function hasValue()
+    {
+        return isset($this->value);
+    }
+
+    public function clearValue()
+    {
+        unset($this->value);
+    }
+
+    /**
+     * Textproto value.
+     *
+     * Generated from protobuf field <code>optional string value = 2;</code>
+     * @param string $var
+     * @return $this
+     */
+    public function setValue($var)
+    {
+        GPBUtil::checkString($var, True);
+        $this->value = $var;
+
+        return $this;
+    }
+
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(EditionDefault::class, \Google\Protobuf\Internal\FieldOptions_EditionDefault::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FieldOptions/OptionRetention.php b/php/src/Google/Protobuf/Internal/FieldOptions/OptionRetention.php
new file mode 100644
index 000000000..d9e627b10
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FieldOptions/OptionRetention.php
@@ -0,0 +1,60 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FieldOptions;
+
+use UnexpectedValueException;
+
+/**
+ * If set to RETENTION_SOURCE, the option will be omitted from the binary.
+ * Note: as of January 2023, support for this is in progress and does not yet
+ * have an effect (b/264593489).
+ *
+ * Protobuf type <code>google.protobuf.FieldOptions.OptionRetention</code>
+ */
+class OptionRetention
+{
+    /**
+     * Generated from protobuf enum <code>RETENTION_UNKNOWN = 0;</code>
+     */
+    const RETENTION_UNKNOWN = 0;
+    /**
+     * Generated from protobuf enum <code>RETENTION_RUNTIME = 1;</code>
+     */
+    const RETENTION_RUNTIME = 1;
+    /**
+     * Generated from protobuf enum <code>RETENTION_SOURCE = 2;</code>
+     */
+    const RETENTION_SOURCE = 2;
+
+    private static $valueToName = [
+        self::RETENTION_UNKNOWN => 'RETENTION_UNKNOWN',
+        self::RETENTION_RUNTIME => 'RETENTION_RUNTIME',
+        self::RETENTION_SOURCE => 'RETENTION_SOURCE',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(OptionRetention::class, \Google\Protobuf\Internal\FieldOptions_OptionRetention::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FieldOptions/OptionTargetType.php b/php/src/Google/Protobuf/Internal/FieldOptions/OptionTargetType.php
new file mode 100644
index 000000000..ad91f4275
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/FieldOptions/OptionTargetType.php
@@ -0,0 +1,96 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\FieldOptions;
+
+use UnexpectedValueException;
+
+/**
+ * This indicates the types of entities that the field may apply to when used
+ * as an option. If it is unset, then the field may be freely used as an
+ * option on any kind of entity. Note: as of January 2023, support for this is
+ * in progress and does not yet have an effect (b/264593489).
+ *
+ * Protobuf type <code>google.protobuf.FieldOptions.OptionTargetType</code>
+ */
+class OptionTargetType
+{
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_UNKNOWN = 0;</code>
+     */
+    const TARGET_TYPE_UNKNOWN = 0;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_FILE = 1;</code>
+     */
+    const TARGET_TYPE_FILE = 1;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_EXTENSION_RANGE = 2;</code>
+     */
+    const TARGET_TYPE_EXTENSION_RANGE = 2;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_MESSAGE = 3;</code>
+     */
+    const TARGET_TYPE_MESSAGE = 3;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_FIELD = 4;</code>
+     */
+    const TARGET_TYPE_FIELD = 4;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_ONEOF = 5;</code>
+     */
+    const TARGET_TYPE_ONEOF = 5;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_ENUM = 6;</code>
+     */
+    const TARGET_TYPE_ENUM = 6;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_ENUM_ENTRY = 7;</code>
+     */
+    const TARGET_TYPE_ENUM_ENTRY = 7;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_SERVICE = 8;</code>
+     */
+    const TARGET_TYPE_SERVICE = 8;
+    /**
+     * Generated from protobuf enum <code>TARGET_TYPE_METHOD = 9;</code>
+     */
+    const TARGET_TYPE_METHOD = 9;
+
+    private static $valueToName = [
+        self::TARGET_TYPE_UNKNOWN => 'TARGET_TYPE_UNKNOWN',
+        self::TARGET_TYPE_FILE => 'TARGET_TYPE_FILE',
+        self::TARGET_TYPE_EXTENSION_RANGE => 'TARGET_TYPE_EXTENSION_RANGE',
+        self::TARGET_TYPE_MESSAGE => 'TARGET_TYPE_MESSAGE',
+        self::TARGET_TYPE_FIELD => 'TARGET_TYPE_FIELD',
+        self::TARGET_TYPE_ONEOF => 'TARGET_TYPE_ONEOF',
+        self::TARGET_TYPE_ENUM => 'TARGET_TYPE_ENUM',
+        self::TARGET_TYPE_ENUM_ENTRY => 'TARGET_TYPE_ENUM_ENTRY',
+        self::TARGET_TYPE_SERVICE => 'TARGET_TYPE_SERVICE',
+        self::TARGET_TYPE_METHOD => 'TARGET_TYPE_METHOD',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(OptionTargetType::class, \Google\Protobuf\Internal\FieldOptions_OptionTargetType::class);
+
diff --git a/php/src/Google/Protobuf/Internal/FileDescriptorProto.php b/php/src/Google/Protobuf/Internal/FileDescriptorProto.php
index d4c7f6bb8..1162a4e86 100644
--- a/php/src/Google/Protobuf/Internal/FileDescriptorProto.php
+++ b/php/src/Google/Protobuf/Internal/FileDescriptorProto.php
@@ -88,9 +88,9 @@ class FileDescriptorProto extends \Google\Protobuf\Internal\Message
      */
     protected $syntax = null;
     /**
-     * The edition of the proto file, which is an opaque string.
+     * The edition of the proto file.
      *
-     * Generated from protobuf field <code>optional string edition = 13;</code>
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 14;</code>
      */
     protected $edition = null;
 
@@ -126,8 +126,8 @@ class FileDescriptorProto extends \Google\Protobuf\Internal\Message
      *           The syntax of the proto file.
      *           The supported values are "proto2", "proto3", and "editions".
      *           If `edition` is present, this value must be "editions".
-     *     @type string $edition
-     *           The edition of the proto file, which is an opaque string.
+     *     @type int $edition
+     *           The edition of the proto file.
      * }
      */
     public function __construct($data = NULL) {
@@ -494,14 +494,14 @@ class FileDescriptorProto extends \Google\Protobuf\Internal\Message
     }
 
     /**
-     * The edition of the proto file, which is an opaque string.
+     * The edition of the proto file.
      *
-     * Generated from protobuf field <code>optional string edition = 13;</code>
-     * @return string
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 14;</code>
+     * @return int
      */
     public function getEdition()
     {
-        return isset($this->edition) ? $this->edition : '';
+        return isset($this->edition) ? $this->edition : 0;
     }
 
     public function hasEdition()
@@ -515,15 +515,15 @@ class FileDescriptorProto extends \Google\Protobuf\Internal\Message
     }
 
     /**
-     * The edition of the proto file, which is an opaque string.
+     * The edition of the proto file.
      *
-     * Generated from protobuf field <code>optional string edition = 13;</code>
-     * @param string $var
+     * Generated from protobuf field <code>optional .google.protobuf.Edition edition = 14;</code>
+     * @param int $var
      * @return $this
      */
     public function setEdition($var)
     {
-        GPBUtil::checkString($var, True);
+        GPBUtil::checkEnum($var, \Google\Protobuf\Internal\Edition::class);
         $this->edition = $var;
 
         return $this;
diff --git a/php/src/Google/Protobuf/Internal/FileOptions.php b/php/src/Google/Protobuf/Internal/FileOptions.php
index 43931be80..faae680e6 100644
--- a/php/src/Google/Protobuf/Internal/FileOptions.php
+++ b/php/src/Google/Protobuf/Internal/FileOptions.php
@@ -119,6 +119,14 @@ class FileOptions extends \Google\Protobuf\Internal\Message
      * Generated from protobuf field <code>optional bool cc_enable_arenas = 31 [default = true];</code>
      */
     protected $cc_enable_arenas = null;
+    /**
+     * 增加新开关，控制生成代码的mutable_xxx接口行为和返回值
+     * false: 默认，将donated状态的string转换为heap allocated，通过std::string*返回
+     * true: 保持当前string的donated状态，通过MaybeArenaStringAccessor返回
+     *
+     * Generated from protobuf field <code>optional bool cc_mutable_donated_string = 32 [default = false];</code>
+     */
+    protected $cc_mutable_donated_string = null;
     /**
      * Sets the objective c class prefix which is prepended to all objective c
      * generated classes from this .proto. There is no default.
@@ -172,6 +180,12 @@ class FileOptions extends \Google\Protobuf\Internal\Message
      * Generated from protobuf field <code>optional string ruby_package = 45;</code>
      */
     protected $ruby_package = null;
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 50;</code>
+     */
+    protected $features = null;
     /**
      * The parser stores options it doesn't recognize here.
      * See the documentation for the "Options" section above.
@@ -241,6 +255,10 @@ class FileOptions extends \Google\Protobuf\Internal\Message
      *     @type bool $cc_enable_arenas
      *           Enables the use of arenas for the proto messages in this file. This applies
      *           only to generated classes for C++.
+     *     @type bool $cc_mutable_donated_string
+     *           增加新开关，控制生成代码的mutable_xxx接口行为和返回值
+     *           false: 默认，将donated状态的string转换为heap allocated，通过std::string*返回
+     *           true: 保持当前string的donated状态，通过MaybeArenaStringAccessor返回
      *     @type string $objc_class_prefix
      *           Sets the objective c class prefix which is prepended to all objective c
      *           generated classes from this .proto. There is no default.
@@ -266,6 +284,8 @@ class FileOptions extends \Google\Protobuf\Internal\Message
      *           Use this option to change the package of ruby generated classes. Default
      *           is empty. When this option is not set, the package name will be used for
      *           determining the ruby package.
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
      *     @type array<\Google\Protobuf\Internal\UninterpretedOption>|\Google\Protobuf\Internal\RepeatedField $uninterpreted_option
      *           The parser stores options it doesn't recognize here.
      *           See the documentation for the "Options" section above.
@@ -800,6 +820,46 @@ class FileOptions extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * 增加新开关，控制生成代码的mutable_xxx接口行为和返回值
+     * false: 默认，将donated状态的string转换为heap allocated，通过std::string*返回
+     * true: 保持当前string的donated状态，通过MaybeArenaStringAccessor返回
+     *
+     * Generated from protobuf field <code>optional bool cc_mutable_donated_string = 32 [default = false];</code>
+     * @return bool
+     */
+    public function getCcMutableDonatedString()
+    {
+        return isset($this->cc_mutable_donated_string) ? $this->cc_mutable_donated_string : false;
+    }
+
+    public function hasCcMutableDonatedString()
+    {
+        return isset($this->cc_mutable_donated_string);
+    }
+
+    public function clearCcMutableDonatedString()
+    {
+        unset($this->cc_mutable_donated_string);
+    }
+
+    /**
+     * 增加新开关，控制生成代码的mutable_xxx接口行为和返回值
+     * false: 默认，将donated状态的string转换为heap allocated，通过std::string*返回
+     * true: 保持当前string的donated状态，通过MaybeArenaStringAccessor返回
+     *
+     * Generated from protobuf field <code>optional bool cc_mutable_donated_string = 32 [default = false];</code>
+     * @param bool $var
+     * @return $this
+     */
+    public function setCcMutableDonatedString($var)
+    {
+        GPBUtil::checkBool($var);
+        $this->cc_mutable_donated_string = $var;
+
+        return $this;
+    }
+
     /**
      * Sets the objective c class prefix which is prepended to all objective c
      * generated classes from this .proto. There is no default.
@@ -1074,6 +1134,42 @@ class FileOptions extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 50;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 50;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
     /**
      * The parser stores options it doesn't recognize here.
      * See the documentation for the "Options" section above.
diff --git a/php/src/Google/Protobuf/Internal/GeneratedCodeInfo/Annotation/Semantic.php b/php/src/Google/Protobuf/Internal/GeneratedCodeInfo/Annotation/Semantic.php
new file mode 100644
index 000000000..eec4a5c26
--- /dev/null
+++ b/php/src/Google/Protobuf/Internal/GeneratedCodeInfo/Annotation/Semantic.php
@@ -0,0 +1,65 @@
+<?php
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: google/protobuf/descriptor.proto
+
+namespace Google\Protobuf\Internal\GeneratedCodeInfo\Annotation;
+
+use UnexpectedValueException;
+
+/**
+ * Represents the identified object's effect on the element in the original
+ * .proto file.
+ *
+ * Protobuf type <code>google.protobuf.GeneratedCodeInfo.Annotation.Semantic</code>
+ */
+class Semantic
+{
+    /**
+     * There is no effect or the effect is indescribable.
+     *
+     * Generated from protobuf enum <code>NONE = 0;</code>
+     */
+    const NONE = 0;
+    /**
+     * The element is set or otherwise mutated.
+     *
+     * Generated from protobuf enum <code>SET = 1;</code>
+     */
+    const SET = 1;
+    /**
+     * An alias to the element is returned.
+     *
+     * Generated from protobuf enum <code>ALIAS = 2;</code>
+     */
+    const ALIAS = 2;
+
+    private static $valueToName = [
+        self::NONE => 'NONE',
+        self::SET => 'SET',
+        self::ALIAS => 'ALIAS',
+    ];
+
+    public static function name($value)
+    {
+        if (!isset(self::$valueToName[$value])) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no name defined for value %s', __CLASS__, $value));
+        }
+        return self::$valueToName[$value];
+    }
+
+
+    public static function value($name)
+    {
+        $const = __CLASS__ . '::' . strtoupper($name);
+        if (!defined($const)) {
+            throw new UnexpectedValueException(sprintf(
+                    'Enum %s has no value defined for name %s', __CLASS__, $name));
+        }
+        return constant($const);
+    }
+}
+
+// Adding a class alias for backwards compatibility with the previous class name.
+class_alias(Semantic::class, \Google\Protobuf\Internal\GeneratedCodeInfo_Annotation_Semantic::class);
+
diff --git a/php/src/Google/Protobuf/Internal/MessageOptions.php b/php/src/Google/Protobuf/Internal/MessageOptions.php
index bb01aa4ba..2fa45c620 100644
--- a/php/src/Google/Protobuf/Internal/MessageOptions.php
+++ b/php/src/Google/Protobuf/Internal/MessageOptions.php
@@ -89,6 +89,12 @@ class MessageOptions extends \Google\Protobuf\Internal\Message
      * @deprecated
      */
     protected $deprecated_legacy_json_field_conflicts = null;
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 12;</code>
+     */
+    protected $features = null;
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
@@ -155,6 +161,8 @@ class MessageOptions extends \Google\Protobuf\Internal\Message
      *           to the change in behavior for JSON field name conflicts.
      *           TODO This is legacy behavior we plan to remove once downstream
      *           teams have had time to migrate.
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
      *     @type array<\Google\Protobuf\Internal\UninterpretedOption>|\Google\Protobuf\Internal\RepeatedField $uninterpreted_option
      *           The parser stores options it doesn't recognize here. See above.
      * }
@@ -436,6 +444,42 @@ class MessageOptions extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 12;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 12;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
diff --git a/php/src/Google/Protobuf/Internal/MethodOptions.php b/php/src/Google/Protobuf/Internal/MethodOptions.php
index 87af45167..ade042e55 100644
--- a/php/src/Google/Protobuf/Internal/MethodOptions.php
+++ b/php/src/Google/Protobuf/Internal/MethodOptions.php
@@ -28,6 +28,12 @@ class MethodOptions extends \Google\Protobuf\Internal\Message
      * Generated from protobuf field <code>optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34 [default = IDEMPOTENCY_UNKNOWN];</code>
      */
     protected $idempotency_level = null;
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 35;</code>
+     */
+    protected $features = null;
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
@@ -47,6 +53,8 @@ class MethodOptions extends \Google\Protobuf\Internal\Message
      *           for the method, or it will be completely ignored; in the very least,
      *           this is a formalization for deprecating methods.
      *     @type int $idempotency_level
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
      *     @type array<\Google\Protobuf\Internal\UninterpretedOption>|\Google\Protobuf\Internal\RepeatedField $uninterpreted_option
      *           The parser stores options it doesn't recognize here. See above.
      * }
@@ -130,6 +138,42 @@ class MethodOptions extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 35;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 35;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
diff --git a/php/src/Google/Protobuf/Internal/OneofOptions.php b/php/src/Google/Protobuf/Internal/OneofOptions.php
index b44d19457..ad34d0810 100644
--- a/php/src/Google/Protobuf/Internal/OneofOptions.php
+++ b/php/src/Google/Protobuf/Internal/OneofOptions.php
@@ -15,6 +15,12 @@ use Google\Protobuf\Internal\GPBUtil;
  */
 class OneofOptions extends \Google\Protobuf\Internal\Message
 {
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 1;</code>
+     */
+    protected $features = null;
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
@@ -28,6 +34,8 @@ class OneofOptions extends \Google\Protobuf\Internal\Message
      * @param array $data {
      *     Optional. Data for populating the Message object.
      *
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
      *     @type array<\Google\Protobuf\Internal\UninterpretedOption>|\Google\Protobuf\Internal\RepeatedField $uninterpreted_option
      *           The parser stores options it doesn't recognize here. See above.
      * }
@@ -37,6 +45,42 @@ class OneofOptions extends \Google\Protobuf\Internal\Message
         parent::__construct($data);
     }
 
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 1;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 1;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
     /**
      * The parser stores options it doesn't recognize here. See above.
      *
diff --git a/php/src/Google/Protobuf/Internal/ServiceOptions.php b/php/src/Google/Protobuf/Internal/ServiceOptions.php
index 8ac27ee80..91d51f97c 100644
--- a/php/src/Google/Protobuf/Internal/ServiceOptions.php
+++ b/php/src/Google/Protobuf/Internal/ServiceOptions.php
@@ -15,6 +15,12 @@ use Google\Protobuf\Internal\GPBUtil;
  */
 class ServiceOptions extends \Google\Protobuf\Internal\Message
 {
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 34;</code>
+     */
+    protected $features = null;
     /**
      * Is this service deprecated?
      * Depending on the target platform, this can emit Deprecated annotations
@@ -37,6 +43,8 @@ class ServiceOptions extends \Google\Protobuf\Internal\Message
      * @param array $data {
      *     Optional. Data for populating the Message object.
      *
+     *     @type \Google\Protobuf\Internal\FeatureSet $features
+     *           Any features defined in the specific edition.
      *     @type bool $deprecated
      *           Is this service deprecated?
      *           Depending on the target platform, this can emit Deprecated annotations
@@ -51,6 +59,42 @@ class ServiceOptions extends \Google\Protobuf\Internal\Message
         parent::__construct($data);
     }
 
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 34;</code>
+     * @return \Google\Protobuf\Internal\FeatureSet|null
+     */
+    public function getFeatures()
+    {
+        return $this->features;
+    }
+
+    public function hasFeatures()
+    {
+        return isset($this->features);
+    }
+
+    public function clearFeatures()
+    {
+        unset($this->features);
+    }
+
+    /**
+     * Any features defined in the specific edition.
+     *
+     * Generated from protobuf field <code>optional .google.protobuf.FeatureSet features = 34;</code>
+     * @param \Google\Protobuf\Internal\FeatureSet $var
+     * @return $this
+     */
+    public function setFeatures($var)
+    {
+        GPBUtil::checkMessage($var, \Google\Protobuf\Internal\FeatureSet::class);
+        $this->features = $var;
+
+        return $this;
+    }
+
     /**
      * Is this service deprecated?
      * Depending on the target platform, this can emit Deprecated annotations
diff --git a/php/src/Google/Protobuf/Mixin.php b/php/src/Google/Protobuf/Mixin.php
index 4f7bf844c..0f94d8d2c 100644
--- a/php/src/Google/Protobuf/Mixin.php
+++ b/php/src/Google/Protobuf/Mixin.php
@@ -46,7 +46,7 @@ use Google\Protobuf\Internal\GPBUtil;
  * The mixin construct implies that all methods in `AccessControl` are
  * also declared with same name and request/response types in
  * `Storage`. A documentation generator or annotation processor will
- * see the effective `Storage.GetAcl` method after inheriting
+ * see the effective `Storage.GetAcl` method after inherting
  * documentation and annotations as follows:
  *     service Storage {
  *       // Get the underlying ACL object.
diff --git a/php/src/Google/Protobuf/NullValue.php b/php/src/Google/Protobuf/NullValue.php
index 61569f8a3..66f8c3713 100644
--- a/php/src/Google/Protobuf/NullValue.php
+++ b/php/src/Google/Protobuf/NullValue.php
@@ -9,7 +9,7 @@ use UnexpectedValueException;
 /**
  * `NullValue` is a singleton enumeration to represent the null value for the
  * `Value` type union.
- *  The JSON representation for `NullValue` is JSON `null`.
+ * The JSON representation for `NullValue` is JSON `null`.
  *
  * Protobuf type <code>google.protobuf.NullValue</code>
  */
diff --git a/php/src/Google/Protobuf/Syntax.php b/php/src/Google/Protobuf/Syntax.php
index 10952bfd4..ce547bf2e 100644
--- a/php/src/Google/Protobuf/Syntax.php
+++ b/php/src/Google/Protobuf/Syntax.php
@@ -25,10 +25,17 @@ class Syntax
      * Generated from protobuf enum <code>SYNTAX_PROTO3 = 1;</code>
      */
     const SYNTAX_PROTO3 = 1;
+    /**
+     * Syntax `editions`.
+     *
+     * Generated from protobuf enum <code>SYNTAX_EDITIONS = 2;</code>
+     */
+    const SYNTAX_EDITIONS = 2;
 
     private static $valueToName = [
         self::SYNTAX_PROTO2 => 'SYNTAX_PROTO2',
         self::SYNTAX_PROTO3 => 'SYNTAX_PROTO3',
+        self::SYNTAX_EDITIONS => 'SYNTAX_EDITIONS',
     ];
 
     public static function name($value)
diff --git a/php/src/Google/Protobuf/Timestamp.php b/php/src/Google/Protobuf/Timestamp.php
index a12f48520..2c0307a64 100644
--- a/php/src/Google/Protobuf/Timestamp.php
+++ b/php/src/Google/Protobuf/Timestamp.php
@@ -73,7 +73,7 @@ use Google\Protobuf\Internal\GPBUtil;
  * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
  * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
  * the Joda Time's [`ISODateTimeFormat.dateTime()`](
- * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
+ * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
  * ) to obtain a formatter capable of generating timestamps in this format.
  *
  * Generated from protobuf message <code>google.protobuf.Timestamp</code>
diff --git a/php/src/Google/Protobuf/Type.php b/php/src/Google/Protobuf/Type.php
index d4af7dfec..24a5a670f 100644
--- a/php/src/Google/Protobuf/Type.php
+++ b/php/src/Google/Protobuf/Type.php
@@ -51,6 +51,12 @@ class Type extends \Google\Protobuf\Internal\Message
      * Generated from protobuf field <code>.google.protobuf.Syntax syntax = 6;</code>
      */
     protected $syntax = 0;
+    /**
+     * The source edition string, only valid when syntax is SYNTAX_EDITIONS.
+     *
+     * Generated from protobuf field <code>string edition = 7;</code>
+     */
+    protected $edition = '';
 
     /**
      * Constructor.
@@ -70,6 +76,8 @@ class Type extends \Google\Protobuf\Internal\Message
      *           The source context.
      *     @type int $syntax
      *           The source syntax.
+     *     @type string $edition
+     *           The source edition string, only valid when syntax is SYNTAX_EDITIONS.
      * }
      */
     public function __construct($data = NULL) {
@@ -243,5 +251,31 @@ class Type extends \Google\Protobuf\Internal\Message
         return $this;
     }
 
+    /**
+     * The source edition string, only valid when syntax is SYNTAX_EDITIONS.
+     *
+     * Generated from protobuf field <code>string edition = 7;</code>
+     * @return string
+     */
+    public function getEdition()
+    {
+        return $this->edition;
+    }
+
+    /**
+     * The source edition string, only valid when syntax is SYNTAX_EDITIONS.
+     *
+     * Generated from protobuf field <code>string edition = 7;</code>
+     * @param string $var
+     * @return $this
+     */
+    public function setEdition($var)
+    {
+        GPBUtil::checkString($var, True);
+        $this->edition = $var;
+
+        return $this;
+    }
+
 }
 
diff --git a/src/google/protobuf/BUILD.bazel b/src/google/protobuf/BUILD.bazel
index 8961ca6af..ad1513689 100644
--- a/src/google/protobuf/BUILD.bazel
+++ b/src/google/protobuf/BUILD.bazel
@@ -368,6 +368,7 @@ cc_library(
     srcs = [
         "any_lite.cc",
         "arenastring.cc",
+        "arenastring_impl.cc",
         "arenaz_sampler.cc",
         "extension_set.cc",
         "generated_enum_util.cc",
@@ -387,6 +388,7 @@ cc_library(
         "any.h",
         "arena.h",
         "arenastring.h",
+        "arenastring_impl.h",
         "arenaz_sampler.h",
         "endian.h",
         "explicitly_constructed.h",
diff --git a/src/google/protobuf/any.pb.h b/src/google/protobuf/any.pb.h
index 59497189e..ed08e503a 100644
--- a/src/google/protobuf/any.pb.h
+++ b/src/google/protobuf/any.pb.h
@@ -255,6 +255,7 @@ class PROTOBUF_EXPORT Any final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_url(
       const std::string& value);
   std::string* _internal_mutable_type_url();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_type_url_accessor();
 
   public:
   // bytes value = 2;
@@ -271,6 +272,7 @@ class PROTOBUF_EXPORT Any final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
       const std::string& value);
   std::string* _internal_mutable_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_value_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.Any)
@@ -341,7 +343,7 @@ inline PROTOBUF_ALWAYS_INLINE void Any::set_type_url(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Any.type_url)
 }
 inline std::string* Any::mutable_type_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_type_url();
+  auto _s = _internal_mutable_type_url();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Any.type_url)
   return _s;
 }
@@ -359,10 +361,19 @@ inline std::string* Any::_internal_mutable_type_url() {
   ;
   return _impl_.type_url_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Any::_internal_mutable_type_url_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.type_url_.MutableAccessor( GetArena());
+}
 inline std::string* Any::release_type_url() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Any.type_url)
-  return _impl_.type_url_.Release();
+  auto* released = _impl_.type_url_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.type_url_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Any::set_allocated_type_url(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -394,7 +405,7 @@ inline PROTOBUF_ALWAYS_INLINE void Any::set_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Any.value)
 }
 inline std::string* Any::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_value();
+  auto _s = _internal_mutable_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Any.value)
   return _s;
 }
@@ -412,10 +423,19 @@ inline std::string* Any::_internal_mutable_value() {
   ;
   return _impl_.value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Any::_internal_mutable_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.value_.MutableAccessor( GetArena());
+}
 inline std::string* Any::release_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Any.value)
-  return _impl_.value_.Release();
+  auto* released = _impl_.value_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.value_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Any::set_allocated_value(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
diff --git a/src/google/protobuf/api.pb.h b/src/google/protobuf/api.pb.h
index ad6915575..9aa8e03ef 100644
--- a/src/google/protobuf/api.pb.h
+++ b/src/google/protobuf/api.pb.h
@@ -228,6 +228,7 @@ class PROTOBUF_EXPORT Mixin final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string root = 2;
@@ -244,6 +245,7 @@ class PROTOBUF_EXPORT Mixin final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(
       const std::string& value);
   std::string* _internal_mutable_root();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_root_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.Mixin)
@@ -450,6 +452,7 @@ class PROTOBUF_EXPORT Method final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string request_type_url = 2;
@@ -466,6 +469,7 @@ class PROTOBUF_EXPORT Method final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_type_url(
       const std::string& value);
   std::string* _internal_mutable_request_type_url();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_request_type_url_accessor();
 
   public:
   // string response_type_url = 4;
@@ -482,6 +486,7 @@ class PROTOBUF_EXPORT Method final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_type_url(
       const std::string& value);
   std::string* _internal_mutable_response_type_url();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_response_type_url_accessor();
 
   public:
   // bool request_streaming = 3;
@@ -759,6 +764,7 @@ class PROTOBUF_EXPORT Api final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string version = 4;
@@ -775,6 +781,7 @@ class PROTOBUF_EXPORT Api final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
       const std::string& value);
   std::string* _internal_mutable_version();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_version_accessor();
 
   public:
   // .google.protobuf.SourceContext source_context = 5;
@@ -875,7 +882,7 @@ inline PROTOBUF_ALWAYS_INLINE void Api::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Api.name)
 }
 inline std::string* Api::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Api.name)
   return _s;
 }
@@ -893,10 +900,19 @@ inline std::string* Api::_internal_mutable_name() {
   ;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Api::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Api::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Api.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Api::set_allocated_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -1022,7 +1038,7 @@ inline PROTOBUF_ALWAYS_INLINE void Api::set_version(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Api.version)
 }
 inline std::string* Api::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_version();
+  auto _s = _internal_mutable_version();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Api.version)
   return _s;
 }
@@ -1040,10 +1056,19 @@ inline std::string* Api::_internal_mutable_version() {
   ;
   return _impl_.version_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Api::_internal_mutable_version_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.version_.MutableAccessor( GetArena());
+}
 inline std::string* Api::release_version() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Api.version)
-  return _impl_.version_.Release();
+  auto* released = _impl_.version_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.version_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Api::set_allocated_version(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -1242,7 +1267,7 @@ inline PROTOBUF_ALWAYS_INLINE void Method::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Method.name)
 }
 inline std::string* Method::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Method.name)
   return _s;
 }
@@ -1260,10 +1285,19 @@ inline std::string* Method::_internal_mutable_name() {
   ;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Method::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Method::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Method.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Method::set_allocated_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -1295,7 +1329,7 @@ inline PROTOBUF_ALWAYS_INLINE void Method::set_request_type_url(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Method.request_type_url)
 }
 inline std::string* Method::mutable_request_type_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_request_type_url();
+  auto _s = _internal_mutable_request_type_url();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Method.request_type_url)
   return _s;
 }
@@ -1313,10 +1347,19 @@ inline std::string* Method::_internal_mutable_request_type_url() {
   ;
   return _impl_.request_type_url_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Method::_internal_mutable_request_type_url_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.request_type_url_.MutableAccessor( GetArena());
+}
 inline std::string* Method::release_request_type_url() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Method.request_type_url)
-  return _impl_.request_type_url_.Release();
+  auto* released = _impl_.request_type_url_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.request_type_url_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Method::set_allocated_request_type_url(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -1371,7 +1414,7 @@ inline PROTOBUF_ALWAYS_INLINE void Method::set_response_type_url(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Method.response_type_url)
 }
 inline std::string* Method::mutable_response_type_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_response_type_url();
+  auto _s = _internal_mutable_response_type_url();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Method.response_type_url)
   return _s;
 }
@@ -1389,10 +1432,19 @@ inline std::string* Method::_internal_mutable_response_type_url() {
   ;
   return _impl_.response_type_url_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Method::_internal_mutable_response_type_url_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.response_type_url_.MutableAccessor( GetArena());
+}
 inline std::string* Method::release_response_type_url() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Method.response_type_url)
-  return _impl_.response_type_url_.Release();
+  auto* released = _impl_.response_type_url_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.response_type_url_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Method::set_allocated_response_type_url(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -1519,7 +1571,7 @@ inline PROTOBUF_ALWAYS_INLINE void Mixin::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Mixin.name)
 }
 inline std::string* Mixin::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Mixin.name)
   return _s;
 }
@@ -1537,10 +1589,19 @@ inline std::string* Mixin::_internal_mutable_name() {
   ;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Mixin::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Mixin::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Mixin.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Mixin::set_allocated_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -1572,7 +1633,7 @@ inline PROTOBUF_ALWAYS_INLINE void Mixin::set_root(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Mixin.root)
 }
 inline std::string* Mixin::mutable_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_root();
+  auto _s = _internal_mutable_root();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Mixin.root)
   return _s;
 }
@@ -1590,10 +1651,19 @@ inline std::string* Mixin::_internal_mutable_root() {
   ;
   return _impl_.root_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Mixin::_internal_mutable_root_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.root_.MutableAccessor( GetArena());
+}
 inline std::string* Mixin::release_root() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Mixin.root)
-  return _impl_.root_.Release();
+  auto* released = _impl_.root_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.root_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Mixin::set_allocated_root(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
diff --git a/src/google/protobuf/arena_unittest.cc b/src/google/protobuf/arena_unittest.cc
index 4a2d502cc..b9649d55e 100644
--- a/src/google/protobuf/arena_unittest.cc
+++ b/src/google/protobuf/arena_unittest.cc
@@ -923,11 +923,12 @@ TEST(ArenaTest, UnsafeArenaAddAllocatedToRepeatedField) {
   arena1_message->Clear();
   {
     std::string* s = new std::string("Test");
-    arena1_message->mutable_repeated_string()->UnsafeArenaAddAllocated(s);
+    arena1_message->mutable_repeated_string()->UnsafeArenaAddAllocated(
+        internal::StringHandlerType::ToUnTagged(s));
     // Should not copy.
     EXPECT_EQ(s, &arena1_message->repeated_string(0));
     EXPECT_EQ("Test", arena1_message->repeated_string(0));
-    delete arena1_message->mutable_repeated_string()->UnsafeArenaReleaseLast();
+    delete arena1_message->mutable_repeated_string()->UnsafeArenaReleaseLast()->ToStringPtr();
   }
 }
 
@@ -1046,7 +1047,8 @@ TEST(ArenaTest, UnsafeArenaAddAllocated) {
   TestAllTypes* message = Arena::CreateMessage<TestAllTypes>(&arena);
   for (int i = 0; i < 10; i++) {
     std::string* arena_string = Arena::Create<std::string>(&arena);
-    message->mutable_repeated_string()->UnsafeArenaAddAllocated(arena_string);
+    message->mutable_repeated_string()->UnsafeArenaAddAllocated(
+        internal::StringHandlerType::ToUnTagged(arena_string));
     EXPECT_EQ(arena_string, message->mutable_repeated_string(i));
   }
 }
diff --git a/src/google/protobuf/arenastring.cc b/src/google/protobuf/arenastring.cc
index bf9d0bb7c..cf88c814a 100644
--- a/src/google/protobuf/arenastring.cc
+++ b/src/google/protobuf/arenastring.cc
@@ -84,7 +84,9 @@ inline TaggedStringPtr CreateString(absl::string_view value) {
 // Creates an arena allocated std::string value.
 TaggedStringPtr CreateArenaString(Arena& arena, absl::string_view s) {
   TaggedStringPtr res;
-  res.SetMutableArena(Arena::Create<std::string>(&arena, s.data(), s.length()));
+  // 初始进入FixedSizeArena模式
+  res.SetFixedSizeArena(
+      ArenaStringAccessor::create(&arena, s).underlying());
   return res;
 }
 
@@ -116,7 +118,8 @@ void ArenaStringPtr::Set(absl::string_view value, Arena* arena) {
       old->assign("garbagedata");
     }
 #else   // PROTOBUF_FORCE_COPY_DEFAULT_STRING
-    UnsafeMutablePointer()->assign(value.data(), value.length());
+    // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+    Accessor(arena) = value;
 #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
   }
 }
@@ -127,8 +130,8 @@ void ArenaStringPtr::Set(const std::string& value, Arena* arena) {
   if (IsDefault()) {
     // If we're not on an arena, skip straight to a true string to avoid
     // possible copy cost later.
-    tagged_ptr_ = arena != nullptr ? CreateArenaString(*arena, value)
-                                   : CreateString(value);
+    // 统一访问器适配Allocated/FixedSizeArena模式
+    NewString(arena, value);
   } else {
 #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
     if (arena == nullptr) {
@@ -141,7 +144,8 @@ void ArenaStringPtr::Set(const std::string& value, Arena* arena) {
       old->assign("garbagedata");
     }
 #else   // PROTOBUF_FORCE_COPY_DEFAULT_STRING
-    UnsafeMutablePointer()->assign(value);
+    // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+    Accessor(arena) = value;
 #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
   }
 }
@@ -150,13 +154,9 @@ void ArenaStringPtr::Set(std::string&& value, Arena* arena) {
   ScopedCheckPtrInvariants check(&tagged_ptr_);
   if (IsDefault()) {
     NewString(arena, std::move(value));
-  } else if (IsFixedSizeArena()) {
-    std::string* current = tagged_ptr_.Get();
-    auto* s = new (current) std::string(std::move(value));
-    arena->OwnDestructor(s);
-    tagged_ptr_.SetMutableArena(s);
-  } else /* !IsFixedSizeArena() */ {
-    *UnsafeMutablePointer() = std::move(value);
+  } else {
+    // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+    Accessor(arena) = std::move(value);
   }
 }
 
@@ -179,6 +179,45 @@ std::string* ArenaStringPtr::Mutable(const LazyString& default_value,
   }
 }
 
+MaybeArenaStringAccessor ArenaStringPtr::MutableAccessor(Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) {
+    std::string* string;
+    if (arena != nullptr) {
+      string = ArenaStringAccessor::create(arena).underlying();
+      tagged_ptr_.SetFixedSizeArena(string);
+    } else {
+      string = new std::string;
+      tagged_ptr_.SetAllocated(string);
+    }
+    return MaybeArenaStringAccessor(arena, string);
+  } else {
+    // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+    return Accessor(arena);
+  }
+}
+
+MaybeArenaStringAccessor ArenaStringPtr::MutableAccessor(
+        const LazyString& default_value,
+        Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) {
+    std::string* string;
+    if (arena != nullptr) {
+      string = ArenaStringAccessor::create(
+          arena, default_value.get()).underlying();
+      tagged_ptr_.SetFixedSizeArena(string);
+    } else {
+      string = new std::string(default_value.get());
+      tagged_ptr_.SetAllocated(string);
+    }
+    return MaybeArenaStringAccessor(arena, string);
+  } else {
+    // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+    return Accessor(arena);
+  }
+}
+
 std::string* ArenaStringPtr::MutableNoCopy(Arena* arena) {
   ScopedCheckPtrInvariants check(&tagged_ptr_);
   if (tagged_ptr_.IsMutable()) {
@@ -193,12 +232,29 @@ std::string* ArenaStringPtr::MutableNoCopy(Arena* arena) {
 template <typename... Lazy>
 std::string* ArenaStringPtr::MutableSlow(::google::protobuf::Arena* arena,
                                          const Lazy&... lazy_default) {
+  // 将FixedSizeArena模式转换成MutableArena模式
+  if (IsFixedSizeArena()) {
+    auto ptr = Arena::Create<std::string>(arena, *tagged_ptr_.Get());
+    tagged_ptr_.SetMutableArena(ptr);
+    return ptr;
+  }
+
   ABSL_DCHECK(IsDefault());
 
   // For empty defaults, this ends up calling the default constructor which is
   // more efficient than a copy construction from
   // GetEmptyStringAlreadyInited().
-  return NewString(arena, lazy_default.get()...);
+  if (arena == nullptr) {
+    // 将Default模式转换成Allocated模式
+    auto ptr = new std::string(lazy_default.get()...);
+    tagged_ptr_.SetAllocated(ptr);
+    return ptr;
+  } else {
+    // 将Default模式转换成MutableArena模式
+    auto ptr = Arena::Create<std::string>(arena, lazy_default.get()...);
+    tagged_ptr_.SetMutableArena(ptr);
+    return ptr;
+  }
 }
 
 std::string* ArenaStringPtr::Release() {
@@ -248,7 +304,8 @@ void ArenaStringPtr::ClearToEmpty() {
     // UpdateArenaString uses assign when capacity is larger than the new
     // value, which is trivially true in the donated string case.
     // const_cast<std::string*>(PtrValue<std::string>())->clear();
-    tagged_ptr_.Get()->clear();
+    // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+    ClearNonDefaultToEmpty();
   }
 }
 
@@ -259,23 +316,45 @@ void ArenaStringPtr::ClearToDefault(const LazyString& default_value,
   if (IsDefault()) {
     // Already set to default -- do nothing.
   } else {
-    UnsafeMutablePointer()->assign(default_value.get());
+    // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+    Accessor(arena) = default_value.get();
   }
 }
 
-const char* EpsCopyInputStream::ReadArenaString(const char* ptr,
-                                                ArenaStringPtr* s,
-                                                Arena* arena) {
-  ScopedCheckPtrInvariants check(&s->tagged_ptr_);
-  ABSL_DCHECK(arena != nullptr);
+// FixedSizeArena模式实际执行
+const char* EpsCopyInputStream::ReadArenaString(const char* ptr, int size,
+                                                ArenaStringAccessor s) {
+  auto* buffer = s.__resize_default_init(size);
+
+  if (size <= buffer_end_ + kSlopBytes - ptr) {
+    memcpy(buffer, ptr, size);
+    return ptr + size;
+  }
 
-  int size = ReadSize(&ptr);
+  return AppendSize(ptr, size, [&](const char* p, int s) {
+    memcpy(buffer, p, s);
+    buffer += s;
+  });
+}
+
+// FixedSizeArena模式入口
+const char* EpsCopyInputStream::ReadArenaString(const char* ptr,
+                                                ArenaStringAccessor s) {
+  auto size = ReadSize(&ptr);
   if (!ptr) return nullptr;
+  return ReadArenaString(ptr, size, s);
+}
 
-  auto* str = s->NewString(arena);
-  ptr = ReadString(ptr, size, str);
-  GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-  return ptr;
+// 统一入口适配Allocated/MutableArena/FixedSizeArena模式
+const char* EpsCopyInputStream::ReadArenaString(const char* ptr,
+                                                MaybeArenaStringAccessor s) {
+  if (s.arena() != nullptr) {
+    return ReadArenaString(ptr, static_cast<ArenaStringAccessor&>(s));
+  }
+
+  auto size = ReadSize(&ptr);
+  if (!ptr) return nullptr;
+  return ReadString(ptr, size, s.underlying());
 }
 
 }  // namespace internal
diff --git a/src/google/protobuf/arenastring.h b/src/google/protobuf/arenastring.h
index dea2aecab..c7839ce3a 100644
--- a/src/google/protobuf/arenastring.h
+++ b/src/google/protobuf/arenastring.h
@@ -17,6 +17,7 @@
 #include "absl/log/absl_check.h"
 #include "absl/strings/string_view.h"
 #include "google/protobuf/arena.h"
+#include "google/protobuf/arenastring_impl.h"
 #include "google/protobuf/explicitly_constructed.h"
 #include "google/protobuf/port.h"
 
@@ -318,6 +319,10 @@ struct PROTOBUF_EXPORT ArenaStringPtr {
   // default value is lazily initialized.
   std::string* Mutable(Arena* arena);
   std::string* Mutable(const LazyString& default_value, Arena* arena);
+  // 返回可变的字符串引用，但是保留FixedSizeArena模式，而非转换到MutableArena模式
+  MaybeArenaStringAccessor MutableAccessor(Arena* arena);
+  MaybeArenaStringAccessor MutableAccessor(const LazyString& default_value,
+                                           Arena* arena);
 
   // Gets a mutable pointer with unspecified contents.
   // This function is identical to Mutable(), except it is optimized for the
@@ -395,14 +400,19 @@ struct PROTOBUF_EXPORT ArenaStringPtr {
       auto* s = new std::string(std::forward<Args>(args)...);
       return tagged_ptr_.SetAllocated(s);
     } else {
-      auto* s = Arena::Create<std::string>(arena, std::forward<Args>(args)...);
-      return tagged_ptr_.SetMutableArena(s);
+      // 初始进入FixedSizeArena模式
+      auto* s = ArenaStringAccessor::create(
+          arena, std::forward<Args>(args)...).underlying();
+      return tagged_ptr_.SetFixedSizeArena(s);
     }
   }
 
   TaggedStringPtr tagged_ptr_;
 
-  bool IsFixedSizeArena() const { return false; }
+  bool IsFixedSizeArena() const {
+    // 启用FixedSizeArena模式判定
+    return tagged_ptr_.IsFixedSizeArena();
+  }
 
   // Swaps tagged pointer without debug hardening. This is to allow python
   // protobuf to maintain pointer stability even in DEBUG builds.
@@ -411,6 +421,14 @@ struct PROTOBUF_EXPORT ArenaStringPtr {
     std::swap(lhs->tagged_ptr_, rhs->tagged_ptr_);
   }
 
+  // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+  PROTOBUF_ALWAYS_INLINE
+  inline MaybeArenaStringAccessor Accessor(Arena* arena) {
+    return MaybeArenaStringAccessor(
+            tagged_ptr_.IsFixedSizeArena() ? arena : nullptr,
+            tagged_ptr_.Get());
+  }
+
   friend class ::google::protobuf::internal::SwapFieldHelper;
   friend class TcParser;
 
@@ -519,8 +537,8 @@ inline PROTOBUF_NDEBUG_INLINE void ArenaStringPtr::InternalSwap(
 }
 
 inline void ArenaStringPtr::ClearNonDefaultToEmpty() {
-  // Unconditionally mask away the tag.
-  tagged_ptr_.Get()->clear();
+  // 统一访问器适配Allocated/MutableArena/FixedSizeArena模式
+  MaybeArenaStringAccessor::clear(tagged_ptr_.Get());
 }
 
 inline std::string* ArenaStringPtr::UnsafeMutablePointer() {
diff --git a/src/google/protobuf/arenastring_impl.cc b/src/google/protobuf/arenastring_impl.cc
new file mode 100644
index 000000000..c128b2ba0
--- /dev/null
+++ b/src/google/protobuf/arenastring_impl.cc
@@ -0,0 +1,155 @@
+#include "google/protobuf/arenastring_impl.h"
+
+#include "google/protobuf/port_def.inc"
+
+namespace google {
+namespace protobuf {
+
+ArenaStringAccessor& ArenaStringAccessor::assign(
+        const_pointer data, size_type size) noexcept {
+    auto* buffer = qualified_buffer(size);
+    set_size(size);
+    __builtin_memcpy(buffer, data, size);
+    buffer[size] = '\0';
+    return *this;
+}
+
+void ArenaStringAccessor::reserve(size_type required_capacity) noexcept {
+    if (required_capacity > capacity()) {
+        auto origin_size = size();
+        recreate_buffer(required_capacity);
+        set_size_and_terminator(origin_size);
+    }
+}
+
+void ArenaStringAccessor::push_back(value_type c) noexcept {
+    auto origin_size = size();
+    auto* buffer = qualified_buffer(origin_size + 1, origin_size << 1);
+    set_size(origin_size + 1);
+    buffer[origin_size] = c;
+    buffer[origin_size + 1] = '\0';
+}
+
+ArenaStringAccessor& ArenaStringAccessor::append(
+        const_pointer append_data, size_type append_size) noexcept {
+    auto origin_size = size();
+    auto* buffer = qualified_buffer(origin_size + append_size);
+    set_size(origin_size + append_size);
+    __builtin_memcpy(buffer + origin_size, append_data, append_size);
+    buffer[origin_size + append_size] = '\0';
+    return *this;
+}
+
+void ArenaStringAccessor::swap(ArenaStringAccessor other) noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+    auto* tmp = representation().data;
+    *reinterpret_cast<pointer*>(_ptr) = other.representation().data;
+    *reinterpret_cast<pointer*>(other._ptr) = tmp;
+#else // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+    _ptr->swap(*other._ptr);
+#endif // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+void ArenaStringAccessor::resize(size_type new_size, value_type c) noexcept {
+    auto origin_size = size();
+    auto buffer = qualified_buffer(new_size);
+    set_size_and_terminator(new_size);
+    if (new_size > origin_size) {
+        __builtin_memset(buffer + origin_size, c, new_size - origin_size);
+    }
+}
+ 
+internal::StdStringRep& ArenaStringAccessor::representation() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+    return *(*reinterpret_cast<StdStringRep**>(_ptr) - 1);
+#else // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+    return *reinterpret_cast<StdStringRep*>(_ptr);
+#endif // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+ArenaStringAccessor::pointer ArenaStringAccessor::recreate_buffer(
+        size_type capacity) noexcept {
+#if __GLIBCXX__
+    size_t buffer_size = capacity + 1;
+    buffer_size = (buffer_size + 7) & static_cast<size_t>(-8);
+    capacity = buffer_size - 1;
+#if _GLIBCXX_USE_CXX11_ABI
+    auto* buffer = reinterpret_cast<char*>(_arena->AllocateAligned(buffer_size));
+    __builtin_memcpy(buffer, data(), size());
+    auto& rep = representation();
+    rep.data = buffer;
+    rep.capacity = capacity;
+    return buffer;
+#else // !_GLIBCXX_USE_CXX11_ABI
+    auto* rep = reinterpret_cast<StdStringRep*>(_arena->AllocateAligned(
+            sizeof(StdStringRep) + buffer_size));
+    rep->capacity = capacity;
+    rep->refcount = -1;
+    __builtin_memcpy(rep->data, data(), size());
+    *reinterpret_cast<pointer*>(_ptr) = rep->data;
+    return rep->data;
+#endif // !_GLIBCXX_USE_CXX11_ABI
+#else // !__GLIBCXX__
+    capacity = (capacity + 16) & static_cast<size_type>(-16);
+    auto* buffer = reinterpret_cast<pointer>(_arena->AllocateAligned(capacity));
+    __builtin_memcpy(buffer, data(), size());
+    auto& rep = representation();
+    rep.long_format.data = buffer;
+    rep.long_format.capacity = capacity + 1;
+    return rep.long_format.data;
+#endif // !__GLIBCXX__
+}
+
+ArenaStringAccessor::pointer ArenaStringAccessor::writable_buffer() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+    return representation().refcount <= 0 ? representation().data : &(*_ptr)[0];
+#else // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+    return &(*_ptr)[0];
+#endif // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+void ArenaStringAccessor::set_size(size_type size) noexcept {
+#if __GLIBCXX__
+    auto& rep = representation();
+    rep.size = size;
+#else // !__GLIBCXX__
+    auto& rep = representation();
+    if (rep.is_long()) {
+        rep.long_format.size = size;
+    } else {
+        rep.shot_format.size = size << 1;
+    }
+#endif // !__GLIBCXX__
+}
+
+void ArenaStringAccessor::set_size_and_terminator(size_type size) noexcept {
+#if __GLIBCXX__
+    auto& rep = representation();
+    rep.size = size;
+    rep.data[size] = '\0';
+#else // !__GLIBCXX__
+    auto& rep = representation();
+    if (rep.is_long()) {
+        rep.long_format.size = size;
+        rep.long_format.data[size] = '\0';
+    } else {
+        rep.shot_format.size = size << 1;
+        rep.shot_format.data[size] = '\0';
+    }
+#endif // !__GLIBCXX__
+}
+
+void MaybeArenaStringAccessor::clear() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+    if (representation().refcount <= 0) {
+        ArenaStringAccessor::clear();
+        return;
+    }
+#endif // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+    underlying()->clear();
+}
+
+} // namespace protobuf
+} // namespace google
+
+#include "google/protobuf/port_undef.inc"
diff --git a/src/google/protobuf/arenastring_impl.h b/src/google/protobuf/arenastring_impl.h
new file mode 100644
index 000000000..7928c4bf0
--- /dev/null
+++ b/src/google/protobuf/arenastring_impl.h
@@ -0,0 +1,529 @@
+#pragma once
+
+// feature check macro
+#define GOOGLE_PROTOBUF_HAS_DONATED_STRING 1
+
+#include "google/protobuf/arena.h"
+#if defined(__has_include) && __has_include("google/protobuf/config.h")
+#include "google/protobuf/config.h"
+#endif
+
+#include "absl/strings/internal/resize_uninitialized.h"
+
+#include "google/protobuf/port_def.inc"
+
+namespace google {
+namespace protobuf {
+
+namespace internal {
+
+#if __GLIBCXX__
+#if _GLIBCXX_USE_CXX11_ABI
+struct StdStringRep {
+    char* data;
+    uint64_t size;
+    union {
+        uint64_t capacity;
+        char local[16];
+    };
+};
+#else // !_GLIBCXX_USE_CXX11_ABI
+struct StdStringRep {
+    uint64_t size;
+    uint64_t capacity;
+    int32_t refcount;
+    uint32_t gap;
+    char data[0];
+};
+#endif // !_GLIBCXX_USE_CXX11_ABI
+#elif _LIBCPP_VERSION // && !__GLIBCXX__
+#if _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT 
+static_assert(false, "don not support _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT yet");
+#endif // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
+#if _LIBCPP_BIG_ENDIAN
+static_assert(false, "don not support _LIBCPP_BIG_ENDIAN yet");
+#endif // _LIBCPP_BIG_ENDIAN
+union StdStringRep {
+    struct {
+        typename ::std::string::size_type capacity;
+        typename ::std::string::size_type size;
+        typename ::std::string::pointer data;
+    } long_format;
+    struct {
+        uint8_t size;
+        typename ::std::string::value_type data[0];
+    } shot_format;
+
+    inline bool is_long() const noexcept {
+        return shot_format.size & 0x01;
+    }
+
+    inline ::std::string::size_type long_capacity() const noexcept {
+        return long_format.capacity & ~static_cast<::std::string::size_type>(0x01);
+    }
+};
+#endif // _LIBCPP_VERSION && !__GLIBCXX__
+} // internal
+
+// ArenaString的访问器，操作明确分配在Arena上的string
+class ArenaStringAccessor {
+public:
+    typedef typename ::std::string::value_type value_type;
+    typedef typename ::std::string::traits_type traits_type;
+    typedef typename ::std::string::allocator_type allocator_type;
+    typedef typename ::std::string::size_type size_type;
+    typedef typename ::std::string::difference_type difference_type;
+    typedef typename ::std::string::reference reference;
+    typedef typename ::std::string::const_reference const_reference;
+    typedef typename ::std::string::pointer pointer;
+    typedef typename ::std::string::const_pointer const_pointer;
+    typedef pointer iterator;
+    typedef const_pointer const_iterator;
+    typedef ::std::reverse_iterator<pointer> reverse_iterator;
+    typedef ::std::reverse_iterator<const_pointer> const_reverse_iterator;
+    typedef internal::StdStringRep StdStringRep;
+
+    // 禁用默认构造和拷贝和移动赋值，避免出错
+    inline ArenaStringAccessor() = delete;
+    inline ArenaStringAccessor(ArenaStringAccessor&&) noexcept = default;
+    inline ArenaStringAccessor(const ArenaStringAccessor&) noexcept = default;
+    inline ArenaStringAccessor& operator=(ArenaStringAccessor&&) = delete;
+    inline ArenaStringAccessor& operator=(const ArenaStringAccessor&) = delete;
+
+    // 赋值
+    inline ArenaStringAccessor& operator=(::absl::string_view other) noexcept {
+        return assign(other.data(), other.size());
+    }
+    inline ArenaStringAccessor& assign(::absl::string_view other) noexcept {
+        return assign(other.data(), other.size());
+    }
+    ArenaStringAccessor& assign(const_pointer data, size_type size) noexcept;
+    template <typename T>
+    inline ArenaStringAccessor& operator=(::std::reference_wrapper<T> other) noexcept {
+        return assign(other);
+    }
+    template <typename T>
+    inline ArenaStringAccessor& assign(::std::reference_wrapper<T> other) noexcept {
+        return assign(other.get());
+    }
+
+    // 访问
+    inline reference operator[](size_type position) noexcept {
+        return writable_buffer()[position];
+    }
+    inline const_reference operator[](size_type position) const noexcept {
+        return data()[position];
+    }
+    inline const_pointer data() const noexcept {
+        return c_str();
+    }
+    inline const_pointer c_str() const noexcept {
+        return static_cast<const ::std::string*>(_ptr)->c_str();
+    }
+    inline operator ::absl::string_view() const noexcept {
+        return ::absl::string_view(data(), size());
+    }
+    inline operator const ::std::string&() const noexcept {
+        return *_ptr;
+    }
+
+    // 迭代器
+    inline iterator begin() noexcept {
+        return iterator(writable_buffer());
+    }
+    inline const_iterator cbegin() const noexcept {
+        return const_iterator(data());
+    }
+    inline const_iterator end() noexcept {
+        return iterator(writable_buffer() + size());
+    }
+    inline const_iterator cend() const noexcept {
+        return const_iterator(data() + size());
+    }
+
+    // 容量
+    inline bool empty() const noexcept {
+        return _ptr->empty();
+    }
+    inline size_type size() const noexcept {
+        return _ptr->size();
+    }
+    void reserve(size_type required_capacity) noexcept;
+    inline size_type capacity() const noexcept {
+        return _ptr->capacity();
+    }
+
+    // 操作
+    inline void clear() noexcept {
+        set_size_and_terminator(0);
+    }
+
+    // ArenaStringAccessor& insert(size_type index, size_type count, value_type value);
+    // ArenaStringAccessor& erase(size_type index, size_type count);
+
+    void push_back(value_type c) noexcept;
+
+    // void pop_back();
+
+    inline ArenaStringAccessor& append(::absl::string_view sv) noexcept {
+        return append(sv.data(), sv.size());
+    }
+
+    ArenaStringAccessor& append(const_pointer append_data,
+                                size_type append_size) noexcept;
+
+    inline ArenaStringAccessor& operator+=(char ch) noexcept {
+        push_back(ch);
+        return *this;
+    }
+
+    inline ArenaStringAccessor& operator+=(::absl::string_view sv) noexcept {
+        return append(sv.data(), sv.size());
+    }
+
+    inline int compare(::absl::string_view other) const noexcept {
+        return static_cast<::absl::string_view>(*this).compare(other);
+    }
+
+    void swap(ArenaStringAccessor other) noexcept;
+
+    // size_type find(value_type value, size_type pos) const;
+    
+    void resize(size_type new_size) noexcept {
+        resize(new_size, '\0');
+    }
+    void resize(size_type new_size, value_type c) noexcept;
+
+    ////////////////////////////////////////////////////////////////////////////
+    // 不同于std::string的特殊功能
+
+    // 包装构造，用于从ArenaStringPtr将Arena和ptr打包返回
+    inline ArenaStringAccessor(Arena* arena, ::std::string* ptr) noexcept :
+        _arena(arena), _ptr(ptr) {}
+
+    inline Arena* arena() const noexcept {
+        return _arena;
+    }
+
+    inline ::std::string* underlying() const noexcept {
+        return _ptr;
+    }
+
+    inline char* __resize_default_init(size_type new_size) noexcept {
+        auto buffer = qualified_buffer(new_size);
+        set_size_and_terminator(new_size);
+        return buffer;
+    }
+
+    inline static ArenaStringAccessor create(Arena* arena) noexcept {
+        // ArenaString不需要析构和释放内存，因此不能采用Arena::Create<::std::string>(arena)
+        // 独立进行分配和构造两个动作
+        auto* ptr = reinterpret_cast<::std::string*>(arena->AllocateAligned(sizeof(::std::string)));
+        new (ptr) ::std::string();
+        return ArenaStringAccessor(arena, ptr);
+    }
+
+    template <typename T>
+    inline static ArenaStringAccessor create(Arena* arena, T&& value) noexcept {
+        return create(arena) = ::std::forward<T>(value);
+    }
+
+    // clear动作不需要使用arena，可以直接对string生效
+    inline static void clear(::std::string* ptr) noexcept {
+        ArenaStringAccessor(nullptr, ptr).clear();
+    }
+
+    // swap动作不需要使用arena，可以直接对string生效
+    inline static void swap(::std::string* left, ::std::string* right) noexcept {
+        ArenaStringAccessor(nullptr, left).swap(
+                ArenaStringAccessor(nullptr, right));
+    }
+    ////////////////////////////////////////////////////////////////////////////
+
+protected:
+    StdStringRep& representation() noexcept;
+
+    pointer recreate_buffer(size_type capacity) noexcept;
+
+    pointer writable_buffer() noexcept;
+
+    inline pointer qualified_buffer(size_type required_capacity,
+                                    size_type predict_capacity) noexcept{
+        return required_capacity <= capacity() ? writable_buffer() : recreate_buffer(predict_capacity);
+    }
+
+    inline pointer qualified_buffer(size_type required_capacity) noexcept {
+        return qualified_buffer(required_capacity, required_capacity);
+    }
+
+    void set_size(size_type size) noexcept;
+
+    void set_size_and_terminator(size_type size) noexcept;
+
+    Arena* _arena;
+    ::std::string* _ptr;
+};
+
+inline bool operator==(const ArenaStringAccessor& left, const ArenaStringAccessor& right) noexcept {
+    return *left.underlying() == *right.underlying();
+}
+
+inline bool operator==(::absl::string_view left, const ArenaStringAccessor& right) noexcept {
+    return left == *right.underlying();
+}
+
+inline bool operator==(const ArenaStringAccessor& left, ::absl::string_view right) noexcept {
+    return *left.underlying() == right;
+}
+
+inline bool operator!=(const ArenaStringAccessor& left, const ArenaStringAccessor& right) noexcept {
+    return !(left == right);
+}
+
+inline bool operator!=(::absl::string_view left, const ArenaStringAccessor& right) noexcept {
+    return !(left == right);
+}
+
+inline bool operator!=(const ArenaStringAccessor& left, ::absl::string_view right) noexcept {
+    return !(left == right);
+}
+
+inline bool operator<(const ArenaStringAccessor& left, const ArenaStringAccessor& right) noexcept {
+    return *left.underlying() < *right.underlying();
+}
+
+inline bool operator<(::absl::string_view left, const ArenaStringAccessor& right) noexcept {
+    return left < *right.underlying();
+}
+
+inline bool operator<(const ArenaStringAccessor& left, ::absl::string_view right) noexcept {
+    return *left.underlying() < right;
+}
+
+inline bool operator<=(const ArenaStringAccessor& left, const ArenaStringAccessor& right) noexcept {
+    return *left.underlying() <= *right.underlying();
+}
+
+inline bool operator<=(::absl::string_view left, const ArenaStringAccessor& right) noexcept {
+    return left <= *right.underlying();
+}
+
+inline bool operator<=(const ArenaStringAccessor& left, ::absl::string_view right) noexcept {
+    return *left.underlying() <= right;
+}
+
+inline bool operator>(const ArenaStringAccessor& left, const ArenaStringAccessor& right) noexcept {
+    return *left.underlying() > *right.underlying();
+}
+
+inline bool operator>(::absl::string_view left, const ArenaStringAccessor& right) noexcept {
+    return left > *right.underlying();
+}
+
+inline bool operator>(const ArenaStringAccessor& left, ::absl::string_view right) noexcept {
+    return *left.underlying() > right;
+}
+
+inline bool operator>=(const ArenaStringAccessor& left, const ArenaStringAccessor& right) noexcept {
+    return *left.underlying() >= *right.underlying();
+}
+
+inline bool operator>=(::absl::string_view left, const ArenaStringAccessor& right) noexcept {
+    return left >= *right.underlying();
+}
+
+inline bool operator>=(const ArenaStringAccessor& left, ::absl::string_view right) noexcept {
+    return *left.underlying() >= right;
+}
+
+class MaybeArenaStringAccessor : public ArenaStringAccessor {
+public:
+    using ArenaStringAccessor::ArenaStringAccessor;
+
+    MaybeArenaStringAccessor(const ArenaStringAccessor& other) noexcept : ArenaStringAccessor(other) {}
+
+    // 赋值
+    template <typename T>
+    inline MaybeArenaStringAccessor& operator=(T&& other) {
+        return assign(::std::forward<T>(other));
+    }
+    template <typename T>
+    inline MaybeArenaStringAccessor& assign(T&& other) {
+        ::absl::string_view sv(::std::forward<T>(other));
+        return assign(sv.data(), sv.size());
+    }
+    inline MaybeArenaStringAccessor& assign(const_pointer data, size_type size) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::assign(data, size);
+        } else {
+            underlying()->assign(data, size);
+        }
+        return *this;
+    }
+
+    // string单独处理，避免在非Arena场景下失去copy on write
+    inline MaybeArenaStringAccessor& operator=(const ::std::string& other) {
+        return assign(other);
+    }
+    inline MaybeArenaStringAccessor& assign(const ::std::string& other) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::assign(other);
+        } else {
+            underlying()->assign(other);
+        }
+        return *this;
+    }
+    inline MaybeArenaStringAccessor& operator=(::std::string& other) {
+        return assign(static_cast<const ::std::string&>(other));
+    }
+    inline MaybeArenaStringAccessor& assign(::std::string& other) {
+        return assign(static_cast<const ::std::string&>(other));
+    }
+    inline MaybeArenaStringAccessor& operator=(::std::string&& other) {
+        return assign(::std::move(other));
+    }
+    inline MaybeArenaStringAccessor& assign(::std::string&& other) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::assign(other);
+        } else {
+            underlying()->assign(::std::move(other));
+        }
+        return *this;
+    }
+    template <typename T>
+    inline MaybeArenaStringAccessor& operator=(::std::reference_wrapper<T> other) {
+        return assign(other);
+    }
+    template <typename T>
+    inline MaybeArenaStringAccessor& assign(::std::reference_wrapper<T> other) {
+        return assign(other.get());
+    }
+
+    inline void reserve(size_type required_capacity) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::reserve(required_capacity);
+        } else if (required_capacity > capacity()) {
+            underlying()->reserve(required_capacity);
+        }
+    }
+
+    void clear() noexcept;
+
+    inline void push_back(value_type c) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::push_back(c);
+        } else {
+            underlying()->push_back(c);
+        }
+    }
+
+    inline MaybeArenaStringAccessor& append(::absl::string_view sv) {
+        return append(sv.data(), sv.size());
+    }
+
+    inline MaybeArenaStringAccessor& append(const_pointer data, size_type size) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::append(data, size);
+        } else {
+            underlying()->append(data, size);
+        }
+        return *this;
+    }
+
+    inline MaybeArenaStringAccessor& operator+=(char ch) noexcept {
+        push_back(ch);
+        return *this;
+    }
+
+    inline MaybeArenaStringAccessor& operator+=(::absl::string_view sv) noexcept {
+        return append(sv.data(), sv.size());
+    }
+
+    inline void resize(size_type size) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::resize(size);
+        } else {
+            underlying()->resize(size);
+        }
+    }
+    inline void resize(size_type size, value_type c) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::resize(size, c);
+        } else {
+            underlying()->resize(size, c);
+        }
+    }
+
+    ////////////////////////////////////////////////////////////////////////////
+    // 修改ArenaStringAccessor中不同于std::string的特殊功能
+
+    inline MaybeArenaStringAccessor(::std::string* string) noexcept :
+        ArenaStringAccessor(nullptr, string) {}
+
+    using ArenaStringAccessor::arena;
+    using ArenaStringAccessor::underlying;
+
+    inline void __resize_default_init(size_type new_size) noexcept {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::__resize_default_init(new_size);
+        } else {
+            ::absl::strings_internal::STLStringResizeUninitialized(
+                    underlying(), new_size);
+        }
+    }
+
+    inline static MaybeArenaStringAccessor create(Arena* arena) {
+        if (arena != nullptr) {
+            return ArenaStringAccessor::create(arena);
+        } else {
+            return MaybeArenaStringAccessor(new ::std::string);
+        }
+    }
+    
+    template <typename T>
+    inline static MaybeArenaStringAccessor create(Arena* arena, T&& value) {
+        return create(arena) = ::std::forward<T>(value);
+    }
+    ////////////////////////////////////////////////////////////////////////////
+
+    ////////////////////////////////////////////////////////////////////////////
+    // 提供更多不同于std::string的特殊功能
+
+    // 仿自身指针，以便尽量接近std::string*的行为
+    inline MaybeArenaStringAccessor* operator->() {
+        return this;
+    }
+    inline const MaybeArenaStringAccessor* operator->() const {
+        return this;
+    }
+    inline MaybeArenaStringAccessor& operator*() {
+        return *this;
+    }
+    inline const MaybeArenaStringAccessor& operator*() const {
+        return *this;
+    }
+
+    inline static void clear(::std::string* ptr) noexcept {
+        MaybeArenaStringAccessor(ptr).clear();
+    }
+    ////////////////////////////////////////////////////////////////////////////
+    
+    inline void destroy() noexcept {
+        if (arena() == nullptr) {
+            delete underlying();
+        }
+    }
+};
+
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+using MutableStringType = MaybeArenaStringAccessor;
+using MutableStringReferenceType = MaybeArenaStringAccessor;
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+using MutableStringType = ::std::string*;
+using MutableStringReferenceType = ::std::string&;
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+
+} // namespace protobuf
+} // namespace google
+
+#include "google/protobuf/port_undef.inc"
diff --git a/src/google/protobuf/compiler/cpp/field.cc b/src/google/protobuf/compiler/cpp/field.cc
index e9ccf46bb..dfa6a5ae9 100644
--- a/src/google/protobuf/compiler/cpp/field.cc
+++ b/src/google/protobuf/compiler/cpp/field.cc
@@ -306,7 +306,7 @@ void InlinedStringVars(const FieldDescriptor* field, const Options& opts,
                                 : "_impl_._inlined_string_donated_";
 
   vars.emplace_back("inlined_string_donated",
-                    absl::StrFormat("(%s[%d] & %s) != 0;", array, index, mask));
+                    absl::StrFormat("(%s[%d] & %s) != 0", array, index, mask));
   vars.emplace_back("donating_states_word",
                     absl::StrFormat("%s[%d]", array, index));
   vars.emplace_back("mask_for_undonate", absl::StrFormat("~%s", mask));
diff --git a/src/google/protobuf/compiler/cpp/field_generators/string_field.cc b/src/google/protobuf/compiler/cpp/field_generators/string_field.cc
index 748a8d688..118e29ffe 100644
--- a/src/google/protobuf/compiler/cpp/field_generators/string_field.cc
+++ b/src/google/protobuf/compiler/cpp/field_generators/string_field.cc
@@ -76,7 +76,8 @@ class SingularString : public FieldGeneratorBase {
   bool IsInlined() const override { return is_inlined(); }
 
   ArenaDtorNeeds NeedsArenaDestructor() const override {
-    return is_inlined() ? ArenaDtorNeeds::kOnDemand : ArenaDtorNeeds::kNone;
+    // 目前透出代码中看OnDemand实现并不健全，实际改为了None
+    return ArenaDtorNeeds::kNone;
   }
 
   void GeneratePrivateMembers(io::Printer* p) const override {
@@ -94,15 +95,8 @@ class SingularString : public FieldGeneratorBase {
     )cc");
   }
 
-  void GenerateArenaDestructorCode(io::Printer* p) const override {
-    if (!is_inlined()) return;
-
-    p->Emit(R"cc(
-      if (!_this->_internal_$name$_donated()) {
-        _this->$field_$.~InlinedStringField();
-      }
-    )cc");
-  }
+  // 目前透出代码中看OnDemand实现并不健全，实际改为了None
+  // void GenerateArenaDestructorCode(io::Printer* p) const override;
 
   void GenerateNonInlineAccessorDefinitions(io::Printer* p) const override {
     if (EmptyDefault()) return;
@@ -247,7 +241,16 @@ void SingularString::GenerateAccessorDeclarations(io::Printer* p) const {
           p->Emit(R"cc(
             inline PROTOBUF_ALWAYS_INLINE bool _internal_$name$_donated() const;
           )cc");
-        }}},
+        }},
+       // 根据cc_mutable_donated_string开关，控制mutable_xxx接口行为和返回值
+       {"mutable_return_type", [&] {
+         if (descriptor_->file()->options().cc_mutable_donated_string()) {
+           p->Emit("$pb$::MaybeArenaStringAccessor");
+         } else {
+           p->Emit("std::string*");
+         }
+       }},
+      },
       R"cc(
         $DEPRECATED$ const std::string& $name$() const;
         //~ Using `Arg_ = const std::string&` will make the type of `arg`
@@ -256,7 +259,7 @@ void SingularString::GenerateAccessorDeclarations(io::Printer* p) const {
         //~ default.
         template <typename Arg_ = const std::string&, typename... Args_>
         $DEPRECATED$ void $set_name$(Arg_&& arg, Args_... args);
-        $DEPRECATED$ std::string* $mutable_name$();
+        $DEPRECATED$ $mutable_return_type$ $mutable_name$();
         $DEPRECATED$ PROTOBUF_NODISCARD std::string* $release_name$();
         $DEPRECATED$ void $set_allocated_name$(std::string* value);
 
@@ -265,6 +268,7 @@ void SingularString::GenerateAccessorDeclarations(io::Printer* p) const {
         inline PROTOBUF_ALWAYS_INLINE void _internal_set_$name$(
             const std::string& value);
         std::string* _internal_mutable_$name$();
+        $pb$::MaybeArenaStringAccessor _internal_mutable_$name$_accessor();
         $donated$;
 
         public:
@@ -311,32 +315,24 @@ void SingularString::ReleaseImpl(io::Printer* p) const {
     return;
   }
 
-  if (!HasHasbit(field_)) {
-    p->Emit(R"cc(
-      return $field_$.Release();
-    )cc");
-    return;
-  }
-
-  if (is_inlined()) {
+  // optional字段也可以是inline的，更换顺序统一生效
+  if (HasHasbit(field_)) {
     p->Emit(R"cc(
       if (($has_hasbit$) == 0) {
         return nullptr;
       }
       $clear_hasbit$;
+    )cc");
+  }
 
+  // optional字段也可以是inline的，更换顺序确保使用正确的API
+  if (is_inlined()) {
+    p->Emit(R"cc(
       return $field_$.Release(GetArena(), _internal_$name$_donated());
     )cc");
     return;
   }
 
-  p->Emit(R"cc(
-    if (($has_hasbit$) == 0) {
-      return nullptr;
-    }
-    $clear_hasbit$;
-  )cc");
-
   if (!EmptyDefault()) {
     p->Emit(R"cc(
       return $field_$.Release();
@@ -427,6 +423,19 @@ void SingularString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
            SafeFunctionName(field_->containing_type(), field_, "release_")},
           {"release_impl", [&] { ReleaseImpl(p); }},
           {"set_allocated_impl", [&] { SetAllocatedImpl(p); }},
+          // 根据cc_mutable_donated_string开关，控制mutable_xxx接口行为和返回值
+          {"mutable_return_type", [&] {
+             if (descriptor_->file()->options().cc_mutable_donated_string()) {
+               p->Emit("$pb$::MaybeArenaStringAccessor");
+             } else {
+               p->Emit("std::string*");
+             }
+           }},
+          {"mutable_suffix", [&] {
+             if (descriptor_->file()->options().cc_mutable_donated_string()) {
+               p->Emit("_accessor");
+             }
+           }},
       },
       R"cc(
         inline const std::string& $Msg$::$name$() const
@@ -446,9 +455,9 @@ void SingularString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
           $annotate_set$;
           // @@protoc_insertion_point(field_set:$pkg.Msg.field$)
         }
-        inline std::string* $Msg$::mutable_$name$() ABSL_ATTRIBUTE_LIFETIME_BOUND {
+        inline $mutable_return_type$ $Msg$::mutable_$name$() ABSL_ATTRIBUTE_LIFETIME_BOUND {
           $PrepareSplitMessageForWrite$;
-          std::string* _s = _internal_mutable_$name$();
+          auto _s = _internal_mutable_$name$$mutable_suffix$();
           $annotate_mutable$;
           // @@protoc_insertion_point(field_mutable:$pkg.Msg.field$)
           return _s;
@@ -470,6 +479,11 @@ void SingularString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
           $update_hasbit$;
           return $field_$.Mutable($lazy_args$, $set_args$);
         }
+        inline $pb$::MaybeArenaStringAccessor $Msg$::_internal_mutable_$name$_accessor() {
+          $TsanDetectConcurrentMutation$;
+          $update_hasbit$;
+          return $field_$.MutableAccessor($lazy_args$, $set_args$);
+        }
         inline std::string* $Msg$::$release_name$() {
           $TsanDetectConcurrentMutation$;
           $annotate_release$;
@@ -830,15 +844,24 @@ void RepeatedString::GenerateAccessorDeclarations(io::Printer* p) const {
   auto v3 = p->WithVars(
       AnnotatedAccessors(field_, {"mutable_"}, AnnotationCollector::kAlias));
 
-  p->Emit(R"cc(
+  // 根据cc_mutable_donated_string开关，控制mutable_xxx接口行为和返回值
+  p->Emit({{"mutable_return_type",
+            [&] {
+              if (descriptor_->file()->options().cc_mutable_donated_string()) {
+                p->Emit("$pb$::MaybeArenaStringAccessor");
+              } else {
+                p->Emit("std::string*");
+              }
+            }}},
+          R"cc(
     $DEPRECATED$ const std::string& $name$(int index) const;
-    $DEPRECATED$ std::string* $mutable_name$(int index);
+    $DEPRECATED$ $mutable_return_type$ $mutable_name$(int index);
     $DEPRECATED$ void $set_name$(int index, const std::string& value);
     $DEPRECATED$ void $set_name$(int index, std::string&& value);
     $DEPRECATED$ void $set_name$(int index, const char* value);
     $DEPRECATED$ void $set_name$(int index, const $byte$* value, std::size_t size);
     $DEPRECATED$ void $set_name$(int index, absl::string_view value);
-    $DEPRECATED$ std::string* $add_name$();
+    $DEPRECATED$ $mutable_return_type$ $add_name$();
     $DEPRECATED$ void $add_name$(const std::string& value);
     $DEPRECATED$ void $add_name$(std::string&& value);
     $DEPRECATED$ void $add_name$(const char* value);
@@ -862,12 +885,29 @@ void RepeatedString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
               p->Emit(opts_->safe_boundary_check
                           ? ", $pbi$::GetEmptyStringAlreadyInited()"
                           : "");
-            }}},
+            }},
+           // 根据cc_mutable_donated_string开关，控制mutable_xxx接口行为和返回值
+           {"mutable_return_type",
+            [&] {
+              if (descriptor_->file()->options().cc_mutable_donated_string()) {
+                p->Emit("$pb$::MaybeArenaStringAccessor");
+              } else {
+                p->Emit("std::string*");
+              }
+            }},
+            {"mutable_suffix", [&] {
+               if (descriptor_->file()->options().cc_mutable_donated_string()) {
+                 p->Emit("Accessor");
+               } else {
+                 p->Emit("String");
+               }
+             }},
+          },
           R"cc(
-            inline std::string* $Msg$::add_$name$()
+            inline $mutable_return_type$ $Msg$::add_$name$()
                 ABSL_ATTRIBUTE_LIFETIME_BOUND {
               $TsanDetectConcurrentMutation$;
-              std::string* _s = _internal_mutable_$name$()->Add();
+              auto _s = _internal_mutable_$name$()->Add$mutable_suffix$();
               $annotate_add_mutable$;
               // @@protoc_insertion_point(field_add_mutable:$pkg.Msg.field$)
               return _s;
@@ -878,44 +918,45 @@ void RepeatedString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
               // @@protoc_insertion_point(field_get:$pkg.Msg.field$)
               return _internal_$name$().$Get$(index$GetExtraArg$);
             }
-            inline std::string* $Msg$::mutable_$name$(int index)
+            inline $mutable_return_type$ $Msg$::mutable_$name$(int index)
                 ABSL_ATTRIBUTE_LIFETIME_BOUND {
               $annotate_mutable$;
               // @@protoc_insertion_point(field_mutable:$pkg.Msg.field$)
-              return _internal_mutable_$name$()->Mutable(index);
+              return _internal_mutable_$name$()->Mutable$mutable_suffix$(index);
             }
             inline void $Msg$::set_$name$(int index, const std::string& value) {
-              _internal_mutable_$name$()->Mutable(index)->assign(value);
+              _internal_mutable_$name$()->MutableAccessor(index)->assign(value);
               $annotate_set$;
               // @@protoc_insertion_point(field_set:$pkg.Msg.field$)
             }
             inline void $Msg$::set_$name$(int index, std::string&& value) {
-              _internal_mutable_$name$()->Mutable(index)->assign(std::move(value));
+              _internal_mutable_$name$()->MutableAccessor(index)->assign(
+                  std::move(value));
               $annotate_set$;
               // @@protoc_insertion_point(field_set:$pkg.Msg.field$)
             }
             inline void $Msg$::set_$name$(int index, const char* value) {
               $DCHK$(value != nullptr);
-              _internal_mutable_$name$()->Mutable(index)->assign(value);
+              _internal_mutable_$name$()->MutableAccessor(index)->assign(value);
               $annotate_set$;
               // @@protoc_insertion_point(field_set_char:$pkg.Msg.field$)
             }
             inline void $Msg$::set_$name$(int index, const $byte$* value,
                                           std::size_t size) {
-              _internal_mutable_$name$()->Mutable(index)->assign(
+              _internal_mutable_$name$()->MutableAccessor(index)->assign(
                   reinterpret_cast<const char*>(value), size);
               $annotate_set$;
               // @@protoc_insertion_point(field_set_pointer:$pkg.Msg.field$)
             }
             inline void $Msg$::set_$name$(int index, absl::string_view value) {
-              _internal_mutable_$name$()->Mutable(index)->assign(value.data(),
-                                                                 value.size());
+              _internal_mutable_$name$()->MutableAccessor(index)->assign(
+                  value.data(), value.size());
               $annotate_set$;
               // @@protoc_insertion_point(field_set_string_piece:$pkg.Msg.field$)
             }
             inline void $Msg$::add_$name$(const std::string& value) {
               $TsanDetectConcurrentMutation$;
-              _internal_mutable_$name$()->Add()->assign(value);
+              _internal_mutable_$name$()->AddAccessor()->assign(value);
               $annotate_add$;
               // @@protoc_insertion_point(field_add:$pkg.Msg.field$)
             }
@@ -928,20 +969,20 @@ void RepeatedString::GenerateInlineAccessorDefinitions(io::Printer* p) const {
             inline void $Msg$::add_$name$(const char* value) {
               $DCHK$(value != nullptr);
               $TsanDetectConcurrentMutation$;
-              _internal_mutable_$name$()->Add()->assign(value);
+              _internal_mutable_$name$()->AddAccessor()->assign(value);
               $annotate_add$;
               // @@protoc_insertion_point(field_add_char:$pkg.Msg.field$)
             }
             inline void $Msg$::add_$name$(const $byte$* value, std::size_t size) {
               $TsanDetectConcurrentMutation$;
-              _internal_mutable_$name$()->Add()->assign(
+              _internal_mutable_$name$()->AddAccessor()->assign(
                   reinterpret_cast<const char*>(value), size);
               $annotate_add$;
               // @@protoc_insertion_point(field_add_pointer:$pkg.Msg.field$)
             }
             inline void $Msg$::add_$name$(absl::string_view value) {
               $TsanDetectConcurrentMutation$;
-              _internal_mutable_$name$()->Add()->assign(value.data(), value.size());
+              _internal_mutable_$name$()->AddAccessor()->assign(value.data(), value.size());
               $annotate_add$;
               // @@protoc_insertion_point(field_add_string_piece:$pkg.Msg.field$)
             }
diff --git a/src/google/protobuf/compiler/cpp/helpers.cc b/src/google/protobuf/compiler/cpp/helpers.cc
index 2c8d27511..38aa21cdd 100644
--- a/src/google/protobuf/compiler/cpp/helpers.cc
+++ b/src/google/protobuf/compiler/cpp/helpers.cc
@@ -924,7 +924,20 @@ bool IsStringInliningEnabled(const Options& options) {
 bool IsStringInlined(const FieldDescriptor* field, const Options& options) {
   (void)field;
   (void)options;
-  return false;
+  // 复用cc_mutable_donated_string开关，同时启用InlinedStringField
+  return field->file()->options().cc_mutable_donated_string() &&
+         // 仅针对string/bytes类型
+         field->cpp_type() == FieldDescriptor::CPPTYPE_STRING &&
+         // 排除Cord等其他ctype
+         internal::cpp::EffectiveStringCType(field) == FieldOptions::STRING &&
+         // 排除oneof内的字段
+         !field->real_containing_oneof() &&
+         // 排除repeated
+         !field->is_repeated() &&
+         // 排除map内部字段
+         !field->containing_type()->options().map_entry() &&
+         // 不支持默认值
+         !field->has_default_value();
 }
 
 static bool HasLazyFields(const Descriptor* descriptor, const Options& options,
diff --git a/src/google/protobuf/compiler/cpp/message.cc b/src/google/protobuf/compiler/cpp/message.cc
index 08fd28f69..b2b138948 100644
--- a/src/google/protobuf/compiler/cpp/message.cc
+++ b/src/google/protobuf/compiler/cpp/message.cc
@@ -1925,23 +1925,30 @@ void MessageGenerator::GenerateInlineMethods(io::Printer* p) {
 
 void MessageGenerator::GenerateSchema(io::Printer* p, int offset,
                                       int has_offset) {
-  has_offset = !has_bit_indices_.empty() || IsMapEntryMessage(descriptor_)
-                   ? offset + has_offset
-                   : -1;
+  // 一个Message的使用的schema信息在offset段中构成是
+  // <metadata>[has_bit_indices][inlined_string_indices]
+  // has_offset = sizeof(metadata)
+  // offset = base offset of metadata
+  // 原先的写法当has_bit_indices为空，但inlined_string_indices非空时
+  // 无法正确支持，可能和这段从google开源过程中的删减有关
+  // 这里按照远离调整为能够正确计算
+  int has_bit_indices_offset = !has_bit_indices_.empty() || IsMapEntryMessage(descriptor_)
+                                   ? offset + has_offset
+                                   : -1;
   int inlined_string_indices_offset;
   if (inlined_string_indices_.empty()) {
     inlined_string_indices_offset = -1;
   } else {
     ABSL_DCHECK_NE(has_offset, -1);
     ABSL_DCHECK(!IsMapEntryMessage(descriptor_));
-    inlined_string_indices_offset = has_offset + has_bit_indices_.size();
+    inlined_string_indices_offset = offset + has_offset + has_bit_indices_.size();
   }
 
   auto v = p->WithVars(ClassVars(descriptor_, options_));
   p->Emit(
       {
           {"offset", offset},
-          {"has_offset", has_offset},
+          {"has_offset", has_bit_indices_offset},
           {"string_offsets", inlined_string_indices_offset},
       },
       R"cc(
diff --git a/src/google/protobuf/compiler/plugin.pb.h b/src/google/protobuf/compiler/plugin.pb.h
index 2fcfe1489..b8a28db5c 100644
--- a/src/google/protobuf/compiler/plugin.pb.h
+++ b/src/google/protobuf/compiler/plugin.pb.h
@@ -273,6 +273,7 @@ class PROTOC_EXPORT Version final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(
       const std::string& value);
   std::string* _internal_mutable_suffix();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_suffix_accessor();
 
   public:
   // optional int32 major = 1;
@@ -495,6 +496,7 @@ class PROTOC_EXPORT CodeGeneratorResponse_File final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional string insertion_point = 2;
@@ -512,6 +514,7 @@ class PROTOC_EXPORT CodeGeneratorResponse_File final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_insertion_point(
       const std::string& value);
   std::string* _internal_mutable_insertion_point();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_insertion_point_accessor();
 
   public:
   // optional string content = 15;
@@ -529,6 +532,7 @@ class PROTOC_EXPORT CodeGeneratorResponse_File final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
       const std::string& value);
   std::string* _internal_mutable_content();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_content_accessor();
 
   public:
   // optional .google.protobuf.GeneratedCodeInfo generated_code_info = 16;
@@ -773,6 +777,7 @@ class PROTOC_EXPORT CodeGeneratorResponse final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
       const std::string& value);
   std::string* _internal_mutable_error();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_error_accessor();
 
   public:
   // optional uint64 supported_features = 2;
@@ -1037,6 +1042,7 @@ class PROTOC_EXPORT CodeGeneratorRequest final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter(
       const std::string& value);
   std::string* _internal_mutable_parameter();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_parameter_accessor();
 
   public:
   // optional .google.protobuf.compiler.Version compiler_version = 3;
@@ -1214,7 +1220,7 @@ inline PROTOBUF_ALWAYS_INLINE void Version::set_suffix(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.Version.suffix)
 }
 inline std::string* Version::mutable_suffix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_suffix();
+  auto _s = _internal_mutable_suffix();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.Version.suffix)
   return _s;
 }
@@ -1232,6 +1238,11 @@ inline std::string* Version::_internal_mutable_suffix() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.suffix_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Version::_internal_mutable_suffix_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.suffix_.MutableAccessor( GetArena());
+}
 inline std::string* Version::release_suffix() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.Version.suffix)
@@ -1279,7 +1290,7 @@ inline void CodeGeneratorRequest::clear_file_to_generate() {
 inline std::string* CodeGeneratorRequest::add_file_to_generate()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  std::string* _s = _internal_mutable_file_to_generate()->Add();
+  auto _s = _internal_mutable_file_to_generate()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
   return _s;
 }
@@ -1291,35 +1302,36 @@ inline const std::string& CodeGeneratorRequest::file_to_generate(int index) cons
 inline std::string* CodeGeneratorRequest::mutable_file_to_generate(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
-  return _internal_mutable_file_to_generate()->Mutable(index);
+  return _internal_mutable_file_to_generate()->MutableString(index);
 }
 inline void CodeGeneratorRequest::set_file_to_generate(int index, const std::string& value) {
-  _internal_mutable_file_to_generate()->Mutable(index)->assign(value);
+  _internal_mutable_file_to_generate()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline void CodeGeneratorRequest::set_file_to_generate(int index, std::string&& value) {
-  _internal_mutable_file_to_generate()->Mutable(index)->assign(std::move(value));
+  _internal_mutable_file_to_generate()->MutableAccessor(index)->assign(
+      std::move(value));
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline void CodeGeneratorRequest::set_file_to_generate(int index, const char* value) {
   ABSL_DCHECK(value != nullptr);
-  _internal_mutable_file_to_generate()->Mutable(index)->assign(value);
+  _internal_mutable_file_to_generate()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set_char:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline void CodeGeneratorRequest::set_file_to_generate(int index, const char* value,
                               std::size_t size) {
-  _internal_mutable_file_to_generate()->Mutable(index)->assign(
+  _internal_mutable_file_to_generate()->MutableAccessor(index)->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_set_pointer:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline void CodeGeneratorRequest::set_file_to_generate(int index, absl::string_view value) {
-  _internal_mutable_file_to_generate()->Mutable(index)->assign(value.data(),
-                                                     value.size());
+  _internal_mutable_file_to_generate()->MutableAccessor(index)->assign(
+      value.data(), value.size());
   // @@protoc_insertion_point(field_set_string_piece:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline void CodeGeneratorRequest::add_file_to_generate(const std::string& value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_file_to_generate()->Add()->assign(value);
+  _internal_mutable_file_to_generate()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline void CodeGeneratorRequest::add_file_to_generate(std::string&& value) {
@@ -1330,18 +1342,18 @@ inline void CodeGeneratorRequest::add_file_to_generate(std::string&& value) {
 inline void CodeGeneratorRequest::add_file_to_generate(const char* value) {
   ABSL_DCHECK(value != nullptr);
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_file_to_generate()->Add()->assign(value);
+  _internal_mutable_file_to_generate()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add_char:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline void CodeGeneratorRequest::add_file_to_generate(const char* value, std::size_t size) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_file_to_generate()->Add()->assign(
+  _internal_mutable_file_to_generate()->AddAccessor()->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_add_pointer:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline void CodeGeneratorRequest::add_file_to_generate(absl::string_view value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_file_to_generate()->Add()->assign(value.data(), value.size());
+  _internal_mutable_file_to_generate()->AddAccessor()->assign(value.data(), value.size());
   // @@protoc_insertion_point(field_add_string_piece:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
 }
 inline const ::google::protobuf::RepeatedPtrField<std::string>&
@@ -1390,7 +1402,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorRequest::set_parameter(Arg_&& ar
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorRequest.parameter)
 }
 inline std::string* CodeGeneratorRequest::mutable_parameter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_parameter();
+  auto _s = _internal_mutable_parameter();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorRequest.parameter)
   return _s;
 }
@@ -1408,6 +1420,11 @@ inline std::string* CodeGeneratorRequest::_internal_mutable_parameter() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.parameter_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorRequest::_internal_mutable_parameter_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.parameter_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorRequest::release_parameter() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorRequest.parameter)
@@ -1651,7 +1668,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorResponse_File::set_name(Arg_&& a
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorResponse.File.name)
 }
 inline std::string* CodeGeneratorResponse_File::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorResponse.File.name)
   return _s;
 }
@@ -1669,6 +1686,11 @@ inline std::string* CodeGeneratorResponse_File::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorResponse_File::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorResponse_File::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.File.name)
@@ -1722,7 +1744,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorResponse_File::set_insertion_poi
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorResponse.File.insertion_point)
 }
 inline std::string* CodeGeneratorResponse_File::mutable_insertion_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_insertion_point();
+  auto _s = _internal_mutable_insertion_point();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorResponse.File.insertion_point)
   return _s;
 }
@@ -1740,6 +1762,11 @@ inline std::string* CodeGeneratorResponse_File::_internal_mutable_insertion_poin
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.insertion_point_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorResponse_File::_internal_mutable_insertion_point_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.insertion_point_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorResponse_File::release_insertion_point() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.File.insertion_point)
@@ -1793,7 +1820,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorResponse_File::set_content(Arg_&
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorResponse.File.content)
 }
 inline std::string* CodeGeneratorResponse_File::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_content();
+  auto _s = _internal_mutable_content();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorResponse.File.content)
   return _s;
 }
@@ -1811,6 +1838,11 @@ inline std::string* CodeGeneratorResponse_File::_internal_mutable_content() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.content_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorResponse_File::_internal_mutable_content_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.content_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorResponse_File::release_content() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.File.content)
@@ -1959,7 +1991,7 @@ inline PROTOBUF_ALWAYS_INLINE void CodeGeneratorResponse::set_error(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.compiler.CodeGeneratorResponse.error)
 }
 inline std::string* CodeGeneratorResponse::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_error();
+  auto _s = _internal_mutable_error();
   // @@protoc_insertion_point(field_mutable:google.protobuf.compiler.CodeGeneratorResponse.error)
   return _s;
 }
@@ -1977,6 +2009,11 @@ inline std::string* CodeGeneratorResponse::_internal_mutable_error() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.error_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor CodeGeneratorResponse::_internal_mutable_error_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.error_.MutableAccessor( GetArena());
+}
 inline std::string* CodeGeneratorResponse::release_error() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.compiler.CodeGeneratorResponse.error)
diff --git a/src/google/protobuf/descriptor.pb.cc b/src/google/protobuf/descriptor.pb.cc
index 8e880a77c..0c05e8f5b 100644
--- a/src/google/protobuf/descriptor.pb.cc
+++ b/src/google/protobuf/descriptor.pb.cc
@@ -513,6 +513,7 @@ inline constexpr FileOptions::Impl_::Impl_(
         py_generic_services_{false},
         php_generic_services_{false},
         deprecated_{false},
+        cc_mutable_donated_string_{false},
         optimize_for_{static_cast< ::google::protobuf::FileOptions_OptimizeMode >(1)},
         cc_enable_arenas_{true} {}
 
@@ -1277,6 +1278,7 @@ const ::uint32_t TableStruct_google_2fprotobuf_2fdescriptor_2eproto::offsets[] P
     PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.php_generic_services_),
     PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.deprecated_),
     PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.cc_enable_arenas_),
+    PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.cc_mutable_donated_string_),
     PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.objc_class_prefix_),
     PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.csharp_namespace_),
     PROTOBUF_FIELD_OFFSET(::google::protobuf::FileOptions, _impl_.swift_prefix_),
@@ -1291,14 +1293,15 @@ const ::uint32_t TableStruct_google_2fprotobuf_2fdescriptor_2eproto::offsets[] P
     11,
     12,
     13,
-    19,
+    20,
     2,
     14,
     15,
     16,
     17,
     18,
-    20,
+    21,
+    19,
     3,
     4,
     5,
@@ -1604,24 +1607,24 @@ static const ::_pbi::MigrationSchema
         {203, 214, -1, sizeof(::google::protobuf::EnumValueDescriptorProto)},
         {217, 228, -1, sizeof(::google::protobuf::ServiceDescriptorProto)},
         {231, 245, -1, sizeof(::google::protobuf::MethodDescriptorProto)},
-        {251, 281, -1, sizeof(::google::protobuf::FileOptions)},
-        {303, 318, -1, sizeof(::google::protobuf::MessageOptions)},
-        {325, 335, -1, sizeof(::google::protobuf::FieldOptions_EditionDefault)},
-        {337, 358, -1, sizeof(::google::protobuf::FieldOptions)},
-        {371, 381, -1, sizeof(::google::protobuf::OneofOptions)},
-        {383, 396, -1, sizeof(::google::protobuf::EnumOptions)},
-        {401, 413, -1, sizeof(::google::protobuf::EnumValueOptions)},
-        {417, 428, -1, sizeof(::google::protobuf::ServiceOptions)},
-        {431, 443, -1, sizeof(::google::protobuf::MethodOptions)},
-        {447, 457, -1, sizeof(::google::protobuf::UninterpretedOption_NamePart)},
-        {459, 474, -1, sizeof(::google::protobuf::UninterpretedOption)},
-        {481, 495, -1, sizeof(::google::protobuf::FeatureSet)},
-        {501, 511, -1, sizeof(::google::protobuf::FeatureSetDefaults_FeatureSetEditionDefault)},
-        {513, 524, -1, sizeof(::google::protobuf::FeatureSetDefaults)},
-        {527, 540, -1, sizeof(::google::protobuf::SourceCodeInfo_Location)},
-        {545, -1, -1, sizeof(::google::protobuf::SourceCodeInfo)},
-        {554, 567, -1, sizeof(::google::protobuf::GeneratedCodeInfo_Annotation)},
-        {572, -1, -1, sizeof(::google::protobuf::GeneratedCodeInfo)},
+        {251, 282, -1, sizeof(::google::protobuf::FileOptions)},
+        {305, 320, -1, sizeof(::google::protobuf::MessageOptions)},
+        {327, 337, -1, sizeof(::google::protobuf::FieldOptions_EditionDefault)},
+        {339, 360, -1, sizeof(::google::protobuf::FieldOptions)},
+        {373, 383, -1, sizeof(::google::protobuf::OneofOptions)},
+        {385, 398, -1, sizeof(::google::protobuf::EnumOptions)},
+        {403, 415, -1, sizeof(::google::protobuf::EnumValueOptions)},
+        {419, 430, -1, sizeof(::google::protobuf::ServiceOptions)},
+        {433, 445, -1, sizeof(::google::protobuf::MethodOptions)},
+        {449, 459, -1, sizeof(::google::protobuf::UninterpretedOption_NamePart)},
+        {461, 476, -1, sizeof(::google::protobuf::UninterpretedOption)},
+        {483, 497, -1, sizeof(::google::protobuf::FeatureSet)},
+        {503, 513, -1, sizeof(::google::protobuf::FeatureSetDefaults_FeatureSetEditionDefault)},
+        {515, 526, -1, sizeof(::google::protobuf::FeatureSetDefaults)},
+        {529, 542, -1, sizeof(::google::protobuf::SourceCodeInfo_Location)},
+        {547, -1, -1, sizeof(::google::protobuf::SourceCodeInfo)},
+        {556, 569, -1, sizeof(::google::protobuf::GeneratedCodeInfo_Annotation)},
+        {574, -1, -1, sizeof(::google::protobuf::GeneratedCodeInfo)},
 };
 
 static const ::_pb::Message* const file_default_instances[] = {
@@ -1743,7 +1746,7 @@ const char descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto[] PR
     "\n\013output_type\030\003 \001(\t\022/\n\007options\030\004 \001(\0132\036.g"
     "oogle.protobuf.MethodOptions\022\037\n\020client_s"
     "treaming\030\005 \001(\010:\005false\022\037\n\020server_streamin"
-    "g\030\006 \001(\010:\005false\"\324\006\n\013FileOptions\022\024\n\014java_p"
+    "g\030\006 \001(\010:\005false\"\376\006\n\013FileOptions\022\024\n\014java_p"
     "ackage\030\001 \001(\t\022\034\n\024java_outer_classname\030\010 \001"
     "(\t\022\"\n\023java_multiple_files\030\n \001(\010:\005false\022)"
     "\n\035java_generate_equals_and_hash\030\024 \001(\010B\002\030"
@@ -1755,155 +1758,156 @@ const char descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto[] PR
     "\005false\022\"\n\023py_generic_services\030\022 \001(\010:\005fal"
     "se\022#\n\024php_generic_services\030* \001(\010:\005false\022"
     "\031\n\ndeprecated\030\027 \001(\010:\005false\022\036\n\020cc_enable_"
-    "arenas\030\037 \001(\010:\004true\022\031\n\021objc_class_prefix\030"
-    "$ \001(\t\022\030\n\020csharp_namespace\030% \001(\t\022\024\n\014swift"
-    "_prefix\030\' \001(\t\022\030\n\020php_class_prefix\030( \001(\t\022"
-    "\025\n\rphp_namespace\030) \001(\t\022\036\n\026php_metadata_n"
-    "amespace\030, \001(\t\022\024\n\014ruby_package\030- \001(\t\022-\n\010"
-    "features\0302 \001(\0132\033.google.protobuf.Feature"
+    "arenas\030\037 \001(\010:\004true\022(\n\031cc_mutable_donated"
+    "_string\030  \001(\010:\005false\022\031\n\021objc_class_prefi"
+    "x\030$ \001(\t\022\030\n\020csharp_namespace\030% \001(\t\022\024\n\014swi"
+    "ft_prefix\030\' \001(\t\022\030\n\020php_class_prefix\030( \001("
+    "\t\022\025\n\rphp_namespace\030) \001(\t\022\036\n\026php_metadata"
+    "_namespace\030, \001(\t\022\024\n\014ruby_package\030- \001(\t\022-"
+    "\n\010features\0302 \001(\0132\033.google.protobuf.Featu"
+    "reSet\022C\n\024uninterpreted_option\030\347\007 \003(\0132$.g"
+    "oogle.protobuf.UninterpretedOption\":\n\014Op"
+    "timizeMode\022\t\n\005SPEED\020\001\022\r\n\tCODE_SIZE\020\002\022\020\n\014"
+    "LITE_RUNTIME\020\003*\t\010\350\007\020\200\200\200\200\002J\004\010&\020\'\"\347\002\n\016Mess"
+    "ageOptions\022&\n\027message_set_wire_format\030\001 "
+    "\001(\010:\005false\022.\n\037no_standard_descriptor_acc"
+    "essor\030\002 \001(\010:\005false\022\031\n\ndeprecated\030\003 \001(\010:\005"
+    "false\022\021\n\tmap_entry\030\007 \001(\010\0222\n&deprecated_l"
+    "egacy_json_field_conflicts\030\013 \001(\010B\002\030\001\022-\n\010"
+    "features\030\014 \001(\0132\033.google.protobuf.Feature"
     "Set\022C\n\024uninterpreted_option\030\347\007 \003(\0132$.goo"
-    "gle.protobuf.UninterpretedOption\":\n\014Opti"
-    "mizeMode\022\t\n\005SPEED\020\001\022\r\n\tCODE_SIZE\020\002\022\020\n\014LI"
-    "TE_RUNTIME\020\003*\t\010\350\007\020\200\200\200\200\002J\004\010&\020\'\"\347\002\n\016Messag"
-    "eOptions\022&\n\027message_set_wire_format\030\001 \001("
-    "\010:\005false\022.\n\037no_standard_descriptor_acces"
-    "sor\030\002 \001(\010:\005false\022\031\n\ndeprecated\030\003 \001(\010:\005fa"
-    "lse\022\021\n\tmap_entry\030\007 \001(\010\0222\n&deprecated_leg"
-    "acy_json_field_conflicts\030\013 \001(\010B\002\030\001\022-\n\010fe"
-    "atures\030\014 \001(\0132\033.google.protobuf.FeatureSe"
-    "t\022C\n\024uninterpreted_option\030\347\007 \003(\0132$.googl"
-    "e.protobuf.UninterpretedOption*\t\010\350\007\020\200\200\200\200"
-    "\002J\004\010\004\020\005J\004\010\005\020\006J\004\010\006\020\007J\004\010\010\020\tJ\004\010\t\020\n\"\215\t\n\014Fiel"
-    "dOptions\022:\n\005ctype\030\001 \001(\0162#.google.protobu"
-    "f.FieldOptions.CType:\006STRING\022\016\n\006packed\030\002"
-    " \001(\010\022\?\n\006jstype\030\006 \001(\0162$.google.protobuf.F"
-    "ieldOptions.JSType:\tJS_NORMAL\022\023\n\004lazy\030\005 "
-    "\001(\010:\005false\022\036\n\017unverified_lazy\030\017 \001(\010:\005fal"
-    "se\022\031\n\ndeprecated\030\003 \001(\010:\005false\022\023\n\004weak\030\n "
-    "\001(\010:\005false\022\033\n\014debug_redact\030\020 \001(\010:\005false\022"
-    "@\n\tretention\030\021 \001(\0162-.google.protobuf.Fie"
-    "ldOptions.OptionRetention\022\?\n\007targets\030\023 \003"
-    "(\0162..google.protobuf.FieldOptions.Option"
-    "TargetType\022F\n\020edition_defaults\030\024 \003(\0132,.g"
-    "oogle.protobuf.FieldOptions.EditionDefau"
-    "lt\022-\n\010features\030\025 \001(\0132\033.google.protobuf.F"
-    "eatureSet\022C\n\024uninterpreted_option\030\347\007 \003(\013"
-    "2$.google.protobuf.UninterpretedOption\032J"
-    "\n\016EditionDefault\022)\n\007edition\030\003 \001(\0162\030.goog"
-    "le.protobuf.Edition\022\r\n\005value\030\002 \001(\t\"/\n\005CT"
-    "ype\022\n\n\006STRING\020\000\022\010\n\004CORD\020\001\022\020\n\014STRING_PIEC"
-    "E\020\002\"5\n\006JSType\022\r\n\tJS_NORMAL\020\000\022\r\n\tJS_STRIN"
-    "G\020\001\022\r\n\tJS_NUMBER\020\002\"U\n\017OptionRetention\022\025\n"
-    "\021RETENTION_UNKNOWN\020\000\022\025\n\021RETENTION_RUNTIM"
-    "E\020\001\022\024\n\020RETENTION_SOURCE\020\002\"\214\002\n\020OptionTarg"
-    "etType\022\027\n\023TARGET_TYPE_UNKNOWN\020\000\022\024\n\020TARGE"
-    "T_TYPE_FILE\020\001\022\037\n\033TARGET_TYPE_EXTENSION_R"
-    "ANGE\020\002\022\027\n\023TARGET_TYPE_MESSAGE\020\003\022\025\n\021TARGE"
-    "T_TYPE_FIELD\020\004\022\025\n\021TARGET_TYPE_ONEOF\020\005\022\024\n"
-    "\020TARGET_TYPE_ENUM\020\006\022\032\n\026TARGET_TYPE_ENUM_"
-    "ENTRY\020\007\022\027\n\023TARGET_TYPE_SERVICE\020\010\022\026\n\022TARG"
-    "ET_TYPE_METHOD\020\t*\t\010\350\007\020\200\200\200\200\002J\004\010\004\020\005J\004\010\022\020\023\""
-    "\215\001\n\014OneofOptions\022-\n\010features\030\001 \001(\0132\033.goo"
-    "gle.protobuf.FeatureSet\022C\n\024uninterpreted"
-    "_option\030\347\007 \003(\0132$.google.protobuf.Uninter"
-    "pretedOption*\t\010\350\007\020\200\200\200\200\002\"\366\001\n\013EnumOptions\022"
-    "\023\n\013allow_alias\030\002 \001(\010\022\031\n\ndeprecated\030\003 \001(\010"
-    ":\005false\0222\n&deprecated_legacy_json_field_"
-    "conflicts\030\006 \001(\010B\002\030\001\022-\n\010features\030\007 \001(\0132\033."
-    "google.protobuf.FeatureSet\022C\n\024uninterpre"
-    "ted_option\030\347\007 \003(\0132$.google.protobuf.Unin"
-    "terpretedOption*\t\010\350\007\020\200\200\200\200\002J\004\010\005\020\006\"\311\001\n\020Enu"
-    "mValueOptions\022\031\n\ndeprecated\030\001 \001(\010:\005false"
-    "\022-\n\010features\030\002 \001(\0132\033.google.protobuf.Fea"
-    "tureSet\022\033\n\014debug_redact\030\003 \001(\010:\005false\022C\n\024"
-    "uninterpreted_option\030\347\007 \003(\0132$.google.pro"
-    "tobuf.UninterpretedOption*\t\010\350\007\020\200\200\200\200\002\"\252\001\n"
-    "\016ServiceOptions\022-\n\010features\030\" \001(\0132\033.goog"
-    "le.protobuf.FeatureSet\022\031\n\ndeprecated\030! \001"
-    "(\010:\005false\022C\n\024uninterpreted_option\030\347\007 \003(\013"
-    "2$.google.protobuf.UninterpretedOption*\t"
-    "\010\350\007\020\200\200\200\200\002\"\334\002\n\rMethodOptions\022\031\n\ndeprecate"
-    "d\030! \001(\010:\005false\022_\n\021idempotency_level\030\" \001("
-    "\0162/.google.protobuf.MethodOptions.Idempo"
-    "tencyLevel:\023IDEMPOTENCY_UNKNOWN\022-\n\010featu"
-    "res\030# \001(\0132\033.google.protobuf.FeatureSet\022C"
+    "gle.protobuf.UninterpretedOption*\t\010\350\007\020\200\200"
+    "\200\200\002J\004\010\004\020\005J\004\010\005\020\006J\004\010\006\020\007J\004\010\010\020\tJ\004\010\t\020\n\"\215\t\n\014Fi"
+    "eldOptions\022:\n\005ctype\030\001 \001(\0162#.google.proto"
+    "buf.FieldOptions.CType:\006STRING\022\016\n\006packed"
+    "\030\002 \001(\010\022\?\n\006jstype\030\006 \001(\0162$.google.protobuf"
+    ".FieldOptions.JSType:\tJS_NORMAL\022\023\n\004lazy\030"
+    "\005 \001(\010:\005false\022\036\n\017unverified_lazy\030\017 \001(\010:\005f"
+    "alse\022\031\n\ndeprecated\030\003 \001(\010:\005false\022\023\n\004weak\030"
+    "\n \001(\010:\005false\022\033\n\014debug_redact\030\020 \001(\010:\005fals"
+    "e\022@\n\tretention\030\021 \001(\0162-.google.protobuf.F"
+    "ieldOptions.OptionRetention\022\?\n\007targets\030\023"
+    " \003(\0162..google.protobuf.FieldOptions.Opti"
+    "onTargetType\022F\n\020edition_defaults\030\024 \003(\0132,"
+    ".google.protobuf.FieldOptions.EditionDef"
+    "ault\022-\n\010features\030\025 \001(\0132\033.google.protobuf"
+    ".FeatureSet\022C\n\024uninterpreted_option\030\347\007 \003"
+    "(\0132$.google.protobuf.UninterpretedOption"
+    "\032J\n\016EditionDefault\022)\n\007edition\030\003 \001(\0162\030.go"
+    "ogle.protobuf.Edition\022\r\n\005value\030\002 \001(\t\"/\n\005"
+    "CType\022\n\n\006STRING\020\000\022\010\n\004CORD\020\001\022\020\n\014STRING_PI"
+    "ECE\020\002\"5\n\006JSType\022\r\n\tJS_NORMAL\020\000\022\r\n\tJS_STR"
+    "ING\020\001\022\r\n\tJS_NUMBER\020\002\"U\n\017OptionRetention\022"
+    "\025\n\021RETENTION_UNKNOWN\020\000\022\025\n\021RETENTION_RUNT"
+    "IME\020\001\022\024\n\020RETENTION_SOURCE\020\002\"\214\002\n\020OptionTa"
+    "rgetType\022\027\n\023TARGET_TYPE_UNKNOWN\020\000\022\024\n\020TAR"
+    "GET_TYPE_FILE\020\001\022\037\n\033TARGET_TYPE_EXTENSION"
+    "_RANGE\020\002\022\027\n\023TARGET_TYPE_MESSAGE\020\003\022\025\n\021TAR"
+    "GET_TYPE_FIELD\020\004\022\025\n\021TARGET_TYPE_ONEOF\020\005\022"
+    "\024\n\020TARGET_TYPE_ENUM\020\006\022\032\n\026TARGET_TYPE_ENU"
+    "M_ENTRY\020\007\022\027\n\023TARGET_TYPE_SERVICE\020\010\022\026\n\022TA"
+    "RGET_TYPE_METHOD\020\t*\t\010\350\007\020\200\200\200\200\002J\004\010\004\020\005J\004\010\022\020"
+    "\023\"\215\001\n\014OneofOptions\022-\n\010features\030\001 \001(\0132\033.g"
+    "oogle.protobuf.FeatureSet\022C\n\024uninterpret"
+    "ed_option\030\347\007 \003(\0132$.google.protobuf.Unint"
+    "erpretedOption*\t\010\350\007\020\200\200\200\200\002\"\366\001\n\013EnumOption"
+    "s\022\023\n\013allow_alias\030\002 \001(\010\022\031\n\ndeprecated\030\003 \001"
+    "(\010:\005false\0222\n&deprecated_legacy_json_fiel"
+    "d_conflicts\030\006 \001(\010B\002\030\001\022-\n\010features\030\007 \001(\0132"
+    "\033.google.protobuf.FeatureSet\022C\n\024uninterp"
+    "reted_option\030\347\007 \003(\0132$.google.protobuf.Un"
+    "interpretedOption*\t\010\350\007\020\200\200\200\200\002J\004\010\005\020\006\"\311\001\n\020E"
+    "numValueOptions\022\031\n\ndeprecated\030\001 \001(\010:\005fal"
+    "se\022-\n\010features\030\002 \001(\0132\033.google.protobuf.F"
+    "eatureSet\022\033\n\014debug_redact\030\003 \001(\010:\005false\022C"
     "\n\024uninterpreted_option\030\347\007 \003(\0132$.google.p"
-    "rotobuf.UninterpretedOption\"P\n\020Idempoten"
-    "cyLevel\022\027\n\023IDEMPOTENCY_UNKNOWN\020\000\022\023\n\017NO_S"
-    "IDE_EFFECTS\020\001\022\016\n\nIDEMPOTENT\020\002*\t\010\350\007\020\200\200\200\200\002"
-    "\"\236\002\n\023UninterpretedOption\022;\n\004name\030\002 \003(\0132-"
-    ".google.protobuf.UninterpretedOption.Nam"
-    "ePart\022\030\n\020identifier_value\030\003 \001(\t\022\032\n\022posit"
-    "ive_int_value\030\004 \001(\004\022\032\n\022negative_int_valu"
-    "e\030\005 \001(\003\022\024\n\014double_value\030\006 \001(\001\022\024\n\014string_"
-    "value\030\007 \001(\014\022\027\n\017aggregate_value\030\010 \001(\t\0323\n\010"
-    "NamePart\022\021\n\tname_part\030\001 \002(\t\022\024\n\014is_extens"
-    "ion\030\002 \002(\010\"\235\t\n\nFeatureSet\022|\n\016field_presen"
-    "ce\030\001 \001(\0162).google.protobuf.FeatureSet.Fi"
-    "eldPresenceB9\210\001\001\230\001\004\230\001\001\242\001\r\022\010EXPLICIT\030\346\007\242\001"
-    "\r\022\010IMPLICIT\030\347\007\242\001\r\022\010EXPLICIT\030\350\007\022\\\n\tenum_t"
-    "ype\030\002 \001(\0162$.google.protobuf.FeatureSet.E"
-    "numTypeB#\210\001\001\230\001\006\230\001\001\242\001\013\022\006CLOSED\030\346\007\242\001\t\022\004OPE"
-    "N\030\347\007\022{\n\027repeated_field_encoding\030\003 \001(\01621."
-    "google.protobuf.FeatureSet.RepeatedField"
-    "EncodingB\'\210\001\001\230\001\004\230\001\001\242\001\r\022\010EXPANDED\030\346\007\242\001\013\022\006"
-    "PACKED\030\347\007\022h\n\017utf8_validation\030\004 \001(\0162*.goo"
-    "gle.protobuf.FeatureSet.Utf8ValidationB#"
-    "\210\001\001\230\001\004\230\001\001\242\001\t\022\004NONE\030\346\007\242\001\013\022\006VERIFY\030\347\007\022g\n\020m"
-    "essage_encoding\030\005 \001(\0162+.google.protobuf."
-    "FeatureSet.MessageEncodingB \210\001\001\230\001\004\230\001\001\242\001\024"
-    "\022\017LENGTH_PREFIXED\030\346\007\022p\n\013json_format\030\006 \001("
-    "\0162&.google.protobuf.FeatureSet.JsonForma"
-    "tB3\210\001\001\230\001\003\230\001\006\230\001\001\242\001\027\022\022LEGACY_BEST_EFFORT\030\346"
-    "\007\242\001\n\022\005ALLOW\030\347\007\"\\\n\rFieldPresence\022\032\n\026FIELD"
-    "_PRESENCE_UNKNOWN\020\000\022\014\n\010EXPLICIT\020\001\022\014\n\010IMP"
-    "LICIT\020\002\022\023\n\017LEGACY_REQUIRED\020\003\"7\n\010EnumType"
-    "\022\025\n\021ENUM_TYPE_UNKNOWN\020\000\022\010\n\004OPEN\020\001\022\n\n\006CLO"
-    "SED\020\002\"V\n\025RepeatedFieldEncoding\022#\n\037REPEAT"
-    "ED_FIELD_ENCODING_UNKNOWN\020\000\022\n\n\006PACKED\020\001\022"
-    "\014\n\010EXPANDED\020\002\"C\n\016Utf8Validation\022\033\n\027UTF8_"
-    "VALIDATION_UNKNOWN\020\000\022\010\n\004NONE\020\001\022\n\n\006VERIFY"
-    "\020\002\"S\n\017MessageEncoding\022\034\n\030MESSAGE_ENCODIN"
-    "G_UNKNOWN\020\000\022\023\n\017LENGTH_PREFIXED\020\001\022\r\n\tDELI"
-    "MITED\020\002\"H\n\nJsonFormat\022\027\n\023JSON_FORMAT_UNK"
-    "NOWN\020\000\022\t\n\005ALLOW\020\001\022\026\n\022LEGACY_BEST_EFFORT\020"
-    "\002*\006\010\350\007\020\351\007*\006\010\351\007\020\352\007*\006\010\213N\020\220NJ\006\010\347\007\020\350\007\"\300\002\n\022Fe"
-    "atureSetDefaults\022N\n\010defaults\030\001 \003(\0132<.goo"
-    "gle.protobuf.FeatureSetDefaults.FeatureS"
-    "etEditionDefault\0221\n\017minimum_edition\030\004 \001("
-    "\0162\030.google.protobuf.Edition\0221\n\017maximum_e"
-    "dition\030\005 \001(\0162\030.google.protobuf.Edition\032t"
-    "\n\030FeatureSetEditionDefault\022)\n\007edition\030\003 "
-    "\001(\0162\030.google.protobuf.Edition\022-\n\010feature"
-    "s\030\002 \001(\0132\033.google.protobuf.FeatureSet\"\325\001\n"
-    "\016SourceCodeInfo\022:\n\010location\030\001 \003(\0132(.goog"
-    "le.protobuf.SourceCodeInfo.Location\032\206\001\n\010"
-    "Location\022\020\n\004path\030\001 \003(\005B\002\020\001\022\020\n\004span\030\002 \003(\005"
-    "B\002\020\001\022\030\n\020leading_comments\030\003 \001(\t\022\031\n\021traili"
-    "ng_comments\030\004 \001(\t\022!\n\031leading_detached_co"
-    "mments\030\006 \003(\t\"\234\002\n\021GeneratedCodeInfo\022A\n\nan"
-    "notation\030\001 \003(\0132-.google.protobuf.Generat"
-    "edCodeInfo.Annotation\032\303\001\n\nAnnotation\022\020\n\004"
-    "path\030\001 \003(\005B\002\020\001\022\023\n\013source_file\030\002 \001(\t\022\r\n\005b"
-    "egin\030\003 \001(\005\022\013\n\003end\030\004 \001(\005\022H\n\010semantic\030\005 \001("
-    "\01626.google.protobuf.GeneratedCodeInfo.An"
-    "notation.Semantic\"(\n\010Semantic\022\010\n\004NONE\020\000\022"
-    "\007\n\003SET\020\001\022\t\n\005ALIAS\020\002*\352\001\n\007Edition\022\023\n\017EDITI"
-    "ON_UNKNOWN\020\000\022\023\n\016EDITION_PROTO2\020\346\007\022\023\n\016EDI"
-    "TION_PROTO3\020\347\007\022\021\n\014EDITION_2023\020\350\007\022\027\n\023EDI"
-    "TION_1_TEST_ONLY\020\001\022\027\n\023EDITION_2_TEST_ONL"
-    "Y\020\002\022\035\n\027EDITION_99997_TEST_ONLY\020\235\215\006\022\035\n\027ED"
-    "ITION_99998_TEST_ONLY\020\236\215\006\022\035\n\027EDITION_999"
-    "99_TEST_ONLY\020\237\215\006B~\n\023com.google.protobufB"
-    "\020DescriptorProtosH\001Z-google.golang.org/p"
-    "rotobuf/types/descriptorpb\370\001\001\242\002\003GPB\252\002\032Go"
-    "ogle.Protobuf.Reflection"
+    "rotobuf.UninterpretedOption*\t\010\350\007\020\200\200\200\200\002\"\252"
+    "\001\n\016ServiceOptions\022-\n\010features\030\" \001(\0132\033.go"
+    "ogle.protobuf.FeatureSet\022\031\n\ndeprecated\030!"
+    " \001(\010:\005false\022C\n\024uninterpreted_option\030\347\007 \003"
+    "(\0132$.google.protobuf.UninterpretedOption"
+    "*\t\010\350\007\020\200\200\200\200\002\"\334\002\n\rMethodOptions\022\031\n\ndepreca"
+    "ted\030! \001(\010:\005false\022_\n\021idempotency_level\030\" "
+    "\001(\0162/.google.protobuf.MethodOptions.Idem"
+    "potencyLevel:\023IDEMPOTENCY_UNKNOWN\022-\n\010fea"
+    "tures\030# \001(\0132\033.google.protobuf.FeatureSet"
+    "\022C\n\024uninterpreted_option\030\347\007 \003(\0132$.google"
+    ".protobuf.UninterpretedOption\"P\n\020Idempot"
+    "encyLevel\022\027\n\023IDEMPOTENCY_UNKNOWN\020\000\022\023\n\017NO"
+    "_SIDE_EFFECTS\020\001\022\016\n\nIDEMPOTENT\020\002*\t\010\350\007\020\200\200\200"
+    "\200\002\"\236\002\n\023UninterpretedOption\022;\n\004name\030\002 \003(\013"
+    "2-.google.protobuf.UninterpretedOption.N"
+    "amePart\022\030\n\020identifier_value\030\003 \001(\t\022\032\n\022pos"
+    "itive_int_value\030\004 \001(\004\022\032\n\022negative_int_va"
+    "lue\030\005 \001(\003\022\024\n\014double_value\030\006 \001(\001\022\024\n\014strin"
+    "g_value\030\007 \001(\014\022\027\n\017aggregate_value\030\010 \001(\t\0323"
+    "\n\010NamePart\022\021\n\tname_part\030\001 \002(\t\022\024\n\014is_exte"
+    "nsion\030\002 \002(\010\"\235\t\n\nFeatureSet\022|\n\016field_pres"
+    "ence\030\001 \001(\0162).google.protobuf.FeatureSet."
+    "FieldPresenceB9\210\001\001\230\001\004\230\001\001\242\001\r\022\010EXPLICIT\030\346\007"
+    "\242\001\r\022\010IMPLICIT\030\347\007\242\001\r\022\010EXPLICIT\030\350\007\022\\\n\tenum"
+    "_type\030\002 \001(\0162$.google.protobuf.FeatureSet"
+    ".EnumTypeB#\210\001\001\230\001\006\230\001\001\242\001\013\022\006CLOSED\030\346\007\242\001\t\022\004O"
+    "PEN\030\347\007\022{\n\027repeated_field_encoding\030\003 \001(\0162"
+    "1.google.protobuf.FeatureSet.RepeatedFie"
+    "ldEncodingB\'\210\001\001\230\001\004\230\001\001\242\001\r\022\010EXPANDED\030\346\007\242\001\013"
+    "\022\006PACKED\030\347\007\022h\n\017utf8_validation\030\004 \001(\0162*.g"
+    "oogle.protobuf.FeatureSet.Utf8Validation"
+    "B#\210\001\001\230\001\004\230\001\001\242\001\t\022\004NONE\030\346\007\242\001\013\022\006VERIFY\030\347\007\022g\n"
+    "\020message_encoding\030\005 \001(\0162+.google.protobu"
+    "f.FeatureSet.MessageEncodingB \210\001\001\230\001\004\230\001\001\242"
+    "\001\024\022\017LENGTH_PREFIXED\030\346\007\022p\n\013json_format\030\006 "
+    "\001(\0162&.google.protobuf.FeatureSet.JsonFor"
+    "matB3\210\001\001\230\001\003\230\001\006\230\001\001\242\001\027\022\022LEGACY_BEST_EFFORT"
+    "\030\346\007\242\001\n\022\005ALLOW\030\347\007\"\\\n\rFieldPresence\022\032\n\026FIE"
+    "LD_PRESENCE_UNKNOWN\020\000\022\014\n\010EXPLICIT\020\001\022\014\n\010I"
+    "MPLICIT\020\002\022\023\n\017LEGACY_REQUIRED\020\003\"7\n\010EnumTy"
+    "pe\022\025\n\021ENUM_TYPE_UNKNOWN\020\000\022\010\n\004OPEN\020\001\022\n\n\006C"
+    "LOSED\020\002\"V\n\025RepeatedFieldEncoding\022#\n\037REPE"
+    "ATED_FIELD_ENCODING_UNKNOWN\020\000\022\n\n\006PACKED\020"
+    "\001\022\014\n\010EXPANDED\020\002\"C\n\016Utf8Validation\022\033\n\027UTF"
+    "8_VALIDATION_UNKNOWN\020\000\022\010\n\004NONE\020\001\022\n\n\006VERI"
+    "FY\020\002\"S\n\017MessageEncoding\022\034\n\030MESSAGE_ENCOD"
+    "ING_UNKNOWN\020\000\022\023\n\017LENGTH_PREFIXED\020\001\022\r\n\tDE"
+    "LIMITED\020\002\"H\n\nJsonFormat\022\027\n\023JSON_FORMAT_U"
+    "NKNOWN\020\000\022\t\n\005ALLOW\020\001\022\026\n\022LEGACY_BEST_EFFOR"
+    "T\020\002*\006\010\350\007\020\351\007*\006\010\351\007\020\352\007*\006\010\213N\020\220NJ\006\010\347\007\020\350\007\"\300\002\n\022"
+    "FeatureSetDefaults\022N\n\010defaults\030\001 \003(\0132<.g"
+    "oogle.protobuf.FeatureSetDefaults.Featur"
+    "eSetEditionDefault\0221\n\017minimum_edition\030\004 "
+    "\001(\0162\030.google.protobuf.Edition\0221\n\017maximum"
+    "_edition\030\005 \001(\0162\030.google.protobuf.Edition"
+    "\032t\n\030FeatureSetEditionDefault\022)\n\007edition\030"
+    "\003 \001(\0162\030.google.protobuf.Edition\022-\n\010featu"
+    "res\030\002 \001(\0132\033.google.protobuf.FeatureSet\"\325"
+    "\001\n\016SourceCodeInfo\022:\n\010location\030\001 \003(\0132(.go"
+    "ogle.protobuf.SourceCodeInfo.Location\032\206\001"
+    "\n\010Location\022\020\n\004path\030\001 \003(\005B\002\020\001\022\020\n\004span\030\002 \003"
+    "(\005B\002\020\001\022\030\n\020leading_comments\030\003 \001(\t\022\031\n\021trai"
+    "ling_comments\030\004 \001(\t\022!\n\031leading_detached_"
+    "comments\030\006 \003(\t\"\234\002\n\021GeneratedCodeInfo\022A\n\n"
+    "annotation\030\001 \003(\0132-.google.protobuf.Gener"
+    "atedCodeInfo.Annotation\032\303\001\n\nAnnotation\022\020"
+    "\n\004path\030\001 \003(\005B\002\020\001\022\023\n\013source_file\030\002 \001(\t\022\r\n"
+    "\005begin\030\003 \001(\005\022\013\n\003end\030\004 \001(\005\022H\n\010semantic\030\005 "
+    "\001(\01626.google.protobuf.GeneratedCodeInfo."
+    "Annotation.Semantic\"(\n\010Semantic\022\010\n\004NONE\020"
+    "\000\022\007\n\003SET\020\001\022\t\n\005ALIAS\020\002*\352\001\n\007Edition\022\023\n\017EDI"
+    "TION_UNKNOWN\020\000\022\023\n\016EDITION_PROTO2\020\346\007\022\023\n\016E"
+    "DITION_PROTO3\020\347\007\022\021\n\014EDITION_2023\020\350\007\022\027\n\023E"
+    "DITION_1_TEST_ONLY\020\001\022\027\n\023EDITION_2_TEST_O"
+    "NLY\020\002\022\035\n\027EDITION_99997_TEST_ONLY\020\235\215\006\022\035\n\027"
+    "EDITION_99998_TEST_ONLY\020\236\215\006\022\035\n\027EDITION_9"
+    "9999_TEST_ONLY\020\237\215\006B~\n\023com.google.protobu"
+    "fB\020DescriptorProtosH\001Z-google.golang.org"
+    "/protobuf/types/descriptorpb\370\001\001\242\002\003GPB\252\002\032"
+    "Google.Protobuf.Reflection"
 };
 static ::absl::once_flag descriptor_table_google_2fprotobuf_2fdescriptor_2eproto_once;
 const ::_pbi::DescriptorTable descriptor_table_google_2fprotobuf_2fdescriptor_2eproto = {
     false,
     false,
-    9544,
+    9586,
     descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto,
     "google/protobuf/descriptor.proto",
     &descriptor_table_google_2fprotobuf_2fdescriptor_2eproto_once,
@@ -7167,7 +7171,7 @@ class FileOptions::_Internal {
     (*has_bits)[0] |= 8192u;
   }
   static void set_has_optimize_for(HasBits* has_bits) {
-    (*has_bits)[0] |= 524288u;
+    (*has_bits)[0] |= 1048576u;
   }
   static void set_has_go_package(HasBits* has_bits) {
     (*has_bits)[0] |= 4u;
@@ -7188,7 +7192,10 @@ class FileOptions::_Internal {
     (*has_bits)[0] |= 262144u;
   }
   static void set_has_cc_enable_arenas(HasBits* has_bits) {
-    (*has_bits)[0] |= 1048576u;
+    (*has_bits)[0] |= 2097152u;
+  }
+  static void set_has_cc_mutable_donated_string(HasBits* has_bits) {
+    (*has_bits)[0] |= 524288u;
   }
   static void set_has_objc_class_prefix(HasBits* has_bits) {
     (*has_bits)[0] |= 8u;
@@ -7291,9 +7298,9 @@ inline void FileOptions::SharedCtor(::_pb::Arena* arena) {
   ::memset(reinterpret_cast<char *>(&_impl_) +
                offsetof(Impl_, features_),
            0,
-           offsetof(Impl_, deprecated_) -
+           offsetof(Impl_, cc_mutable_donated_string_) -
                offsetof(Impl_, features_) +
-               sizeof(Impl_::deprecated_));
+               sizeof(Impl_::cc_mutable_donated_string_));
 }
 FileOptions::~FileOptions() {
   // @@protoc_insertion_point(destructor:google.protobuf.FileOptions)
@@ -7369,10 +7376,10 @@ PROTOBUF_NOINLINE void FileOptions::Clear() {
         reinterpret_cast<char*>(&_impl_.java_generic_services_) -
         reinterpret_cast<char*>(&_impl_.java_multiple_files_)) + sizeof(_impl_.java_generic_services_));
   }
-  if (cached_has_bits & 0x001f0000u) {
+  if (cached_has_bits & 0x003f0000u) {
     ::memset(&_impl_.py_generic_services_, 0, static_cast<::size_t>(
-        reinterpret_cast<char*>(&_impl_.deprecated_) -
-        reinterpret_cast<char*>(&_impl_.py_generic_services_)) + sizeof(_impl_.deprecated_));
+        reinterpret_cast<char*>(&_impl_.cc_mutable_donated_string_) -
+        reinterpret_cast<char*>(&_impl_.py_generic_services_)) + sizeof(_impl_.cc_mutable_donated_string_));
     _impl_.optimize_for_ = 1;
     _impl_.cc_enable_arenas_ = true;
   }
@@ -7387,15 +7394,15 @@ const char* FileOptions::_InternalParse(
 }
 
 
-constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
+constexpr ::_pbi::TcParseTable<5, 23, 3, 202, 12> FileOptions::_table_ = {
   {
     PROTOBUF_FIELD_OFFSET(FileOptions, _impl_._has_bits_),
     PROTOBUF_FIELD_OFFSET(FileOptions, _impl_._extensions_),
     999, 248,  // max_field_number, fast_idx_mask
     offsetof(decltype(_table_), field_lookup_table),
-    3149166718,  // skipmap
+    1001683070,  // skipmap
     offsetof(decltype(_table_), field_entries),
-    22,  // num_field_entries
+    23,  // num_field_entries
     3,  // num_aux_entries
     offsetof(decltype(_table_), aux_entries),
     &_FileOptions_default_instance_._instance,
@@ -7416,7 +7423,7 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
      {66, 1, 0, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_outer_classname_)}},
     // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
     {::_pbi::TcParser::FastEr1S1,
-     {72, 19, 3, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.optimize_for_)}},
+     {72, 20, 3, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.optimize_for_)}},
     // optional bool java_multiple_files = 10 [default = false];
     {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(FileOptions, _impl_.java_multiple_files_), 11>(),
      {80, 11, 0, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_multiple_files_)}},
@@ -7468,11 +7475,11 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
     {::_pbi::TcParser::MiniParse, {}},
     // optional bool cc_enable_arenas = 31 [default = true];
     {::_pbi::TcParser::FastV8S2,
-     {504, 20, 0, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_enable_arenas_)}},
+     {504, 21, 0, PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_enable_arenas_)}},
   }}, {{
     36, 0, 1,
-    48260, 12,999, 0, 1,
-     65534, 21,
+    48260, 13,999, 0, 1,
+     65534, 22,
     65535, 65535
   }}, {{
     // optional string java_package = 1;
@@ -7482,7 +7489,7 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
     {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_outer_classname_), _Internal::kHasBitsOffset + 1, 0,
     (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
     // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
-    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.optimize_for_), _Internal::kHasBitsOffset + 19, 0,
+    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.optimize_for_), _Internal::kHasBitsOffset + 20, 0,
     (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
     // optional bool java_multiple_files = 10 [default = false];
     {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_multiple_files_), _Internal::kHasBitsOffset + 11, 0,
@@ -7509,7 +7516,10 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
     {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.java_string_check_utf8_), _Internal::kHasBitsOffset + 13, 0,
     (0 | ::_fl::kFcOptional | ::_fl::kBool)},
     // optional bool cc_enable_arenas = 31 [default = true];
-    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_enable_arenas_), _Internal::kHasBitsOffset + 20, 0,
+    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_enable_arenas_), _Internal::kHasBitsOffset + 21, 0,
+    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
+    // optional bool cc_mutable_donated_string = 32 [default = false];
+    {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.cc_mutable_donated_string_), _Internal::kHasBitsOffset + 19, 0,
     (0 | ::_fl::kFcOptional | ::_fl::kBool)},
     // optional string objc_class_prefix = 36;
     {PROTOBUF_FIELD_OFFSET(FileOptions, _impl_.objc_class_prefix_), _Internal::kHasBitsOffset + 3, 0,
@@ -7546,7 +7556,7 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
     {::_pbi::TcParser::GetTable<::google::protobuf::FeatureSet>()},
     {::_pbi::TcParser::GetTable<::google::protobuf::UninterpretedOption>()},
   }}, {{
-    "\33\14\24\0\0\12\0\0\0\0\0\0\0\21\20\14\20\15\0\26\14\0\0\0"
+    "\33\14\24\0\0\12\0\0\0\0\0\0\0\0\21\20\14\20\15\0\26\14\0\0"
     "google.protobuf.FileOptions"
     "java_package"
     "java_outer_classname"
@@ -7586,7 +7596,7 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
   }
 
   // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
-  if (cached_has_bits & 0x00080000u) {
+  if (cached_has_bits & 0x00100000u) {
     target = stream->EnsureSpace(target);
     target = ::_pbi::WireFormatLite::WriteEnumToArray(
         9, this->_internal_optimize_for(), target);
@@ -7650,12 +7660,19 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
   }
 
   // optional bool cc_enable_arenas = 31 [default = true];
-  if (cached_has_bits & 0x00100000u) {
+  if (cached_has_bits & 0x00200000u) {
     target = stream->EnsureSpace(target);
     target = ::_pbi::WireFormatLite::WriteBoolToArray(
         31, this->_internal_cc_enable_arenas(), target);
   }
 
+  // optional bool cc_mutable_donated_string = 32 [default = false];
+  if (cached_has_bits & 0x00080000u) {
+    target = stream->EnsureSpace(target);
+    target = ::_pbi::WireFormatLite::WriteBoolToArray(
+        32, this->_internal_cc_mutable_donated_string(), target);
+  }
+
   // optional string objc_class_prefix = 36;
   if (cached_has_bits & 0x00000008u) {
     const std::string& _s = this->_internal_objc_class_prefix();
@@ -7858,7 +7875,7 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
     }
 
   }
-  if (cached_has_bits & 0x001f0000u) {
+  if (cached_has_bits & 0x003f0000u) {
     // optional bool py_generic_services = 18 [default = false];
     if (cached_has_bits & 0x00010000u) {
       total_size += 3;
@@ -7874,14 +7891,19 @@ constexpr ::_pbi::TcParseTable<5, 22, 3, 202, 12> FileOptions::_table_ = {
       total_size += 3;
     }
 
-    // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
+    // optional bool cc_mutable_donated_string = 32 [default = false];
     if (cached_has_bits & 0x00080000u) {
+      total_size += 3;
+    }
+
+    // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
+    if (cached_has_bits & 0x00100000u) {
       total_size += 1 +
                     ::_pbi::WireFormatLite::EnumSize(this->_internal_optimize_for());
     }
 
     // optional bool cc_enable_arenas = 31 [default = true];
-    if (cached_has_bits & 0x00100000u) {
+    if (cached_has_bits & 0x00200000u) {
       total_size += 3;
     }
 
@@ -7962,7 +7984,7 @@ void FileOptions::MergeImpl(::google::protobuf::Message& to_msg, const ::google:
     }
     _this->_impl_._has_bits_[0] |= cached_has_bits;
   }
-  if (cached_has_bits & 0x001f0000u) {
+  if (cached_has_bits & 0x003f0000u) {
     if (cached_has_bits & 0x00010000u) {
       _this->_impl_.py_generic_services_ = from._impl_.py_generic_services_;
     }
@@ -7973,9 +7995,12 @@ void FileOptions::MergeImpl(::google::protobuf::Message& to_msg, const ::google:
       _this->_impl_.deprecated_ = from._impl_.deprecated_;
     }
     if (cached_has_bits & 0x00080000u) {
-      _this->_impl_.optimize_for_ = from._impl_.optimize_for_;
+      _this->_impl_.cc_mutable_donated_string_ = from._impl_.cc_mutable_donated_string_;
     }
     if (cached_has_bits & 0x00100000u) {
+      _this->_impl_.optimize_for_ = from._impl_.optimize_for_;
+    }
+    if (cached_has_bits & 0x00200000u) {
       _this->_impl_.cc_enable_arenas_ = from._impl_.cc_enable_arenas_;
     }
     _this->_impl_._has_bits_[0] |= cached_has_bits;
diff --git a/src/google/protobuf/descriptor.pb.h b/src/google/protobuf/descriptor.pb.h
index db3a1e070..3ec48200e 100644
--- a/src/google/protobuf/descriptor.pb.h
+++ b/src/google/protobuf/descriptor.pb.h
@@ -852,6 +852,7 @@ class PROTOBUF_EXPORT UninterpretedOption_NamePart final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_part(
       const std::string& value);
   std::string* _internal_mutable_name_part();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_part_accessor();
 
   public:
   // required bool is_extension = 2;
@@ -1115,6 +1116,7 @@ class PROTOBUF_EXPORT SourceCodeInfo_Location final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_leading_comments(
       const std::string& value);
   std::string* _internal_mutable_leading_comments();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_leading_comments_accessor();
 
   public:
   // optional string trailing_comments = 4;
@@ -1132,6 +1134,7 @@ class PROTOBUF_EXPORT SourceCodeInfo_Location final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_trailing_comments(
       const std::string& value);
   std::string* _internal_mutable_trailing_comments();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_trailing_comments_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.SourceCodeInfo.Location)
@@ -1364,6 +1367,7 @@ class PROTOBUF_EXPORT GeneratedCodeInfo_Annotation final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_file(
       const std::string& value);
   std::string* _internal_mutable_source_file();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_source_file_accessor();
 
   public:
   // optional int32 begin = 3;
@@ -1586,6 +1590,7 @@ class PROTOBUF_EXPORT FieldOptions_EditionDefault final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
       const std::string& value);
   std::string* _internal_mutable_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_value_accessor();
 
   public:
   // optional .google.protobuf.Edition edition = 3;
@@ -2333,6 +2338,7 @@ class PROTOBUF_EXPORT ExtensionRangeOptions_Declaration final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_name(
       const std::string& value);
   std::string* _internal_mutable_full_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_full_name_accessor();
 
   public:
   // optional string type = 3;
@@ -2350,6 +2356,7 @@ class PROTOBUF_EXPORT ExtensionRangeOptions_Declaration final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
       const std::string& value);
   std::string* _internal_mutable_type();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_type_accessor();
 
   public:
   // optional int32 number = 1;
@@ -2976,6 +2983,7 @@ class PROTOBUF_EXPORT UninterpretedOption final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier_value(
       const std::string& value);
   std::string* _internal_mutable_identifier_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_identifier_value_accessor();
 
   public:
   // optional bytes string_value = 7;
@@ -2993,6 +3001,7 @@ class PROTOBUF_EXPORT UninterpretedOption final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
       const std::string& value);
   std::string* _internal_mutable_string_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_string_value_accessor();
 
   public:
   // optional string aggregate_value = 8;
@@ -3010,6 +3019,7 @@ class PROTOBUF_EXPORT UninterpretedOption final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregate_value(
       const std::string& value);
   std::string* _internal_mutable_aggregate_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_aggregate_value_accessor();
 
   public:
   // optional uint64 positive_int_value = 4;
@@ -5465,6 +5475,7 @@ class PROTOBUF_EXPORT FileOptions final :
     kPyGenericServicesFieldNumber = 18,
     kPhpGenericServicesFieldNumber = 42,
     kDeprecatedFieldNumber = 23,
+    kCcMutableDonatedStringFieldNumber = 32,
     kOptimizeForFieldNumber = 9,
     kCcEnableArenasFieldNumber = 31,
   };
@@ -5501,6 +5512,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_java_package(
       const std::string& value);
   std::string* _internal_mutable_java_package();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_java_package_accessor();
 
   public:
   // optional string java_outer_classname = 8;
@@ -5518,6 +5530,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_java_outer_classname(
       const std::string& value);
   std::string* _internal_mutable_java_outer_classname();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_java_outer_classname_accessor();
 
   public:
   // optional string go_package = 11;
@@ -5535,6 +5548,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_go_package(
       const std::string& value);
   std::string* _internal_mutable_go_package();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_go_package_accessor();
 
   public:
   // optional string objc_class_prefix = 36;
@@ -5552,6 +5566,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_objc_class_prefix(
       const std::string& value);
   std::string* _internal_mutable_objc_class_prefix();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_objc_class_prefix_accessor();
 
   public:
   // optional string csharp_namespace = 37;
@@ -5569,6 +5584,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_csharp_namespace(
       const std::string& value);
   std::string* _internal_mutable_csharp_namespace();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_csharp_namespace_accessor();
 
   public:
   // optional string swift_prefix = 39;
@@ -5586,6 +5602,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_swift_prefix(
       const std::string& value);
   std::string* _internal_mutable_swift_prefix();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_swift_prefix_accessor();
 
   public:
   // optional string php_class_prefix = 40;
@@ -5603,6 +5620,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_php_class_prefix(
       const std::string& value);
   std::string* _internal_mutable_php_class_prefix();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_php_class_prefix_accessor();
 
   public:
   // optional string php_namespace = 41;
@@ -5620,6 +5638,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_php_namespace(
       const std::string& value);
   std::string* _internal_mutable_php_namespace();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_php_namespace_accessor();
 
   public:
   // optional string php_metadata_namespace = 44;
@@ -5637,6 +5656,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_php_metadata_namespace(
       const std::string& value);
   std::string* _internal_mutable_php_metadata_namespace();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_php_metadata_namespace_accessor();
 
   public:
   // optional string ruby_package = 45;
@@ -5654,6 +5674,7 @@ class PROTOBUF_EXPORT FileOptions final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_ruby_package(
       const std::string& value);
   std::string* _internal_mutable_ruby_package();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_ruby_package_accessor();
 
   public:
   // optional .google.protobuf.FeatureSet features = 50;
@@ -5758,6 +5779,17 @@ class PROTOBUF_EXPORT FileOptions final :
   bool _internal_deprecated() const;
   void _internal_set_deprecated(bool value);
 
+  public:
+  // optional bool cc_mutable_donated_string = 32 [default = false];
+  bool has_cc_mutable_donated_string() const;
+  void clear_cc_mutable_donated_string() ;
+  bool cc_mutable_donated_string() const;
+  void set_cc_mutable_donated_string(bool value);
+
+  private:
+  bool _internal_cc_mutable_donated_string() const;
+  void _internal_set_cc_mutable_donated_string(bool value);
+
   public:
   // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
   bool has_optimize_for() const;
@@ -5964,7 +5996,7 @@ class PROTOBUF_EXPORT FileOptions final :
 
   friend class ::google::protobuf::internal::TcParser;
   static const ::google::protobuf::internal::TcParseTable<
-      5, 22, 3,
+      5, 23, 3,
       202, 12>
       _table_;
   friend class ::google::protobuf::MessageLite;
@@ -6005,6 +6037,7 @@ class PROTOBUF_EXPORT FileOptions final :
     bool py_generic_services_;
     bool php_generic_services_;
     bool deprecated_;
+    bool cc_mutable_donated_string_;
     int optimize_for_;
     bool cc_enable_arenas_;
     PROTOBUF_TSAN_DECLARE_MEMBER
@@ -8266,6 +8299,7 @@ class PROTOBUF_EXPORT OneofDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.OneofOptions options = 2;
@@ -8470,6 +8504,7 @@ class PROTOBUF_EXPORT MethodDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional string input_type = 2;
@@ -8487,6 +8522,7 @@ class PROTOBUF_EXPORT MethodDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_type(
       const std::string& value);
   std::string* _internal_mutable_input_type();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_input_type_accessor();
 
   public:
   // optional string output_type = 3;
@@ -8504,6 +8540,7 @@ class PROTOBUF_EXPORT MethodDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_type(
       const std::string& value);
   std::string* _internal_mutable_output_type();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_output_type_accessor();
 
   public:
   // optional .google.protobuf.MethodOptions options = 4;
@@ -8796,6 +8833,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional string extendee = 2;
@@ -8813,6 +8851,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_extendee(
       const std::string& value);
   std::string* _internal_mutable_extendee();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_extendee_accessor();
 
   public:
   // optional string type_name = 6;
@@ -8830,6 +8869,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_name(
       const std::string& value);
   std::string* _internal_mutable_type_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_type_name_accessor();
 
   public:
   // optional string default_value = 7;
@@ -8847,6 +8887,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(
       const std::string& value);
   std::string* _internal_mutable_default_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_default_value_accessor();
 
   public:
   // optional string json_name = 10;
@@ -8864,6 +8905,7 @@ class PROTOBUF_EXPORT FieldDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_json_name(
       const std::string& value);
   std::string* _internal_mutable_json_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_json_name_accessor();
 
   public:
   // optional .google.protobuf.FieldOptions options = 8;
@@ -9129,6 +9171,7 @@ class PROTOBUF_EXPORT EnumValueDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.EnumValueOptions options = 3;
@@ -9567,6 +9610,7 @@ class PROTOBUF_EXPORT ServiceDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.ServiceOptions options = 3;
@@ -9837,6 +9881,7 @@ class PROTOBUF_EXPORT EnumDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.EnumOptions options = 3;
@@ -10205,6 +10250,7 @@ class PROTOBUF_EXPORT DescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional .google.protobuf.MessageOptions options = 7;
@@ -10560,6 +10606,7 @@ class PROTOBUF_EXPORT FileDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // optional string package = 2;
@@ -10577,6 +10624,7 @@ class PROTOBUF_EXPORT FileDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_package(
       const std::string& value);
   std::string* _internal_mutable_package();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_package_accessor();
 
   public:
   // optional string syntax = 12;
@@ -10594,6 +10642,7 @@ class PROTOBUF_EXPORT FileDescriptorProto final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_syntax(
       const std::string& value);
   std::string* _internal_mutable_syntax();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_syntax_accessor();
 
   public:
   // optional .google.protobuf.FileOptions options = 8;
@@ -10957,7 +11006,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.name)
 }
 inline std::string* FileDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileDescriptorProto.name)
   return _s;
 }
@@ -10975,6 +11024,11 @@ inline std::string* FileDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileDescriptorProto::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* FileDescriptorProto::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileDescriptorProto.name)
@@ -11028,7 +11082,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileDescriptorProto::set_package(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.package)
 }
 inline std::string* FileDescriptorProto::mutable_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_package();
+  auto _s = _internal_mutable_package();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileDescriptorProto.package)
   return _s;
 }
@@ -11046,6 +11100,11 @@ inline std::string* FileDescriptorProto::_internal_mutable_package() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.package_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileDescriptorProto::_internal_mutable_package_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.package_.MutableAccessor( GetArena());
+}
 inline std::string* FileDescriptorProto::release_package() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileDescriptorProto.package)
@@ -11089,7 +11148,7 @@ inline void FileDescriptorProto::clear_dependency() {
 inline std::string* FileDescriptorProto::add_dependency()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  std::string* _s = _internal_mutable_dependency()->Add();
+  auto _s = _internal_mutable_dependency()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.FileDescriptorProto.dependency)
   return _s;
 }
@@ -11101,35 +11160,36 @@ inline const std::string& FileDescriptorProto::dependency(int index) const
 inline std::string* FileDescriptorProto::mutable_dependency(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileDescriptorProto.dependency)
-  return _internal_mutable_dependency()->Mutable(index);
+  return _internal_mutable_dependency()->MutableString(index);
 }
 inline void FileDescriptorProto::set_dependency(int index, const std::string& value) {
-  _internal_mutable_dependency()->Mutable(index)->assign(value);
+  _internal_mutable_dependency()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.dependency)
 }
 inline void FileDescriptorProto::set_dependency(int index, std::string&& value) {
-  _internal_mutable_dependency()->Mutable(index)->assign(std::move(value));
+  _internal_mutable_dependency()->MutableAccessor(index)->assign(
+      std::move(value));
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.dependency)
 }
 inline void FileDescriptorProto::set_dependency(int index, const char* value) {
   ABSL_DCHECK(value != nullptr);
-  _internal_mutable_dependency()->Mutable(index)->assign(value);
+  _internal_mutable_dependency()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set_char:google.protobuf.FileDescriptorProto.dependency)
 }
 inline void FileDescriptorProto::set_dependency(int index, const char* value,
                               std::size_t size) {
-  _internal_mutable_dependency()->Mutable(index)->assign(
+  _internal_mutable_dependency()->MutableAccessor(index)->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_set_pointer:google.protobuf.FileDescriptorProto.dependency)
 }
 inline void FileDescriptorProto::set_dependency(int index, absl::string_view value) {
-  _internal_mutable_dependency()->Mutable(index)->assign(value.data(),
-                                                     value.size());
+  _internal_mutable_dependency()->MutableAccessor(index)->assign(
+      value.data(), value.size());
   // @@protoc_insertion_point(field_set_string_piece:google.protobuf.FileDescriptorProto.dependency)
 }
 inline void FileDescriptorProto::add_dependency(const std::string& value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_dependency()->Add()->assign(value);
+  _internal_mutable_dependency()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add:google.protobuf.FileDescriptorProto.dependency)
 }
 inline void FileDescriptorProto::add_dependency(std::string&& value) {
@@ -11140,18 +11200,18 @@ inline void FileDescriptorProto::add_dependency(std::string&& value) {
 inline void FileDescriptorProto::add_dependency(const char* value) {
   ABSL_DCHECK(value != nullptr);
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_dependency()->Add()->assign(value);
+  _internal_mutable_dependency()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add_char:google.protobuf.FileDescriptorProto.dependency)
 }
 inline void FileDescriptorProto::add_dependency(const char* value, std::size_t size) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_dependency()->Add()->assign(
+  _internal_mutable_dependency()->AddAccessor()->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_add_pointer:google.protobuf.FileDescriptorProto.dependency)
 }
 inline void FileDescriptorProto::add_dependency(absl::string_view value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_dependency()->Add()->assign(value.data(), value.size());
+  _internal_mutable_dependency()->AddAccessor()->assign(value.data(), value.size());
   // @@protoc_insertion_point(field_add_string_piece:google.protobuf.FileDescriptorProto.dependency)
 }
 inline const ::google::protobuf::RepeatedPtrField<std::string>&
@@ -11678,7 +11738,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileDescriptorProto::set_syntax(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileDescriptorProto.syntax)
 }
 inline std::string* FileDescriptorProto::mutable_syntax() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_syntax();
+  auto _s = _internal_mutable_syntax();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileDescriptorProto.syntax)
   return _s;
 }
@@ -11696,6 +11756,11 @@ inline std::string* FileDescriptorProto::_internal_mutable_syntax() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.syntax_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileDescriptorProto::_internal_mutable_syntax_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.syntax_.MutableAccessor( GetArena());
+}
 inline std::string* FileDescriptorProto::release_syntax() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileDescriptorProto.syntax)
@@ -11998,7 +12063,7 @@ inline PROTOBUF_ALWAYS_INLINE void DescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.DescriptorProto.name)
 }
 inline std::string* DescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.DescriptorProto.name)
   return _s;
 }
@@ -12016,6 +12081,11 @@ inline std::string* DescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor DescriptorProto::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* DescriptorProto::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.DescriptorProto.name)
@@ -12498,7 +12568,7 @@ inline void DescriptorProto::clear_reserved_name() {
 inline std::string* DescriptorProto::add_reserved_name()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  std::string* _s = _internal_mutable_reserved_name()->Add();
+  auto _s = _internal_mutable_reserved_name()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.DescriptorProto.reserved_name)
   return _s;
 }
@@ -12510,35 +12580,36 @@ inline const std::string& DescriptorProto::reserved_name(int index) const
 inline std::string* DescriptorProto::mutable_reserved_name(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.DescriptorProto.reserved_name)
-  return _internal_mutable_reserved_name()->Mutable(index);
+  return _internal_mutable_reserved_name()->MutableString(index);
 }
 inline void DescriptorProto::set_reserved_name(int index, const std::string& value) {
-  _internal_mutable_reserved_name()->Mutable(index)->assign(value);
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set:google.protobuf.DescriptorProto.reserved_name)
 }
 inline void DescriptorProto::set_reserved_name(int index, std::string&& value) {
-  _internal_mutable_reserved_name()->Mutable(index)->assign(std::move(value));
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(
+      std::move(value));
   // @@protoc_insertion_point(field_set:google.protobuf.DescriptorProto.reserved_name)
 }
 inline void DescriptorProto::set_reserved_name(int index, const char* value) {
   ABSL_DCHECK(value != nullptr);
-  _internal_mutable_reserved_name()->Mutable(index)->assign(value);
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set_char:google.protobuf.DescriptorProto.reserved_name)
 }
 inline void DescriptorProto::set_reserved_name(int index, const char* value,
                               std::size_t size) {
-  _internal_mutable_reserved_name()->Mutable(index)->assign(
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_set_pointer:google.protobuf.DescriptorProto.reserved_name)
 }
 inline void DescriptorProto::set_reserved_name(int index, absl::string_view value) {
-  _internal_mutable_reserved_name()->Mutable(index)->assign(value.data(),
-                                                     value.size());
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(
+      value.data(), value.size());
   // @@protoc_insertion_point(field_set_string_piece:google.protobuf.DescriptorProto.reserved_name)
 }
 inline void DescriptorProto::add_reserved_name(const std::string& value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_reserved_name()->Add()->assign(value);
+  _internal_mutable_reserved_name()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add:google.protobuf.DescriptorProto.reserved_name)
 }
 inline void DescriptorProto::add_reserved_name(std::string&& value) {
@@ -12549,18 +12620,18 @@ inline void DescriptorProto::add_reserved_name(std::string&& value) {
 inline void DescriptorProto::add_reserved_name(const char* value) {
   ABSL_DCHECK(value != nullptr);
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_reserved_name()->Add()->assign(value);
+  _internal_mutable_reserved_name()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add_char:google.protobuf.DescriptorProto.reserved_name)
 }
 inline void DescriptorProto::add_reserved_name(const char* value, std::size_t size) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_reserved_name()->Add()->assign(
+  _internal_mutable_reserved_name()->AddAccessor()->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_add_pointer:google.protobuf.DescriptorProto.reserved_name)
 }
 inline void DescriptorProto::add_reserved_name(absl::string_view value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_reserved_name()->Add()->assign(value.data(), value.size());
+  _internal_mutable_reserved_name()->AddAccessor()->assign(value.data(), value.size());
   // @@protoc_insertion_point(field_add_string_piece:google.protobuf.DescriptorProto.reserved_name)
 }
 inline const ::google::protobuf::RepeatedPtrField<std::string>&
@@ -12641,7 +12712,7 @@ inline PROTOBUF_ALWAYS_INLINE void ExtensionRangeOptions_Declaration::set_full_n
   // @@protoc_insertion_point(field_set:google.protobuf.ExtensionRangeOptions.Declaration.full_name)
 }
 inline std::string* ExtensionRangeOptions_Declaration::mutable_full_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_full_name();
+  auto _s = _internal_mutable_full_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.ExtensionRangeOptions.Declaration.full_name)
   return _s;
 }
@@ -12659,6 +12730,11 @@ inline std::string* ExtensionRangeOptions_Declaration::_internal_mutable_full_na
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.full_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor ExtensionRangeOptions_Declaration::_internal_mutable_full_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.full_name_.MutableAccessor( GetArena());
+}
 inline std::string* ExtensionRangeOptions_Declaration::release_full_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.ExtensionRangeOptions.Declaration.full_name)
@@ -12712,7 +12788,7 @@ inline PROTOBUF_ALWAYS_INLINE void ExtensionRangeOptions_Declaration::set_type(A
   // @@protoc_insertion_point(field_set:google.protobuf.ExtensionRangeOptions.Declaration.type)
 }
 inline std::string* ExtensionRangeOptions_Declaration::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_type();
+  auto _s = _internal_mutable_type();
   // @@protoc_insertion_point(field_mutable:google.protobuf.ExtensionRangeOptions.Declaration.type)
   return _s;
 }
@@ -12730,6 +12806,11 @@ inline std::string* ExtensionRangeOptions_Declaration::_internal_mutable_type()
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.type_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor ExtensionRangeOptions_Declaration::_internal_mutable_type_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.type_.MutableAccessor( GetArena());
+}
 inline std::string* ExtensionRangeOptions_Declaration::release_type() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.ExtensionRangeOptions.Declaration.type)
@@ -13070,7 +13151,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.name)
 }
 inline std::string* FieldDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.name)
   return _s;
 }
@@ -13088,6 +13169,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.name)
@@ -13227,7 +13313,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_type_name(Arg_&& ar
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.type_name)
 }
 inline std::string* FieldDescriptorProto::mutable_type_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_type_name();
+  auto _s = _internal_mutable_type_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.type_name)
   return _s;
 }
@@ -13245,6 +13331,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_type_name() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.type_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_type_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.type_name_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_type_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.type_name)
@@ -13298,7 +13389,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_extendee(Arg_&& arg
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.extendee)
 }
 inline std::string* FieldDescriptorProto::mutable_extendee() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_extendee();
+  auto _s = _internal_mutable_extendee();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.extendee)
   return _s;
 }
@@ -13316,6 +13407,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_extendee() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.extendee_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_extendee_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.extendee_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_extendee() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.extendee)
@@ -13369,7 +13465,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_default_value(Arg_&
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.default_value)
 }
 inline std::string* FieldDescriptorProto::mutable_default_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_default_value();
+  auto _s = _internal_mutable_default_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.default_value)
   return _s;
 }
@@ -13387,6 +13483,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_default_value() {
   _impl_._has_bits_[0] |= 0x00000008u;
   return _impl_.default_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_default_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000008u;
+  return _impl_.default_value_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_default_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.default_value)
@@ -13468,7 +13569,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldDescriptorProto::set_json_name(Arg_&& ar
   // @@protoc_insertion_point(field_set:google.protobuf.FieldDescriptorProto.json_name)
 }
 inline std::string* FieldDescriptorProto::mutable_json_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_json_name();
+  auto _s = _internal_mutable_json_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldDescriptorProto.json_name)
   return _s;
 }
@@ -13486,6 +13587,11 @@ inline std::string* FieldDescriptorProto::_internal_mutable_json_name() {
   _impl_._has_bits_[0] |= 0x00000010u;
   return _impl_.json_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldDescriptorProto::_internal_mutable_json_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000010u;
+  return _impl_.json_name_.MutableAccessor( GetArena());
+}
 inline std::string* FieldDescriptorProto::release_json_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldDescriptorProto.json_name)
@@ -13667,7 +13773,7 @@ inline PROTOBUF_ALWAYS_INLINE void OneofDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.OneofDescriptorProto.name)
 }
 inline std::string* OneofDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.OneofDescriptorProto.name)
   return _s;
 }
@@ -13685,6 +13791,11 @@ inline std::string* OneofDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor OneofDescriptorProto::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* OneofDescriptorProto::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.OneofDescriptorProto.name)
@@ -13898,7 +14009,7 @@ inline PROTOBUF_ALWAYS_INLINE void EnumDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.EnumDescriptorProto.name)
 }
 inline std::string* EnumDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.EnumDescriptorProto.name)
   return _s;
 }
@@ -13916,6 +14027,11 @@ inline std::string* EnumDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor EnumDescriptorProto::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* EnumDescriptorProto::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.EnumDescriptorProto.name)
@@ -14153,7 +14269,7 @@ inline void EnumDescriptorProto::clear_reserved_name() {
 inline std::string* EnumDescriptorProto::add_reserved_name()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  std::string* _s = _internal_mutable_reserved_name()->Add();
+  auto _s = _internal_mutable_reserved_name()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.EnumDescriptorProto.reserved_name)
   return _s;
 }
@@ -14165,35 +14281,36 @@ inline const std::string& EnumDescriptorProto::reserved_name(int index) const
 inline std::string* EnumDescriptorProto::mutable_reserved_name(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.EnumDescriptorProto.reserved_name)
-  return _internal_mutable_reserved_name()->Mutable(index);
+  return _internal_mutable_reserved_name()->MutableString(index);
 }
 inline void EnumDescriptorProto::set_reserved_name(int index, const std::string& value) {
-  _internal_mutable_reserved_name()->Mutable(index)->assign(value);
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline void EnumDescriptorProto::set_reserved_name(int index, std::string&& value) {
-  _internal_mutable_reserved_name()->Mutable(index)->assign(std::move(value));
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(
+      std::move(value));
   // @@protoc_insertion_point(field_set:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline void EnumDescriptorProto::set_reserved_name(int index, const char* value) {
   ABSL_DCHECK(value != nullptr);
-  _internal_mutable_reserved_name()->Mutable(index)->assign(value);
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set_char:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline void EnumDescriptorProto::set_reserved_name(int index, const char* value,
                               std::size_t size) {
-  _internal_mutable_reserved_name()->Mutable(index)->assign(
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_set_pointer:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline void EnumDescriptorProto::set_reserved_name(int index, absl::string_view value) {
-  _internal_mutable_reserved_name()->Mutable(index)->assign(value.data(),
-                                                     value.size());
+  _internal_mutable_reserved_name()->MutableAccessor(index)->assign(
+      value.data(), value.size());
   // @@protoc_insertion_point(field_set_string_piece:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline void EnumDescriptorProto::add_reserved_name(const std::string& value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_reserved_name()->Add()->assign(value);
+  _internal_mutable_reserved_name()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline void EnumDescriptorProto::add_reserved_name(std::string&& value) {
@@ -14204,18 +14321,18 @@ inline void EnumDescriptorProto::add_reserved_name(std::string&& value) {
 inline void EnumDescriptorProto::add_reserved_name(const char* value) {
   ABSL_DCHECK(value != nullptr);
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_reserved_name()->Add()->assign(value);
+  _internal_mutable_reserved_name()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add_char:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline void EnumDescriptorProto::add_reserved_name(const char* value, std::size_t size) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_reserved_name()->Add()->assign(
+  _internal_mutable_reserved_name()->AddAccessor()->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_add_pointer:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline void EnumDescriptorProto::add_reserved_name(absl::string_view value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_reserved_name()->Add()->assign(value.data(), value.size());
+  _internal_mutable_reserved_name()->AddAccessor()->assign(value.data(), value.size());
   // @@protoc_insertion_point(field_add_string_piece:google.protobuf.EnumDescriptorProto.reserved_name)
 }
 inline const ::google::protobuf::RepeatedPtrField<std::string>&
@@ -14268,7 +14385,7 @@ inline PROTOBUF_ALWAYS_INLINE void EnumValueDescriptorProto::set_name(Arg_&& arg
   // @@protoc_insertion_point(field_set:google.protobuf.EnumValueDescriptorProto.name)
 }
 inline std::string* EnumValueDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.EnumValueDescriptorProto.name)
   return _s;
 }
@@ -14286,6 +14403,11 @@ inline std::string* EnumValueDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor EnumValueDescriptorProto::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* EnumValueDescriptorProto::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.EnumValueDescriptorProto.name)
@@ -14467,7 +14589,7 @@ inline PROTOBUF_ALWAYS_INLINE void ServiceDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.ServiceDescriptorProto.name)
 }
 inline std::string* ServiceDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.ServiceDescriptorProto.name)
   return _s;
 }
@@ -14485,6 +14607,11 @@ inline std::string* ServiceDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor ServiceDescriptorProto::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* ServiceDescriptorProto::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.ServiceDescriptorProto.name)
@@ -14687,7 +14814,7 @@ inline PROTOBUF_ALWAYS_INLINE void MethodDescriptorProto::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.MethodDescriptorProto.name)
 }
 inline std::string* MethodDescriptorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.MethodDescriptorProto.name)
   return _s;
 }
@@ -14705,6 +14832,11 @@ inline std::string* MethodDescriptorProto::_internal_mutable_name() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor MethodDescriptorProto::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* MethodDescriptorProto::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.MethodDescriptorProto.name)
@@ -14758,7 +14890,7 @@ inline PROTOBUF_ALWAYS_INLINE void MethodDescriptorProto::set_input_type(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.MethodDescriptorProto.input_type)
 }
 inline std::string* MethodDescriptorProto::mutable_input_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_input_type();
+  auto _s = _internal_mutable_input_type();
   // @@protoc_insertion_point(field_mutable:google.protobuf.MethodDescriptorProto.input_type)
   return _s;
 }
@@ -14776,6 +14908,11 @@ inline std::string* MethodDescriptorProto::_internal_mutable_input_type() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.input_type_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor MethodDescriptorProto::_internal_mutable_input_type_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.input_type_.MutableAccessor( GetArena());
+}
 inline std::string* MethodDescriptorProto::release_input_type() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.MethodDescriptorProto.input_type)
@@ -14829,7 +14966,7 @@ inline PROTOBUF_ALWAYS_INLINE void MethodDescriptorProto::set_output_type(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.MethodDescriptorProto.output_type)
 }
 inline std::string* MethodDescriptorProto::mutable_output_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_output_type();
+  auto _s = _internal_mutable_output_type();
   // @@protoc_insertion_point(field_mutable:google.protobuf.MethodDescriptorProto.output_type)
   return _s;
 }
@@ -14847,6 +14984,11 @@ inline std::string* MethodDescriptorProto::_internal_mutable_output_type() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.output_type_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor MethodDescriptorProto::_internal_mutable_output_type_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.output_type_.MutableAccessor( GetArena());
+}
 inline std::string* MethodDescriptorProto::release_output_type() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.MethodDescriptorProto.output_type)
@@ -15056,7 +15198,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_java_package(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.java_package)
 }
 inline std::string* FileOptions::mutable_java_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_java_package();
+  auto _s = _internal_mutable_java_package();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.java_package)
   return _s;
 }
@@ -15074,6 +15216,11 @@ inline std::string* FileOptions::_internal_mutable_java_package() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.java_package_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_java_package_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.java_package_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_java_package() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.java_package)
@@ -15127,7 +15274,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_java_outer_classname(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.java_outer_classname)
 }
 inline std::string* FileOptions::mutable_java_outer_classname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_java_outer_classname();
+  auto _s = _internal_mutable_java_outer_classname();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.java_outer_classname)
   return _s;
 }
@@ -15145,6 +15292,11 @@ inline std::string* FileOptions::_internal_mutable_java_outer_classname() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.java_outer_classname_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_java_outer_classname_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.java_outer_classname_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_java_outer_classname() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.java_outer_classname)
@@ -15260,13 +15412,13 @@ inline void FileOptions::_internal_set_java_string_check_utf8(bool value) {
 
 // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
 inline bool FileOptions::has_optimize_for() const {
-  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
+  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
   return value;
 }
 inline void FileOptions::clear_optimize_for() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   _impl_.optimize_for_ = 1;
-  _impl_._has_bits_[0] &= ~0x00080000u;
+  _impl_._has_bits_[0] &= ~0x00100000u;
 }
 inline ::google::protobuf::FileOptions_OptimizeMode FileOptions::optimize_for() const {
   // @@protoc_insertion_point(field_get:google.protobuf.FileOptions.optimize_for)
@@ -15283,7 +15435,7 @@ inline ::google::protobuf::FileOptions_OptimizeMode FileOptions::_internal_optim
 inline void FileOptions::_internal_set_optimize_for(::google::protobuf::FileOptions_OptimizeMode value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   assert(::google::protobuf::FileOptions_OptimizeMode_IsValid(value));
-  _impl_._has_bits_[0] |= 0x00080000u;
+  _impl_._has_bits_[0] |= 0x00100000u;
   _impl_.optimize_for_ = value;
 }
 
@@ -15311,7 +15463,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_go_package(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.go_package)
 }
 inline std::string* FileOptions::mutable_go_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_go_package();
+  auto _s = _internal_mutable_go_package();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.go_package)
   return _s;
 }
@@ -15329,6 +15481,11 @@ inline std::string* FileOptions::_internal_mutable_go_package() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.go_package_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_go_package_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.go_package_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_go_package() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.go_package)
@@ -15500,13 +15657,13 @@ inline void FileOptions::_internal_set_deprecated(bool value) {
 
 // optional bool cc_enable_arenas = 31 [default = true];
 inline bool FileOptions::has_cc_enable_arenas() const {
-  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
+  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
   return value;
 }
 inline void FileOptions::clear_cc_enable_arenas() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   _impl_.cc_enable_arenas_ = true;
-  _impl_._has_bits_[0] &= ~0x00100000u;
+  _impl_._has_bits_[0] &= ~0x00200000u;
 }
 inline bool FileOptions::cc_enable_arenas() const {
   // @@protoc_insertion_point(field_get:google.protobuf.FileOptions.cc_enable_arenas)
@@ -15522,10 +15679,38 @@ inline bool FileOptions::_internal_cc_enable_arenas() const {
 }
 inline void FileOptions::_internal_set_cc_enable_arenas(bool value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _impl_._has_bits_[0] |= 0x00100000u;
+  _impl_._has_bits_[0] |= 0x00200000u;
   _impl_.cc_enable_arenas_ = value;
 }
 
+// optional bool cc_mutable_donated_string = 32 [default = false];
+inline bool FileOptions::has_cc_mutable_donated_string() const {
+  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
+  return value;
+}
+inline void FileOptions::clear_cc_mutable_donated_string() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_.cc_mutable_donated_string_ = false;
+  _impl_._has_bits_[0] &= ~0x00080000u;
+}
+inline bool FileOptions::cc_mutable_donated_string() const {
+  // @@protoc_insertion_point(field_get:google.protobuf.FileOptions.cc_mutable_donated_string)
+  return _internal_cc_mutable_donated_string();
+}
+inline void FileOptions::set_cc_mutable_donated_string(bool value) {
+  _internal_set_cc_mutable_donated_string(value);
+  // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.cc_mutable_donated_string)
+}
+inline bool FileOptions::_internal_cc_mutable_donated_string() const {
+  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
+  return _impl_.cc_mutable_donated_string_;
+}
+inline void FileOptions::_internal_set_cc_mutable_donated_string(bool value) {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00080000u;
+  _impl_.cc_mutable_donated_string_ = value;
+}
+
 // optional string objc_class_prefix = 36;
 inline bool FileOptions::has_objc_class_prefix() const {
   bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
@@ -15550,7 +15735,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_objc_class_prefix(Arg_&& arg
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.objc_class_prefix)
 }
 inline std::string* FileOptions::mutable_objc_class_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_objc_class_prefix();
+  auto _s = _internal_mutable_objc_class_prefix();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.objc_class_prefix)
   return _s;
 }
@@ -15568,6 +15753,11 @@ inline std::string* FileOptions::_internal_mutable_objc_class_prefix() {
   _impl_._has_bits_[0] |= 0x00000008u;
   return _impl_.objc_class_prefix_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_objc_class_prefix_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000008u;
+  return _impl_.objc_class_prefix_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_objc_class_prefix() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.objc_class_prefix)
@@ -15621,7 +15811,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_csharp_namespace(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.csharp_namespace)
 }
 inline std::string* FileOptions::mutable_csharp_namespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_csharp_namespace();
+  auto _s = _internal_mutable_csharp_namespace();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.csharp_namespace)
   return _s;
 }
@@ -15639,6 +15829,11 @@ inline std::string* FileOptions::_internal_mutable_csharp_namespace() {
   _impl_._has_bits_[0] |= 0x00000010u;
   return _impl_.csharp_namespace_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_csharp_namespace_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000010u;
+  return _impl_.csharp_namespace_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_csharp_namespace() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.csharp_namespace)
@@ -15692,7 +15887,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_swift_prefix(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.swift_prefix)
 }
 inline std::string* FileOptions::mutable_swift_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_swift_prefix();
+  auto _s = _internal_mutable_swift_prefix();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.swift_prefix)
   return _s;
 }
@@ -15710,6 +15905,11 @@ inline std::string* FileOptions::_internal_mutable_swift_prefix() {
   _impl_._has_bits_[0] |= 0x00000020u;
   return _impl_.swift_prefix_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_swift_prefix_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000020u;
+  return _impl_.swift_prefix_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_swift_prefix() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.swift_prefix)
@@ -15763,7 +15963,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_php_class_prefix(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.php_class_prefix)
 }
 inline std::string* FileOptions::mutable_php_class_prefix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_php_class_prefix();
+  auto _s = _internal_mutable_php_class_prefix();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.php_class_prefix)
   return _s;
 }
@@ -15781,6 +15981,11 @@ inline std::string* FileOptions::_internal_mutable_php_class_prefix() {
   _impl_._has_bits_[0] |= 0x00000040u;
   return _impl_.php_class_prefix_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_php_class_prefix_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000040u;
+  return _impl_.php_class_prefix_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_php_class_prefix() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.php_class_prefix)
@@ -15834,7 +16039,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_php_namespace(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.php_namespace)
 }
 inline std::string* FileOptions::mutable_php_namespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_php_namespace();
+  auto _s = _internal_mutable_php_namespace();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.php_namespace)
   return _s;
 }
@@ -15852,6 +16057,11 @@ inline std::string* FileOptions::_internal_mutable_php_namespace() {
   _impl_._has_bits_[0] |= 0x00000080u;
   return _impl_.php_namespace_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_php_namespace_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000080u;
+  return _impl_.php_namespace_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_php_namespace() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.php_namespace)
@@ -15905,7 +16115,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_php_metadata_namespace(Arg_&
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.php_metadata_namespace)
 }
 inline std::string* FileOptions::mutable_php_metadata_namespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_php_metadata_namespace();
+  auto _s = _internal_mutable_php_metadata_namespace();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.php_metadata_namespace)
   return _s;
 }
@@ -15923,6 +16133,11 @@ inline std::string* FileOptions::_internal_mutable_php_metadata_namespace() {
   _impl_._has_bits_[0] |= 0x00000100u;
   return _impl_.php_metadata_namespace_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_php_metadata_namespace_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000100u;
+  return _impl_.php_metadata_namespace_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_php_metadata_namespace() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.php_metadata_namespace)
@@ -15976,7 +16191,7 @@ inline PROTOBUF_ALWAYS_INLINE void FileOptions::set_ruby_package(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.ruby_package)
 }
 inline std::string* FileOptions::mutable_ruby_package() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_ruby_package();
+  auto _s = _internal_mutable_ruby_package();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FileOptions.ruby_package)
   return _s;
 }
@@ -15994,6 +16209,11 @@ inline std::string* FileOptions::_internal_mutable_ruby_package() {
   _impl_._has_bits_[0] |= 0x00000200u;
   return _impl_.ruby_package_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FileOptions::_internal_mutable_ruby_package_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000200u;
+  return _impl_.ruby_package_.MutableAccessor( GetArena());
+}
 inline std::string* FileOptions::release_ruby_package() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FileOptions.ruby_package)
@@ -16514,7 +16734,7 @@ inline PROTOBUF_ALWAYS_INLINE void FieldOptions_EditionDefault::set_value(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.FieldOptions.EditionDefault.value)
 }
 inline std::string* FieldOptions_EditionDefault::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_value();
+  auto _s = _internal_mutable_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldOptions.EditionDefault.value)
   return _s;
 }
@@ -16532,6 +16752,11 @@ inline std::string* FieldOptions_EditionDefault::_internal_mutable_value() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor FieldOptions_EditionDefault::_internal_mutable_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.value_.MutableAccessor( GetArena());
+}
 inline std::string* FieldOptions_EditionDefault::release_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.FieldOptions.EditionDefault.value)
@@ -18058,7 +18283,7 @@ inline PROTOBUF_ALWAYS_INLINE void UninterpretedOption_NamePart::set_name_part(A
   // @@protoc_insertion_point(field_set:google.protobuf.UninterpretedOption.NamePart.name_part)
 }
 inline std::string* UninterpretedOption_NamePart::mutable_name_part() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name_part();
+  auto _s = _internal_mutable_name_part();
   // @@protoc_insertion_point(field_mutable:google.protobuf.UninterpretedOption.NamePart.name_part)
   return _s;
 }
@@ -18076,6 +18301,11 @@ inline std::string* UninterpretedOption_NamePart::_internal_mutable_name_part()
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.name_part_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor UninterpretedOption_NamePart::_internal_mutable_name_part_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.name_part_.MutableAccessor( GetArena());
+}
 inline std::string* UninterpretedOption_NamePart::release_name_part() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.UninterpretedOption.NamePart.name_part)
@@ -18210,7 +18440,7 @@ inline PROTOBUF_ALWAYS_INLINE void UninterpretedOption::set_identifier_value(Arg
   // @@protoc_insertion_point(field_set:google.protobuf.UninterpretedOption.identifier_value)
 }
 inline std::string* UninterpretedOption::mutable_identifier_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_identifier_value();
+  auto _s = _internal_mutable_identifier_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.UninterpretedOption.identifier_value)
   return _s;
 }
@@ -18228,6 +18458,11 @@ inline std::string* UninterpretedOption::_internal_mutable_identifier_value() {
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.identifier_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor UninterpretedOption::_internal_mutable_identifier_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.identifier_value_.MutableAccessor( GetArena());
+}
 inline std::string* UninterpretedOption::release_identifier_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.UninterpretedOption.identifier_value)
@@ -18365,7 +18600,7 @@ inline PROTOBUF_ALWAYS_INLINE void UninterpretedOption::set_string_value(Arg_&&
   // @@protoc_insertion_point(field_set:google.protobuf.UninterpretedOption.string_value)
 }
 inline std::string* UninterpretedOption::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_string_value();
+  auto _s = _internal_mutable_string_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.UninterpretedOption.string_value)
   return _s;
 }
@@ -18383,6 +18618,11 @@ inline std::string* UninterpretedOption::_internal_mutable_string_value() {
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.string_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor UninterpretedOption::_internal_mutable_string_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.string_value_.MutableAccessor( GetArena());
+}
 inline std::string* UninterpretedOption::release_string_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.UninterpretedOption.string_value)
@@ -18436,7 +18676,7 @@ inline PROTOBUF_ALWAYS_INLINE void UninterpretedOption::set_aggregate_value(Arg_
   // @@protoc_insertion_point(field_set:google.protobuf.UninterpretedOption.aggregate_value)
 }
 inline std::string* UninterpretedOption::mutable_aggregate_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_aggregate_value();
+  auto _s = _internal_mutable_aggregate_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.UninterpretedOption.aggregate_value)
   return _s;
 }
@@ -18454,6 +18694,11 @@ inline std::string* UninterpretedOption::_internal_mutable_aggregate_value() {
   _impl_._has_bits_[0] |= 0x00000004u;
   return _impl_.aggregate_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor UninterpretedOption::_internal_mutable_aggregate_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000004u;
+  return _impl_.aggregate_value_.MutableAccessor( GetArena());
+}
 inline std::string* UninterpretedOption::release_aggregate_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.UninterpretedOption.aggregate_value)
@@ -19019,7 +19264,7 @@ inline PROTOBUF_ALWAYS_INLINE void SourceCodeInfo_Location::set_leading_comments
   // @@protoc_insertion_point(field_set:google.protobuf.SourceCodeInfo.Location.leading_comments)
 }
 inline std::string* SourceCodeInfo_Location::mutable_leading_comments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_leading_comments();
+  auto _s = _internal_mutable_leading_comments();
   // @@protoc_insertion_point(field_mutable:google.protobuf.SourceCodeInfo.Location.leading_comments)
   return _s;
 }
@@ -19037,6 +19282,11 @@ inline std::string* SourceCodeInfo_Location::_internal_mutable_leading_comments(
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.leading_comments_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor SourceCodeInfo_Location::_internal_mutable_leading_comments_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.leading_comments_.MutableAccessor( GetArena());
+}
 inline std::string* SourceCodeInfo_Location::release_leading_comments() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.SourceCodeInfo.Location.leading_comments)
@@ -19090,7 +19340,7 @@ inline PROTOBUF_ALWAYS_INLINE void SourceCodeInfo_Location::set_trailing_comment
   // @@protoc_insertion_point(field_set:google.protobuf.SourceCodeInfo.Location.trailing_comments)
 }
 inline std::string* SourceCodeInfo_Location::mutable_trailing_comments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_trailing_comments();
+  auto _s = _internal_mutable_trailing_comments();
   // @@protoc_insertion_point(field_mutable:google.protobuf.SourceCodeInfo.Location.trailing_comments)
   return _s;
 }
@@ -19108,6 +19358,11 @@ inline std::string* SourceCodeInfo_Location::_internal_mutable_trailing_comments
   _impl_._has_bits_[0] |= 0x00000002u;
   return _impl_.trailing_comments_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor SourceCodeInfo_Location::_internal_mutable_trailing_comments_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000002u;
+  return _impl_.trailing_comments_.MutableAccessor( GetArena());
+}
 inline std::string* SourceCodeInfo_Location::release_trailing_comments() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.SourceCodeInfo.Location.trailing_comments)
@@ -19151,7 +19406,7 @@ inline void SourceCodeInfo_Location::clear_leading_detached_comments() {
 inline std::string* SourceCodeInfo_Location::add_leading_detached_comments()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  std::string* _s = _internal_mutable_leading_detached_comments()->Add();
+  auto _s = _internal_mutable_leading_detached_comments()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
   return _s;
 }
@@ -19163,35 +19418,36 @@ inline const std::string& SourceCodeInfo_Location::leading_detached_comments(int
 inline std::string* SourceCodeInfo_Location::mutable_leading_detached_comments(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
-  return _internal_mutable_leading_detached_comments()->Mutable(index);
+  return _internal_mutable_leading_detached_comments()->MutableString(index);
 }
 inline void SourceCodeInfo_Location::set_leading_detached_comments(int index, const std::string& value) {
-  _internal_mutable_leading_detached_comments()->Mutable(index)->assign(value);
+  _internal_mutable_leading_detached_comments()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline void SourceCodeInfo_Location::set_leading_detached_comments(int index, std::string&& value) {
-  _internal_mutable_leading_detached_comments()->Mutable(index)->assign(std::move(value));
+  _internal_mutable_leading_detached_comments()->MutableAccessor(index)->assign(
+      std::move(value));
   // @@protoc_insertion_point(field_set:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline void SourceCodeInfo_Location::set_leading_detached_comments(int index, const char* value) {
   ABSL_DCHECK(value != nullptr);
-  _internal_mutable_leading_detached_comments()->Mutable(index)->assign(value);
+  _internal_mutable_leading_detached_comments()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set_char:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline void SourceCodeInfo_Location::set_leading_detached_comments(int index, const char* value,
                               std::size_t size) {
-  _internal_mutable_leading_detached_comments()->Mutable(index)->assign(
+  _internal_mutable_leading_detached_comments()->MutableAccessor(index)->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_set_pointer:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline void SourceCodeInfo_Location::set_leading_detached_comments(int index, absl::string_view value) {
-  _internal_mutable_leading_detached_comments()->Mutable(index)->assign(value.data(),
-                                                     value.size());
+  _internal_mutable_leading_detached_comments()->MutableAccessor(index)->assign(
+      value.data(), value.size());
   // @@protoc_insertion_point(field_set_string_piece:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline void SourceCodeInfo_Location::add_leading_detached_comments(const std::string& value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_leading_detached_comments()->Add()->assign(value);
+  _internal_mutable_leading_detached_comments()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline void SourceCodeInfo_Location::add_leading_detached_comments(std::string&& value) {
@@ -19202,18 +19458,18 @@ inline void SourceCodeInfo_Location::add_leading_detached_comments(std::string&&
 inline void SourceCodeInfo_Location::add_leading_detached_comments(const char* value) {
   ABSL_DCHECK(value != nullptr);
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_leading_detached_comments()->Add()->assign(value);
+  _internal_mutable_leading_detached_comments()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add_char:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline void SourceCodeInfo_Location::add_leading_detached_comments(const char* value, std::size_t size) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_leading_detached_comments()->Add()->assign(
+  _internal_mutable_leading_detached_comments()->AddAccessor()->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_add_pointer:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline void SourceCodeInfo_Location::add_leading_detached_comments(absl::string_view value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_leading_detached_comments()->Add()->assign(value.data(), value.size());
+  _internal_mutable_leading_detached_comments()->AddAccessor()->assign(value.data(), value.size());
   // @@protoc_insertion_point(field_add_string_piece:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
 }
 inline const ::google::protobuf::RepeatedPtrField<std::string>&
@@ -19364,7 +19620,7 @@ inline PROTOBUF_ALWAYS_INLINE void GeneratedCodeInfo_Annotation::set_source_file
   // @@protoc_insertion_point(field_set:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
 }
 inline std::string* GeneratedCodeInfo_Annotation::mutable_source_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_source_file();
+  auto _s = _internal_mutable_source_file();
   // @@protoc_insertion_point(field_mutable:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
   return _s;
 }
@@ -19382,6 +19638,11 @@ inline std::string* GeneratedCodeInfo_Annotation::_internal_mutable_source_file(
   _impl_._has_bits_[0] |= 0x00000001u;
   return _impl_.source_file_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor GeneratedCodeInfo_Annotation::_internal_mutable_source_file_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  _impl_._has_bits_[0] |= 0x00000001u;
+  return _impl_.source_file_.MutableAccessor( GetArena());
+}
 inline std::string* GeneratedCodeInfo_Annotation::release_source_file() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
diff --git a/src/google/protobuf/descriptor.proto b/src/google/protobuf/descriptor.proto
index 474864353..4e3396e11 100644
--- a/src/google/protobuf/descriptor.proto
+++ b/src/google/protobuf/descriptor.proto
@@ -490,6 +490,11 @@ message FileOptions {
   // only to generated classes for C++.
   optional bool cc_enable_arenas = 31 [default = true];
 
+  // 增加新开关，控制生成代码的mutable_xxx接口行为和返回值
+  // false: 默认，将donated状态的string转换为heap allocated，通过std::string*返回
+  // true: 保持当前string的donated状态，通过MaybeArenaStringAccessor返回
+  optional bool cc_mutable_donated_string = 32 [default = false];
+
   // Sets the objective c class prefix which is prepended to all objective c
   // generated classes from this .proto. There is no default.
   optional string objc_class_prefix = 36;
diff --git a/src/google/protobuf/extension_set.cc b/src/google/protobuf/extension_set.cc
index 4b54d7a3b..dfd407409 100644
--- a/src/google/protobuf/extension_set.cc
+++ b/src/google/protobuf/extension_set.cc
@@ -517,23 +517,62 @@ const std::string& ExtensionSet::GetString(
     return default_value;
   } else {
     ABSL_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
-    return *extension->string_value;
+    return *extension->string_value.Get();
   }
 }
 
-std::string* ExtensionSet::MutableString(int number, FieldType type,
-                                         const FieldDescriptor* descriptor) {
+MutableStringType ExtensionSet::MutableString(int number, FieldType type,
+                                              const FieldDescriptor* descriptor) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(number, type, descriptor);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   Extension* extension;
+  std::string* string;
   if (MaybeNewExtension(number, descriptor, &extension)) {
     extension->type = type;
     ABSL_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
     extension->is_repeated = false;
-    extension->string_value = Arena::Create<std::string>(arena_);
+    string = Arena::Create<std::string>(arena_);
+    if (arena_ != nullptr) {
+      extension->string_value.SetMutableArena(string);
+    } else {
+      extension->string_value.SetAllocated(string);
+    }
   } else {
     ABSL_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
+    string = extension->string_value.Get();
+    if (extension->string_value.IsFixedSizeArena()) {
+      string = Arena::Create<std::string>(arena_, *string);
+      extension->string_value.SetMutableArena(string);
+    }
   }
   extension->is_cleared = false;
-  return extension->string_value;
+  return string;
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+MaybeArenaStringAccessor ExtensionSet::MutableAccessor(
+        int number, FieldType type, const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    ABSL_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
+    extension->is_repeated = false;
+    auto accessor = MaybeArenaStringAccessor::create(arena_);
+    if (arena_ != nullptr) {
+      extension->string_value.SetFixedSizeArena(accessor.underlying());
+    } else {
+      extension->string_value.SetAllocated(accessor.underlying());
+    }
+    extension->is_cleared = false;
+    return accessor;
+  } else {
+    ABSL_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
+    extension->is_cleared = false;
+    return MaybeArenaStringAccessor(
+            extension->string_value.IsFixedSizeArena() ? arena_ : nullptr,
+            extension->string_value.Get());
+  }
 }
 
 const std::string& ExtensionSet::GetRepeatedString(int number,
@@ -544,15 +583,22 @@ const std::string& ExtensionSet::GetRepeatedString(int number,
   return extension->repeated_string_value->Get(index);
 }
 
-std::string* ExtensionSet::MutableRepeatedString(int number, int index) {
+MutableStringType ExtensionSet::MutableRepeatedString(int number, int index) {
   Extension* extension = FindOrNull(number);
   ABSL_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
   ABSL_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
   return extension->repeated_string_value->Mutable(index);
 }
 
-std::string* ExtensionSet::AddString(int number, FieldType type,
-                                     const FieldDescriptor* descriptor) {
+MaybeArenaStringAccessor ExtensionSet::MutableRepeatedAccessor(int number, int index) {
+  Extension* extension = FindOrNull(number);
+  ABSL_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
+  ABSL_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  return extension->repeated_string_value->MutableAccessor(index);
+}
+
+MutableStringType ExtensionSet::AddString(int number, FieldType type,
+                                          const FieldDescriptor* descriptor) {
   Extension* extension;
   if (MaybeNewExtension(number, descriptor, &extension)) {
     extension->type = type;
@@ -567,6 +613,22 @@ std::string* ExtensionSet::AddString(int number, FieldType type,
   return extension->repeated_string_value->Add();
 }
 
+MaybeArenaStringAccessor ExtensionSet::AddAccessor(int number, FieldType type,
+                                                   const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    ABSL_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
+    extension->is_repeated = true;
+    extension->is_packed = false;
+    extension->repeated_string_value =
+        Arena::CreateMessage<RepeatedPtrField<std::string>>(arena_);
+  } else {
+    ABSL_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  }
+  return extension->repeated_string_value->AddAccessor();
+}
+
 // -------------------------------------------------------------------
 // Messages
 
@@ -1033,7 +1095,7 @@ void ExtensionSet::InternalExtensionMergeFrom(const MessageLite* extendee,
         HANDLE_TYPE(ENUM, enum, Enum);
 #undef HANDLE_TYPE
         case WireFormatLite::CPPTYPE_STRING:
-          SetString(number, other_extension.type, *other_extension.string_value,
+          SetString(number, other_extension.type, *other_extension.string_value.Get(),
                     other_extension.descriptor);
           break;
         case WireFormatLite::CPPTYPE_MESSAGE: {
@@ -1306,7 +1368,7 @@ void ExtensionSet::Extension::Clear() {
     if (!is_cleared) {
       switch (cpp_type(type)) {
         case WireFormatLite::CPPTYPE_STRING:
-          string_value->clear();
+          MaybeArenaStringAccessor::clear(string_value.Get());
           break;
         case WireFormatLite::CPPTYPE_MESSAGE:
           if (is_lazy) {
@@ -1435,8 +1497,8 @@ size_t ExtensionSet::Extension::ByteSize(int number) const {
       HANDLE_TYPE(UINT64, UInt64, uint64_t_value);
       HANDLE_TYPE(SINT32, SInt32, int32_t_value);
       HANDLE_TYPE(SINT64, SInt64, int64_t_value);
-      HANDLE_TYPE(STRING, String, *string_value);
-      HANDLE_TYPE(BYTES, Bytes, *string_value);
+      HANDLE_TYPE(STRING, String, *string_value.Get());
+      HANDLE_TYPE(BYTES, Bytes, *string_value.Get());
       HANDLE_TYPE(ENUM, Enum, enum_value);
       HANDLE_TYPE(GROUP, Group, *message_value);
 #undef HANDLE_TYPE
@@ -1518,7 +1580,7 @@ void ExtensionSet::Extension::Free() {
   } else {
     switch (cpp_type(type)) {
       case WireFormatLite::CPPTYPE_STRING:
-        delete string_value;
+        delete string_value.Get();
         break;
       case WireFormatLite::CPPTYPE_MESSAGE:
         if (is_lazy) {
@@ -1816,8 +1878,8 @@ uint8_t* ExtensionSet::Extension::InternalSerializeFieldWithCachedSizesToArray(
     target = stream->EnsureSpace(target);                \
     target = stream->WriteString(number, VALUE, target); \
     break
-      HANDLE_TYPE(STRING, String, *string_value);
-      HANDLE_TYPE(BYTES, Bytes, *string_value);
+      HANDLE_TYPE(STRING, String, *string_value.Get());
+      HANDLE_TYPE(BYTES, Bytes, *string_value.Get());
 #undef HANDLE_TYPE
       case WireFormatLite::TYPE_GROUP:
         target = stream->EnsureSpace(target);
diff --git a/src/google/protobuf/extension_set.h b/src/google/protobuf/extension_set.h
index f45a1c858..94e8add78 100644
--- a/src/google/protobuf/extension_set.h
+++ b/src/google/protobuf/extension_set.h
@@ -273,7 +273,8 @@ class PROTOBUF_EXPORT ExtensionSet {
   void SetBool(int number, FieldType type, bool value, desc);
   void SetEnum(int number, FieldType type, int value, desc);
   void SetString(int number, FieldType type, std::string value, desc);
-  std::string* MutableString(int number, FieldType type, desc);
+  MutableStringType MutableString(int number, FieldType type, desc);
+  MaybeArenaStringAccessor MutableAccessor(int number, FieldType type, desc);
   MessageLite* MutableMessage(int number, FieldType type,
                               const MessageLite& prototype, desc);
   MessageLite* MutableMessage(const FieldDescriptor* descriptor,
@@ -337,7 +338,8 @@ class PROTOBUF_EXPORT ExtensionSet {
   void SetRepeatedBool(int number, int index, bool value);
   void SetRepeatedEnum(int number, int index, int value);
   void SetRepeatedString(int number, int index, std::string value);
-  std::string* MutableRepeatedString(int number, int index);
+  MutableStringType MutableRepeatedString(int number, int index);
+  MaybeArenaStringAccessor MutableRepeatedAccessor(int number, int index);
   MessageLite* MutableRepeatedMessage(int number, int index);
 
 #define desc const FieldDescriptor* descriptor  // avoid line wrapping
@@ -350,7 +352,8 @@ class PROTOBUF_EXPORT ExtensionSet {
   void AddBool(int number, FieldType type, bool packed, bool value, desc);
   void AddEnum(int number, FieldType type, bool packed, int value, desc);
   void AddString(int number, FieldType type, std::string value, desc);
-  std::string* AddString(int number, FieldType type, desc);
+  MutableStringType AddString(int number, FieldType type, desc);
+  MaybeArenaStringAccessor AddAccessor(int number, FieldType type, desc);
   MessageLite* AddMessage(int number, FieldType type,
                           const MessageLite& prototype, desc);
   MessageLite* AddMessage(const FieldDescriptor* descriptor,
@@ -592,7 +595,7 @@ class PROTOBUF_EXPORT ExtensionSet {
       double double_value;
       bool bool_value;
       int enum_value;
-      std::string* string_value;
+      internal::TaggedStringPtr string_value;
       MessageLite* message_value;
       LazyMessageExtension* lazymessage_value;
 
@@ -919,16 +922,16 @@ constexpr ExtensionSet::ExtensionSet(Arena* arena)
 inline void ExtensionSet::SetString(int number, FieldType type,
                                     std::string value,
                                     const FieldDescriptor* descriptor) {
-  MutableString(number, type, descriptor)->assign(std::move(value));
+  MutableAccessor(number, type, descriptor)->assign(std::move(value));
 }
 inline void ExtensionSet::SetRepeatedString(int number, int index,
                                             std::string value) {
-  MutableRepeatedString(number, index)->assign(std::move(value));
+  MutableRepeatedAccessor(number, index)->assign(std::move(value));
 }
 inline void ExtensionSet::AddString(int number, FieldType type,
                                     std::string value,
                                     const FieldDescriptor* descriptor) {
-  AddString(number, type, descriptor)->assign(std::move(value));
+  AddAccessor(number, type, descriptor)->assign(std::move(value));
 }
 // ===================================================================
 // Glue for generated extension accessors
@@ -1147,7 +1150,7 @@ PROTOBUF_DEFINE_PRIMITIVE_TYPE(bool, Bool)
 class PROTOBUF_EXPORT StringTypeTraits {
  public:
   typedef const std::string& ConstType;
-  typedef std::string* MutableType;
+  typedef MutableStringType MutableType;
   typedef StringTypeTraits Singular;
   static constexpr bool kLifetimeBound = true;
 
@@ -1163,7 +1166,7 @@ class PROTOBUF_EXPORT StringTypeTraits {
                          const std::string& value, ExtensionSet* set) {
     set->SetString(number, field_type, value, nullptr);
   }
-  static inline std::string* Mutable(int number, FieldType field_type,
+  static inline MutableType Mutable(int number, FieldType field_type,
                                      ExtensionSet* set) {
     return set->MutableString(number, field_type, nullptr);
   }
@@ -1178,7 +1181,7 @@ class PROTOBUF_EXPORT StringTypeTraits {
 class PROTOBUF_EXPORT RepeatedStringTypeTraits {
  public:
   typedef const std::string& ConstType;
-  typedef std::string* MutableType;
+  typedef MutableStringType MutableType;
   typedef RepeatedStringTypeTraits Repeated;
   static constexpr bool kLifetimeBound = true;
 
@@ -1200,14 +1203,14 @@ class PROTOBUF_EXPORT RepeatedStringTypeTraits {
                          ExtensionSet* set) {
     set->SetRepeatedString(number, index, value);
   }
-  static inline std::string* Mutable(int number, int index, ExtensionSet* set) {
+  static inline MutableType Mutable(int number, int index, ExtensionSet* set) {
     return set->MutableRepeatedString(number, index);
   }
   static inline void Add(int number, FieldType field_type, bool /*is_packed*/,
                          const std::string& value, ExtensionSet* set) {
     set->AddString(number, field_type, value, nullptr);
   }
-  static inline std::string* Add(int number, FieldType field_type,
+  static inline MutableType Add(int number, FieldType field_type,
                                  ExtensionSet* set) {
     return set->AddString(number, field_type, nullptr);
   }
diff --git a/src/google/protobuf/extension_set_heavy.cc b/src/google/protobuf/extension_set_heavy.cc
index 20530c14d..ea874fa92 100644
--- a/src/google/protobuf/extension_set_heavy.cc
+++ b/src/google/protobuf/extension_set_heavy.cc
@@ -386,8 +386,8 @@ size_t ExtensionSet::Extension::SpaceUsedExcludingSelfLong() const {
   } else {
     switch (cpp_type(type)) {
       case FieldDescriptor::CPPTYPE_STRING:
-        total_size += sizeof(*string_value) +
-                      StringSpaceUsedExcludingSelfLong(*string_value);
+        total_size += sizeof(*string_value.Get()) +
+                      StringSpaceUsedExcludingSelfLong(*string_value.Get());
         break;
       case FieldDescriptor::CPPTYPE_MESSAGE:
         if (is_lazy) {
diff --git a/src/google/protobuf/extension_set_inl.h b/src/google/protobuf/extension_set_inl.h
index 7360f181a..90a0ddbdb 100644
--- a/src/google/protobuf/extension_set_inl.h
+++ b/src/google/protobuf/extension_set_inl.h
@@ -138,15 +138,13 @@ const char* ExtensionSet::ParseFieldWithExtensionInfo(
 
       case WireFormatLite::TYPE_BYTES:
       case WireFormatLite::TYPE_STRING: {
-        std::string* value =
+        auto value =
             extension.is_repeated
-                ? AddString(number, WireFormatLite::TYPE_STRING,
-                            extension.descriptor)
-                : MutableString(number, WireFormatLite::TYPE_STRING,
-                                extension.descriptor);
-        int size = ReadSize(&ptr);
-        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
-        return ctx->ReadString(ptr, size, value);
+                ? AddAccessor(number, WireFormatLite::TYPE_STRING,
+                              extension.descriptor)
+                : MutableAccessor(number, WireFormatLite::TYPE_STRING,
+                                  extension.descriptor);
+        return ctx->ReadArenaString(ptr, value);
       }
 
       case WireFormatLite::TYPE_GROUP: {
diff --git a/src/google/protobuf/extension_set_unittest.cc b/src/google/protobuf/extension_set_unittest.cc
index c65ebd96d..36b9afe5e 100644
--- a/src/google/protobuf/extension_set_unittest.cc
+++ b/src/google/protobuf/extension_set_unittest.cc
@@ -1131,10 +1131,17 @@ TEST(ExtensionSetTest, RepeatedFields) {
     ASSERT_EQ(x, 4321);
   }
   // Test one string field.
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  for (auto x :
+       *message.MutableRepeatedExtension(unittest::repeated_string_extension)) {
+    x = "test_range_based_for";
+  }
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   for (auto& x :
        *message.MutableRepeatedExtension(unittest::repeated_string_extension)) {
     x = "test_range_based_for";
   }
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   for (const auto& x :
        message.GetRepeatedExtension(unittest::repeated_string_extension)) {
     ASSERT_TRUE(x == "test_range_based_for");
diff --git a/src/google/protobuf/field_mask.pb.h b/src/google/protobuf/field_mask.pb.h
index f5b72c826..a5fbb7734 100644
--- a/src/google/protobuf/field_mask.pb.h
+++ b/src/google/protobuf/field_mask.pb.h
@@ -294,7 +294,7 @@ inline void FieldMask::clear_paths() {
 inline std::string* FieldMask::add_paths()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  std::string* _s = _internal_mutable_paths()->Add();
+  auto _s = _internal_mutable_paths()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.FieldMask.paths)
   return _s;
 }
@@ -306,35 +306,36 @@ inline const std::string& FieldMask::paths(int index) const
 inline std::string* FieldMask::mutable_paths(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.FieldMask.paths)
-  return _internal_mutable_paths()->Mutable(index);
+  return _internal_mutable_paths()->MutableString(index);
 }
 inline void FieldMask::set_paths(int index, const std::string& value) {
-  _internal_mutable_paths()->Mutable(index)->assign(value);
+  _internal_mutable_paths()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set:google.protobuf.FieldMask.paths)
 }
 inline void FieldMask::set_paths(int index, std::string&& value) {
-  _internal_mutable_paths()->Mutable(index)->assign(std::move(value));
+  _internal_mutable_paths()->MutableAccessor(index)->assign(
+      std::move(value));
   // @@protoc_insertion_point(field_set:google.protobuf.FieldMask.paths)
 }
 inline void FieldMask::set_paths(int index, const char* value) {
   ABSL_DCHECK(value != nullptr);
-  _internal_mutable_paths()->Mutable(index)->assign(value);
+  _internal_mutable_paths()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set_char:google.protobuf.FieldMask.paths)
 }
 inline void FieldMask::set_paths(int index, const char* value,
                               std::size_t size) {
-  _internal_mutable_paths()->Mutable(index)->assign(
+  _internal_mutable_paths()->MutableAccessor(index)->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_set_pointer:google.protobuf.FieldMask.paths)
 }
 inline void FieldMask::set_paths(int index, absl::string_view value) {
-  _internal_mutable_paths()->Mutable(index)->assign(value.data(),
-                                                     value.size());
+  _internal_mutable_paths()->MutableAccessor(index)->assign(
+      value.data(), value.size());
   // @@protoc_insertion_point(field_set_string_piece:google.protobuf.FieldMask.paths)
 }
 inline void FieldMask::add_paths(const std::string& value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_paths()->Add()->assign(value);
+  _internal_mutable_paths()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add:google.protobuf.FieldMask.paths)
 }
 inline void FieldMask::add_paths(std::string&& value) {
@@ -345,18 +346,18 @@ inline void FieldMask::add_paths(std::string&& value) {
 inline void FieldMask::add_paths(const char* value) {
   ABSL_DCHECK(value != nullptr);
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_paths()->Add()->assign(value);
+  _internal_mutable_paths()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add_char:google.protobuf.FieldMask.paths)
 }
 inline void FieldMask::add_paths(const char* value, std::size_t size) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_paths()->Add()->assign(
+  _internal_mutable_paths()->AddAccessor()->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_add_pointer:google.protobuf.FieldMask.paths)
 }
 inline void FieldMask::add_paths(absl::string_view value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_paths()->Add()->assign(value.data(), value.size());
+  _internal_mutable_paths()->AddAccessor()->assign(value.data(), value.size());
   // @@protoc_insertion_point(field_add_string_piece:google.protobuf.FieldMask.paths)
 }
 inline const ::google::protobuf::RepeatedPtrField<std::string>&
diff --git a/src/google/protobuf/generated_message_reflection.cc b/src/google/protobuf/generated_message_reflection.cc
index 452fd5240..ffb02e777 100644
--- a/src/google/protobuf/generated_message_reflection.cc
+++ b/src/google/protobuf/generated_message_reflection.cc
@@ -1916,9 +1916,13 @@ void Reflection::SetString(Message* message, const FieldDescriptor* field,
                            const absl::Cord& value) const {
   USAGE_MUTABLE_CHECK_ALL(SetString, SINGULAR, STRING);
   if (field->is_extension()) {
-    return absl::CopyCordToString(value,
-                                  MutableExtensionSet(message)->MutableString(
-                                      field->number(), field->type(), field));
+    auto accessor = MutableExtensionSet(message)->MutableAccessor(
+        field->number(), field->type(), field);
+    accessor.clear();
+    accessor.reserve(value.size());
+    for (auto chunk : value.Chunks()) {
+      accessor.append(chunk);
+    }
   } else {
     switch (internal::cpp::EffectiveStringCType(field)) {
       case FieldOptions::CORD:
@@ -2006,8 +2010,8 @@ void Reflection::SetRepeatedString(Message* message,
     switch (field->options().ctype()) {
       default:  // TODO:  Support other string reps.
       case FieldOptions::STRING:
-        MutableRepeatedField<std::string>(message, field, index)
-            ->assign(std::move(value));
+        MutableRaw<RepeatedPtrField<std::string>>(message, field)
+            ->MutableAccessor(index)->assign(std::move(value));
         break;
     }
   }
@@ -2024,7 +2028,8 @@ void Reflection::AddString(Message* message, const FieldDescriptor* field,
     switch (field->options().ctype()) {
       default:  // TODO:  Support other string reps.
       case FieldOptions::STRING:
-        AddField<std::string>(message, field)->assign(std::move(value));
+        MutableRaw<RepeatedPtrField<std::string>>(message, field)
+            ->Add(std::move(value));
         break;
     }
   }
diff --git a/src/google/protobuf/generated_message_tctable_gen.cc b/src/google/protobuf/generated_message_tctable_gen.cc
index 7c1736d63..d0ef5d1da 100644
--- a/src/google/protobuf/generated_message_tctable_gen.cc
+++ b/src/google/protobuf/generated_message_tctable_gen.cc
@@ -706,6 +706,9 @@ uint16_t MakeTypeCardForField(
           // A repeated string field uses RepeatedPtrField<std::string>
           // (unless it has a ctype option; see above).
           type_card |= fl::kRepSString;
+        } else if (options.is_string_inlined) {
+          // 按照is_string_inlined标记设置kRepIString类型标记
+          type_card |= fl::kRepIString;
         } else {
           // Otherwise, non-repeated string fields use ArenaStringPtr.
           type_card |= fl::kRepAString;
diff --git a/src/google/protobuf/generated_message_tctable_impl.h b/src/google/protobuf/generated_message_tctable_impl.h
index 42a56084b..621fa57b5 100644
--- a/src/google/protobuf/generated_message_tctable_impl.h
+++ b/src/google/protobuf/generated_message_tctable_impl.h
@@ -823,8 +823,10 @@ class PROTOBUF_EXPORT TcParser final {
   template <typename TagType, typename FieldType, Utf8Type utf8>
   static inline const char* RepeatedString(PROTOBUF_TC_PARAM_DECL);
 
+  // 整体代码只有此处依赖SerialArena的内部实现，比较trick先不支持这种优化
+  // 而且ArenaString实现变更后这种加速意义不大
   static inline const char* ParseRepeatedStringOnce(
-      const char* ptr, SerialArena* serial_arena, ParseContext* ctx,
+      const char* ptr, Arena* arena, ParseContext* ctx,
       RepeatedPtrField<std::string>& field);
 
   PROTOBUF_NOINLINE
diff --git a/src/google/protobuf/generated_message_tctable_lite.cc b/src/google/protobuf/generated_message_tctable_lite.cc
index 531d0556a..7d261248a 100644
--- a/src/google/protobuf/generated_message_tctable_lite.cc
+++ b/src/google/protobuf/generated_message_tctable_lite.cc
@@ -1402,23 +1402,46 @@ PROTOBUF_ALWAYS_INLINE inline const char* ReadStringIntoArena(
     MessageLite* /*msg*/, const char* ptr, ParseContext* ctx,
     uint32_t /*aux_idx*/, const TcParseTableBase* /*table*/,
     ArenaStringPtr& field, Arena* arena) {
-  return ctx->ReadArenaString(ptr, &field, arena);
+  // 统一适配Allocated/MutableArena/FixedSizeArena模式
+  return ctx->ReadArenaString(ptr, field.MutableAccessor(arena));
 }
 
+// ArenaStringPtr/InlinedStringField具有类似的API，模板支持
+template <typename T>
 PROTOBUF_NOINLINE
 const char* ReadStringNoArena(MessageLite* /*msg*/, const char* ptr,
                               ParseContext* ctx, uint32_t /*aux_idx*/,
                               const TcParseTableBase* /*table*/,
-                              ArenaStringPtr& field) {
+                              T& field) {
   int size = ReadSize(&ptr);
   if (!ptr) return nullptr;
   return ctx->ReadString(ptr, size, field.MutableNoCopy(nullptr));
 }
 
-PROTOBUF_ALWAYS_INLINE inline bool IsValidUTF8(ArenaStringPtr& field) {
+// ArenaStringPtr/InlinedStringField具有类似的API，模板支持
+template <typename T>
+PROTOBUF_ALWAYS_INLINE inline bool IsValidUTF8(T& field) {
   return utf8_range::IsStructurallyValid(field.Get());
 }
 
+// InlinedStringField需要按照协议提取donated标记之后进行访问
+PROTOBUF_ALWAYS_INLINE inline const char* ReadStringIntoArena(
+    MessageLite* msg, const char* ptr, ParseContext* ctx,
+    uint32_t aux_idx, const TcParseTableBase* table,
+    InlinedStringField& field, Arena* arena) {
+  // 包含InlinedStringField时aux[0]固定存储了donated bit图
+  // _inlined_string_donated_成员的偏移量
+  auto donated_slot_offset = table->field_aux(0u)->offset;
+  // 根据序号计算bit偏移量
+  auto donated_slot_index = aux_idx / 32;
+  donated_slot_offset += donated_slot_index << 4;
+  auto donated_slot_mask = 1 << (aux_idx % 32);
+  // 取出donated bit，相当于如下方式
+  // msg->_inlined_string_donated_[donated_slot_offset] & donated_slot_mask
+  auto donated = TcParser::RefAt<uint32_t>(msg, donated_slot_offset) & donated_slot_mask;
+  // 实际开始读取数据
+  return ctx->ReadArenaString(ptr, field.MutableAccessor(arena, donated));
+}
 
 }  // namespace
 
@@ -1491,23 +1514,32 @@ PROTOBUF_NOINLINE const char* TcParser::FastUS2(PROTOBUF_TC_PARAM_DECL) {
 
 // Inlined string variants:
 
+// 增加和ArenaStringPtr一样的fast path支持
 const char* TcParser::FastBiS1(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint8_t, InlinedStringField, kNoUtf8>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastBiS2(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint16_t, InlinedStringField, kNoUtf8>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastSiS1(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint8_t, InlinedStringField,
+                                          kUtf8ValidateOnly>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastSiS2(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint16_t, InlinedStringField,
+                                          kUtf8ValidateOnly>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastUiS1(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint8_t, InlinedStringField, kUtf8>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 const char* TcParser::FastUiS2(PROTOBUF_TC_PARAM_DECL) {
-  PROTOBUF_MUSTTAIL return MiniParse(PROTOBUF_TC_PARAM_NO_DATA_PASS);
+  PROTOBUF_MUSTTAIL return SingularString<uint16_t, InlinedStringField, kUtf8>(
+      PROTOBUF_TC_PARAM_PASS);
 }
 
 // Corded string variants:
@@ -1547,8 +1579,9 @@ PROTOBUF_ALWAYS_INLINE const char* TcParser::RepeatedString(
 #endif
         return true;
       default:
+        // 切换Get接口避免进行MutableArena转换
         if (PROTOBUF_PREDICT_TRUE(
-                utf8_range::IsStructurallyValid(field[field.size() - 1]))) {
+                utf8_range::IsStructurallyValid(field.Get(field.size() - 1)))) {
           return true;
         }
         ReportFastUtf8Error(FastDecodeTag(expected_tag), table);
@@ -1558,13 +1591,13 @@ PROTOBUF_ALWAYS_INLINE const char* TcParser::RepeatedString(
   };
 
   auto* arena = field.GetArena();
-  SerialArena* serial_arena;
+  // 整体代码只有此处依赖SerialArena的内部实现，比较trick先不支持这种优化
+  // 而且ArenaString实现变更后这种加速意义不大
   if (PROTOBUF_PREDICT_TRUE(arena != nullptr &&
-                            arena->impl_.GetSerialArenaFast(&serial_arena) &&
                             field.PrepareForParse())) {
     do {
       ptr += sizeof(TagType);
-      ptr = ParseRepeatedStringOnce(ptr, serial_arena, ctx, field);
+      ptr = ParseRepeatedStringOnce(ptr, arena, ctx, field);
 
       if (PROTOBUF_PREDICT_FALSE(ptr == nullptr || !validate_last_string())) {
         PROTOBUF_MUSTTAIL return Error(PROTOBUF_TC_PARAM_NO_DATA_PASS);
@@ -1574,8 +1607,9 @@ PROTOBUF_ALWAYS_INLINE const char* TcParser::RepeatedString(
   } else {
     do {
       ptr += sizeof(TagType);
-      std::string* str = field.Add();
-      ptr = InlineGreedyStringParser(str, ptr, ctx);
+      // 统一适配Allocated/MutableArena/FixedSizeArena模式
+      auto str = field.AddAccessor();
+      ptr = ctx->ReadArenaString(ptr, str);
       if (PROTOBUF_PREDICT_FALSE(ptr == nullptr || !validate_last_string())) {
         PROTOBUF_MUSTTAIL return Error(PROTOBUF_TC_PARAM_NO_DATA_PASS);
       }
@@ -2186,7 +2220,8 @@ PROTOBUF_NOINLINE const char* TcParser::MpString(PROTOBUF_TC_PARAM_DECL) {
       if (need_init) field.InitDefault();
       Arena* arena = msg->GetArena();
       if (arena) {
-        ptr = ctx->ReadArenaString(ptr, &field, arena);
+        // 统一适配Allocated/MutableArena/FixedSizeArena模式
+        ptr = ctx->ReadArenaString(ptr, field.MutableAccessor(arena));
       } else {
         std::string* str = field.MutableNoCopy(nullptr);
         ptr = InlineGreedyStringParser(str, ptr, ctx);
@@ -2196,6 +2231,24 @@ PROTOBUF_NOINLINE const char* TcParser::MpString(PROTOBUF_TC_PARAM_DECL) {
       break;
     }
 
+    // 增加InlinedStringField的支持分支
+    // 内容除了类型之外和kRepAString分支完全一致
+    case field_layout::kRepIString: {
+      auto& field = RefAt<InlinedStringField>(base, entry.offset);
+      Arena* arena = msg->GetArena();
+      if (arena) {
+        // 每个field通过aux_idx存储了自身使用的donated bit序号
+        auto aux_idx = table->field_aux(entry.aux_idx)->offset;
+        ptr = ReadStringIntoArena(
+            msg, ptr, ctx, aux_idx, table, field, arena);
+      } else {
+        std::string* str = field.MutableNoCopy(nullptr);
+        ptr = InlineGreedyStringParser(str, ptr, ctx);
+      }
+      if (!ptr) break;
+      is_valid = MpVerifyUtf8(field.Get(), table, entry, xform_val);
+      break;
+    }
 
     case field_layout::kRepCord: {
       absl::Cord* field;
@@ -2226,13 +2279,16 @@ PROTOBUF_NOINLINE const char* TcParser::MpString(PROTOBUF_TC_PARAM_DECL) {
 }
 
 PROTOBUF_ALWAYS_INLINE const char* TcParser::ParseRepeatedStringOnce(
-    const char* ptr, SerialArena* serial_arena, ParseContext* ctx,
+    const char* ptr, Arena* arena, ParseContext* ctx,
     RepeatedPtrField<std::string>& field) {
+  using TypeHandler = typename RepeatedPtrField<std::string>::TypeHandler;
   int size = ReadSize(&ptr);
   if (PROTOBUF_PREDICT_FALSE(!ptr)) return {};
-  auto* str = new (serial_arena->AllocateFromStringBlock()) std::string();
-  field.AddAllocatedForParse(str);
-  ptr = ctx->ReadString(ptr, size, str);
+  // 整体代码只有此处依赖SerialArena的内部实现，比较trick先不支持这种优化
+  // 而且ArenaString实现变更后这种加速意义不大
+  auto str = ArenaStringAccessor::create(arena);
+  field.AddAllocatedForParse(StringHandlerType::ToTagged(str.underlying()));
+  ptr = ctx->ReadArenaString(ptr, size, str);
   if (PROTOBUF_PREDICT_FALSE(!ptr)) return {};
   PROTOBUF_ASSUME(ptr != nullptr);
   return ptr;
@@ -2261,16 +2317,17 @@ PROTOBUF_NOINLINE const char* TcParser::MpRepeatedString(
       uint32_t next_tag;
 
       auto* arena = field.GetArena();
-      SerialArena* serial_arena;
+      // 整体代码只有此处依赖SerialArena的内部实现，比较trick先不支持这种优化
+      // 而且ArenaString实现变更后这种加速意义不大
       if (PROTOBUF_PREDICT_TRUE(
               arena != nullptr &&
-              arena->impl_.GetSerialArenaFast(&serial_arena) &&
               field.PrepareForParse())) {
         do {
           ptr = ptr2;
-          ptr = ParseRepeatedStringOnce(ptr, serial_arena, ctx, field);
+          ptr = ParseRepeatedStringOnce(ptr, arena, ctx, field);
+          // 切换Get接口避免进行MutableArena转换
           if (PROTOBUF_PREDICT_FALSE(ptr == nullptr ||
-                                     !MpVerifyUtf8(field[field.size() - 1],
+                                     !MpVerifyUtf8(field.Get(field.size() - 1),
                                                    table, entry, xform_val))) {
             PROTOBUF_MUSTTAIL return Error(PROTOBUF_TC_PARAM_NO_DATA_PASS);
           }
@@ -2280,8 +2337,9 @@ PROTOBUF_NOINLINE const char* TcParser::MpRepeatedString(
       } else {
         do {
           ptr = ptr2;
-          std::string* str = field.Add();
-          ptr = InlineGreedyStringParser(str, ptr, ctx);
+          // 统一适配Allocated/MutableArena/FixedSizeArena模式
+          auto str = field.AddAccessor();
+          ptr = ctx->ReadArenaString(ptr, str);
           if (PROTOBUF_PREDICT_FALSE(
                   ptr == nullptr ||
                   !MpVerifyUtf8(*str, table, entry, xform_val))) {
diff --git a/src/google/protobuf/inlined_string_field.cc b/src/google/protobuf/inlined_string_field.cc
index ec0a9de10..4f7a06ee0 100644
--- a/src/google/protobuf/inlined_string_field.cc
+++ b/src/google/protobuf/inlined_string_field.cc
@@ -70,6 +70,9 @@ std::string* InlinedStringField::MutableSlow(::google::protobuf::Arena* arena,
                                              uint32_t mask, MessageLite* msg) {
   (void)mask;
   (void)msg;
+  new (get_mutable()) ::std::string(*get_const());
+  *donating_states &= mask;
+  arena->OwnDestructor(get_mutable());
   return UnsafeMutablePointer();
 }
 
@@ -79,6 +82,13 @@ void InlinedStringField::SetAllocated(const std::string* default_value,
                                       uint32_t mask, MessageLite* msg) {
   (void)mask;
   (void)msg;
+  if (arena != nullptr && donated) {
+    new (get_mutable()) ::std::string(::std::move(*value));
+    *donating_states &= mask;
+    arena->OwnDestructor(get_mutable());
+    delete value;
+    return;
+  }
   SetAllocatedNoArena(default_value, value);
 }
 
@@ -88,6 +98,12 @@ void InlinedStringField::Set(std::string&& value, Arena* arena, bool donated,
   (void)donating_states;
   (void)mask;
   (void)msg;
+  if (arena != nullptr && donated) {
+    new (get_mutable()) ::std::string(::std::move(value));
+    *donating_states &= mask;
+    arena->OwnDestructor(get_mutable());
+    return;
+  }
   SetNoArena(std::move(value));
 }
 
@@ -102,14 +118,14 @@ std::string* InlinedStringField::Release(Arena* arena, bool donated) {
   std::string* released = (arena != nullptr && donated)
                               ? new std::string(*get_mutable())
                               : new std::string(std::move(*get_mutable()));
-  get_mutable()->clear();
+  ClearToEmpty();
   return released;
 }
 
 void InlinedStringField::ClearToDefault(const LazyString& default_value,
                                         Arena* arena, bool donated) {
   (void)arena;
-  get_mutable()->assign(default_value.get());
+  MutableAccessor(arena, donated)->assign(default_value.get());
 }
 
 
diff --git a/src/google/protobuf/inlined_string_field.h b/src/google/protobuf/inlined_string_field.h
index 5d18cc956..d3e0cccaa 100644
--- a/src/google/protobuf/inlined_string_field.h
+++ b/src/google/protobuf/inlined_string_field.h
@@ -112,6 +112,8 @@ class PROTOBUF_EXPORT InlinedStringField {
   // This method never changes the `donating_states`.
   void Set(absl::string_view value, Arena* arena, bool donated,
            uint32_t* donating_states, uint32_t mask, MessageLite* msg);
+  void Set(const std::string& value, Arena* arena, bool donated,
+           uint32_t* donating_states, uint32_t mask, MessageLite* msg);
 
   // Rvalue Set. If this field is donated, this method will undonate this field
   // by mutating the `donating_states` according to `mask`.
@@ -131,6 +133,8 @@ class PROTOBUF_EXPORT InlinedStringField {
 
   void SetBytes(absl::string_view value, Arena* arena, bool donated,
                 uint32_t* donating_states, uint32_t mask, MessageLite* msg);
+  void SetBytes(const std::string& value, Arena* arena, bool donated,
+                uint32_t* donating_states, uint32_t mask, MessageLite* msg);
 
   void SetBytes(std::string&& value, Arena* arena, bool donated,
                 uint32_t* donating_states, uint32_t mask, MessageLite* msg);
@@ -163,6 +167,10 @@ class PROTOBUF_EXPORT InlinedStringField {
   std::string* Mutable(const LazyString& default_value, Arena* arena,
                        bool donated, uint32_t* donating_states, uint32_t mask,
                        MessageLite* msg);
+  MaybeArenaStringAccessor MutableAccessor(Arena* arena, bool donated,
+                                           uint32_t* donating_states,
+                                           uint32_t mask, MessageLite* msg);
+  MaybeArenaStringAccessor MutableAccessor(Arena* arena, bool donated);
 
   // Mutable(nullptr_t) is an overload to explicitly support Mutable(nullptr)
   // calls used by the internal parser logic. This provides API equivalence with
@@ -320,7 +328,7 @@ class PROTOBUF_EXPORT InlinedStringField {
   // always be the empty std::string.
   PROTOBUF_NDEBUG_INLINE void ClearToEmpty() { ClearNonDefaultToEmpty(); }
   PROTOBUF_NDEBUG_INLINE void ClearNonDefaultToEmpty() {
-    get_mutable()->clear();
+    MaybeArenaStringAccessor::clear(get_mutable());
   }
 
   // Clears content, but keeps allocated std::string if arena != nullptr, to
@@ -377,8 +385,8 @@ inline InlinedStringField::InlinedStringField(Arena* /*arena*/) { Init(); }
 
 inline InlinedStringField::InlinedStringField(Arena* arena,
                                               const InlinedStringField& rhs) {
-  const std::string& src = *rhs.get_const();
-  new (value_) std::string(src);
+  Init();
+  MaybeArenaStringAccessor(arena, get_mutable()) = *rhs.get_const();
 }
 
 inline const std::string& InlinedStringField::GetNoArena() const {
@@ -428,7 +436,7 @@ inline PROTOBUF_NDEBUG_INLINE void InlinedStringField::InternalSwap(
   (void)rhs_arena_dtor_registered;
   (void)lhs_msg;
   (void)rhs_msg;
-  lhs->get_mutable()->swap(*rhs->get_mutable());
+  MaybeArenaStringAccessor::swap(lhs->get_mutable(), rhs->get_mutable());
 #endif
 }
 
@@ -437,7 +445,13 @@ inline void InlinedStringField::Set(absl::string_view value, Arena* arena,
                                     uint32_t /*mask*/, MessageLite* /*msg*/) {
   (void)arena;
   (void)donated;
-  SetNoArena(value);
+  MutableAccessor(arena, donated) = value;
+}
+
+inline void InlinedStringField::Set(const std::string& value, Arena* arena,
+                                    bool donated, uint32_t* /*donating_states*/,
+                                    uint32_t /*mask*/, MessageLite* /*msg*/) {
+  MutableAccessor(arena, donated) = value;
 }
 
 inline void InlinedStringField::Set(const char* str, ::google::protobuf::Arena* arena,
@@ -460,6 +474,13 @@ inline void InlinedStringField::SetBytes(absl::string_view value, Arena* arena,
   Set(value, arena, donated, donating_states, mask, msg);
 }
 
+inline void InlinedStringField::SetBytes(const std::string& value, Arena* arena,
+                                         bool donated,
+                                         uint32_t* donating_states,
+                                         uint32_t mask, MessageLite* msg) {
+  Set(value, arena, donated, donating_states, mask, msg);
+}
+
 inline void InlinedStringField::SetBytes(std::string&& value, Arena* arena,
                                          bool donated,
                                          uint32_t* donating_states,
@@ -498,6 +519,17 @@ inline void InlinedStringField::SetBytes(
   Set(const_string_ref.get(), arena, donated, donating_states, mask, msg);
 }
 
+inline MaybeArenaStringAccessor InlinedStringField::MutableAccessor(
+    Arena* arena, bool donated, uint32_t* /*donating_states*/,
+    uint32_t /*mask*/, MessageLite* /*msg*/) {
+  return MutableAccessor(arena, donated);
+}
+
+inline MaybeArenaStringAccessor InlinedStringField::MutableAccessor(
+    Arena* arena, bool donated) {
+  return MaybeArenaStringAccessor(donated ? arena : nullptr, get_mutable());
+}
+
 inline std::string* InlinedStringField::UnsafeMutablePointer() {
   return get_mutable();
 }
diff --git a/src/google/protobuf/message_lite.cc b/src/google/protobuf/message_lite.cc
index 450522276..24dd52528 100644
--- a/src/google/protobuf/message_lite.cc
+++ b/src/google/protobuf/message_lite.cc
@@ -483,6 +483,12 @@ bool MessageLite::AppendToString(std::string* output) const {
   return AppendPartialToString(output);
 }
 
+bool MessageLite::AppendToString(MaybeArenaStringAccessor output) const {
+  ABSL_DCHECK(IsInitialized())
+      << InitializationErrorMessage("serialize", *this);
+  return AppendPartialToString(output);
+}
+
 bool MessageLite::AppendPartialToString(std::string* output) const {
   size_t old_size = output->size();
   size_t byte_size = ByteSizeLong();
@@ -500,11 +506,32 @@ bool MessageLite::AppendPartialToString(std::string* output) const {
   return true;
 }
 
+bool MessageLite::AppendPartialToString(MaybeArenaStringAccessor output) const {
+  size_t old_size = output->size();
+  size_t byte_size = ByteSizeLong();
+  if (byte_size > INT_MAX) {
+    ABSL_LOG(ERROR) << GetTypeName()
+                    << " exceeded maximum protobuf size of 2GB: " << byte_size;
+    return false;
+  }
+
+  output.__resize_default_init(old_size + byte_size);
+  uint8_t* start =
+      reinterpret_cast<uint8_t*>(&output[0] + old_size);
+  SerializeToArrayImpl(*this, start, byte_size);
+  return true;
+}
+
 bool MessageLite::SerializeToString(std::string* output) const {
   output->clear();
   return AppendToString(output);
 }
 
+bool MessageLite::SerializeToString(MaybeArenaStringAccessor output) const {
+  output->clear();
+  return AppendToString(output);
+}
+
 bool MessageLite::SerializePartialToString(std::string* output) const {
   output->clear();
   return AppendPartialToString(output);
@@ -630,11 +657,11 @@ void GenericTypeHandler<MessageLite>::Merge(const MessageLite& from,
                                             MessageLite* to) {
   to->CheckTypeAndMergeFrom(from);
 }
-template <>
-void GenericTypeHandler<std::string>::Merge(const std::string& from,
-                                            std::string* to) {
-  *to = from;
-}
+//template <>
+//void GenericTypeHandler<std::string>::Merge(const std::string& from,
+//                                            std::string* to) {
+//  *to = from;
+//}
 
 // Non-inline variants of std::string specializations for
 // various InternalMetadata routines.
diff --git a/src/google/protobuf/message_lite.h b/src/google/protobuf/message_lite.h
index de8bd19aa..c3e3857a7 100644
--- a/src/google/protobuf/message_lite.h
+++ b/src/google/protobuf/message_lite.h
@@ -27,6 +27,7 @@
 #include "absl/strings/cord.h"
 #include "absl/strings/string_view.h"
 #include "google/protobuf/arena.h"
+#include "google/protobuf/arenastring_impl.h"
 #include "google/protobuf/explicitly_constructed.h"
 #include "google/protobuf/internal_visibility.h"
 #include "google/protobuf/io/coded_stream.h"
@@ -377,6 +378,7 @@ class PROTOBUF_EXPORT MessageLite {
   // Serialize the message and store it in the given string.  All required
   // fields must be set.
   bool SerializeToString(std::string* output) const;
+  bool SerializeToString(MaybeArenaStringAccessor output) const;
   // Like SerializeToString(), but allows missing required fields.
   bool SerializePartialToString(std::string* output) const;
   // Serialize the message and store it in the given byte array.  All required
@@ -409,8 +411,10 @@ class PROTOBUF_EXPORT MessageLite {
   // Like SerializeToString(), but appends to the data to the string's
   // existing contents.  All required fields must be set.
   bool AppendToString(std::string* output) const;
+  bool AppendToString(MaybeArenaStringAccessor output) const;
   // Like AppendToString(), but allows missing required fields.
   bool AppendPartialToString(std::string* output) const;
+  bool AppendPartialToString(MaybeArenaStringAccessor output) const;
 
   // Reads a protocol buffer from a Cord and merges it into this message.
   bool MergeFromCord(const absl::Cord& cord);
diff --git a/src/google/protobuf/parse_context.h b/src/google/protobuf/parse_context.h
index df12ee1ab..53030c048 100644
--- a/src/google/protobuf/parse_context.h
+++ b/src/google/protobuf/parse_context.h
@@ -199,9 +199,12 @@ class PROTOBUF_EXPORT EpsCopyInputStream {
     return AppendStringFallback(ptr, size, s);
   }
   // Implemented in arenastring.cc
+  PROTOBUF_NODISCARD const char* ReadArenaString(const char* ptr, int size,
+                                                 ArenaStringAccessor s);
   PROTOBUF_NODISCARD const char* ReadArenaString(const char* ptr,
-                                                 ArenaStringPtr* s,
-                                                 Arena* arena);
+                                                 ArenaStringAccessor s);
+  PROTOBUF_NODISCARD const char* ReadArenaString(const char* ptr,
+                                                 MaybeArenaStringAccessor s);
 
   PROTOBUF_NODISCARD const char* ReadCord(const char* ptr, int size,
                                           ::absl::Cord* cord) {
diff --git a/src/google/protobuf/reflection_internal.h b/src/google/protobuf/reflection_internal.h
index ea4bac293..6f8906567 100644
--- a/src/google/protobuf/reflection_internal.h
+++ b/src/google/protobuf/reflection_internal.h
@@ -136,13 +136,39 @@ class RepeatedPtrFieldWrapper : public RandomAccessRepeatedFieldAccessor {
     MutableRepeatedField(data)->Clear();
   }
   void Set(Field* data, int index, const Value* value) const override {
+    DoSet(data, index, value);
+  }
+  template <typename U = T,
+            typename std::enable_if<
+                !std::is_same<U, std::string>::value, int>::type = 0>
+  void DoSet(Field* data, int index, const Value* value) const {
     ConvertToT(value, MutableRepeatedField(data)->Mutable(index));
   }
+  template <typename U = T,
+            typename std::enable_if<
+                std::is_same<U, std::string>::value, int>::type = 0>
+  void DoSet(Field* data, int index, const Value* value) const {
+    MutableRepeatedField(data)->MutableAccessor(index)
+        = *static_cast<const std::string*>(value);
+  }
   void Add(Field* data, const Value* value) const override {
+    DoAdd(data, value);
+  }
+  template <typename U = T,
+            typename std::enable_if<
+                !std::is_same<U, std::string>::value, int>::type = 0>
+  void DoAdd(Field* data, const Value* value) const {
     T* allocated = New(value);
     ConvertToT(value, allocated);
     MutableRepeatedField(data)->AddAllocated(allocated);
   }
+  template <typename U = T,
+            typename std::enable_if<
+                std::is_same<U, std::string>::value, int>::type = 0>
+  void DoAdd(Field* data, const Value* value) const {
+    MutableRepeatedField(data)->AddAccessor()
+        = *static_cast<const std::string*>(value);
+  }
   void RemoveLast(Field* data) const override {
     MutableRepeatedField(data)->RemoveLast();
   }
diff --git a/src/google/protobuf/repeated_field_unittest.cc b/src/google/protobuf/repeated_field_unittest.cc
index f5529ed78..982258caf 100644
--- a/src/google/protobuf/repeated_field_unittest.cc
+++ b/src/google/protobuf/repeated_field_unittest.cc
@@ -1529,7 +1529,7 @@ TEST(RepeatedPtrField, SwapLargeLarge) {
 }
 
 static int ReservedSpace(RepeatedPtrField<std::string>* field) {
-  const std::string* const* ptr = field->data();
+  auto ptr = field->data();
   do {
     field->Add();
   } while (field->data() == ptr);
@@ -1558,7 +1558,7 @@ TEST(RepeatedPtrField, ReserveLessThanDouble) {
 TEST(RepeatedPtrField, ReserveLessThanExisting) {
   RepeatedPtrField<std::string> field;
   field.Reserve(20);
-  const std::string* const* previous_ptr = field.data();
+  auto previous_ptr = field.data();
   field.Reserve(10);
 
   EXPECT_EQ(previous_ptr, field.data());
@@ -1570,11 +1570,11 @@ TEST(RepeatedPtrField, ReserveDoesntLoseAllocated) {
   // failed to copy pointers to allocated-but-cleared objects, possibly
   // leading to segfaults.
   RepeatedPtrField<std::string> field;
-  std::string* first = field.Add();
+  std::string* first = field.AddString();
   field.RemoveLast();
 
   field.Reserve(20);
-  EXPECT_EQ(first, field.Add());
+  EXPECT_EQ(first, field.AddString());
 }
 
 // Clearing elements is tricky with RepeatedPtrFields since the memory for
@@ -1583,7 +1583,7 @@ TEST(RepeatedPtrField, ClearedElements) {
   PROTOBUF_IGNORE_DEPRECATION_START
   RepeatedPtrField<std::string> field;
 
-  std::string* original = field.Add();
+  std::string* original = field.AddString();
   *original = "foo";
 
   EXPECT_EQ(field.ClearedCount(), 0);
@@ -1592,31 +1592,31 @@ TEST(RepeatedPtrField, ClearedElements) {
   EXPECT_TRUE(original->empty());
   EXPECT_EQ(field.ClearedCount(), 1);
 
-  EXPECT_EQ(field.Add(),
+  EXPECT_EQ(field.AddString(),
             original);  // Should return same string for reuse.
-  EXPECT_EQ(field.UnsafeArenaReleaseLast(), original);  // We take ownership.
+  EXPECT_EQ(field.UnsafeArenaReleaseLast()->ToStringPtr(),  original);  // We take ownership.
   EXPECT_EQ(field.ClearedCount(), 0);
 
-  EXPECT_NE(field.Add(), original);  // Should NOT return the same string.
+  EXPECT_NE(field.AddString(), original);  // Should NOT return the same string.
   EXPECT_EQ(field.ClearedCount(), 0);
 
-  field.UnsafeArenaAddAllocated(original);  // Give ownership back.
+  field.UnsafeArenaAddAllocated(internal::StringHandlerType::ToUnTagged(original));  // Give ownership back.
   EXPECT_EQ(field.ClearedCount(), 0);
-  EXPECT_EQ(field.Mutable(1), original);
+  EXPECT_EQ(field.MutableString(1), original);
 
   field.Clear();
   EXPECT_EQ(field.ClearedCount(), 2);
 #ifndef PROTOBUF_FUTURE_REMOVE_CLEARED_API
   EXPECT_EQ(field.ReleaseCleared(), original);  // Take ownership again.
   EXPECT_EQ(field.ClearedCount(), 1);
-  EXPECT_NE(field.Add(), original);
+  EXPECT_NE(field.AddString(), original);
   EXPECT_EQ(field.ClearedCount(), 0);
-  EXPECT_NE(field.Add(), original);
+  EXPECT_NE(field.AddString(), original);
   EXPECT_EQ(field.ClearedCount(), 0);
 
   field.AddCleared(original);  // Give ownership back, but as a cleared object.
   EXPECT_EQ(field.ClearedCount(), 1);
-  EXPECT_EQ(field.Add(), original);
+  EXPECT_EQ(field.AddString(), original);
   EXPECT_EQ(field.ClearedCount(), 0);
 #endif  // !PROTOBUF_FUTURE_REMOVE_CLEARED_API
   PROTOBUF_IGNORE_DEPRECATION_STOP
@@ -1839,13 +1839,17 @@ TEST(RepeatedPtrField, SmallOptimization) {
   // We use UnsafeArenaAddAllocated just to grow the array without creating
   // objects or causing extra cleanup costs in the arena to make the
   // measurements simpler.
-  array->UnsafeArenaAddAllocated(&str);
+  array->UnsafeArenaAddAllocated(internal::StringHandlerType::ToUnTagged(&str));
   // No backing array, just the string.
   EXPECT_EQ(array->SpaceUsedExcludingSelf(), sizeof(str));
   // We have not used any arena space.
   EXPECT_EQ(usage_before, arena.SpaceUsed());
   // Verify the string is where we think it is.
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  EXPECT_EQ(array->begin()->underlying(), &str);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   EXPECT_EQ(&*array->begin(), &str);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   EXPECT_EQ(array->pointer_begin()[0], &str);
   // The T** in pointer_begin points into the sso in the object.
   EXPECT_TRUE(std::less_equal<void*>{}(array, &*array->pointer_begin()));
@@ -1853,7 +1857,7 @@ TEST(RepeatedPtrField, SmallOptimization) {
 
   // Adding a second object stops sso.
   std::string str2;
-  array->UnsafeArenaAddAllocated(&str2);
+  array->UnsafeArenaAddAllocated(internal::StringHandlerType::ToUnTagged(&str2));
   EXPECT_EQ(array->Capacity(), 3);
   // Backing array and the strings.
   EXPECT_EQ(array->SpaceUsedExcludingSelf(),
@@ -1899,7 +1903,7 @@ TEST(RepeatedPtrField, MoveConstruct) {
     RepeatedPtrField<std::string> source;
     *source.Add() = "1";
     *source.Add() = "2";
-    const std::string* const* data = source.data();
+    auto data = source.data();
     RepeatedPtrField<std::string> destination = std::move(source);
     EXPECT_EQ(data, destination.data());
     EXPECT_THAT(destination, ElementsAre("1", "2"));
@@ -1929,7 +1933,7 @@ TEST(RepeatedPtrField, MoveAssign) {
     *source.Add() = "2";
     RepeatedPtrField<std::string> destination;
     *destination.Add() = "3";
-    const std::string* const* source_data = source.data();
+    auto source_data = source.data();
     destination = std::move(source);
     EXPECT_EQ(source_data, destination.data());
     EXPECT_THAT(destination, ElementsAre("1", "2"));
@@ -1944,7 +1948,7 @@ TEST(RepeatedPtrField, MoveAssign) {
     RepeatedPtrField<std::string>* destination =
         Arena::CreateMessage<RepeatedPtrField<std::string>>(&arena);
     *destination->Add() = "3";
-    const std::string* const* source_data = source->data();
+    auto source_data = source->data();
     *destination = std::move(*source);
     EXPECT_EQ(source_data, destination->data());
     EXPECT_THAT(*destination, ElementsAre("1", "2"));
@@ -2000,7 +2004,7 @@ TEST(RepeatedPtrField, MoveAssign) {
     RepeatedPtrField<std::string>& alias = field;
     *field.Add() = "1";
     *field.Add() = "2";
-    const std::string* const* data = field.data();
+    auto data = field.data();
     field = std::move(alias);
     EXPECT_EQ(data, field.data());
     EXPECT_THAT(field, ElementsAre("1", "2"));
@@ -2011,7 +2015,7 @@ TEST(RepeatedPtrField, MoveAssign) {
         Arena::CreateMessage<RepeatedPtrField<std::string>>(&arena);
     *field->Add() = "1";
     *field->Add() = "2";
-    const std::string* const* data = field->data();
+    auto data = field->data();
     *field = std::move(*field);
     EXPECT_EQ(data, field->data());
     EXPECT_THAT(*field, ElementsAre("1", "2"));
@@ -2024,8 +2028,8 @@ TEST(RepeatedPtrField, MutableDataIsMutable) {
   EXPECT_EQ("1", field.Get(0));
   // The fact that this line compiles would be enough, but we'll check the
   // value anyway.
-  std::string** data = field.mutable_data();
-  **data = "2";
+  auto data = field.mutable_data();
+  *(*data)->UnTaggedToStringPtr() = "2";
   EXPECT_EQ("2", field.Get(0));
 }
 
@@ -2034,9 +2038,13 @@ TEST(RepeatedPtrField, SubscriptOperators) {
   *field.Add() = "1";
   EXPECT_EQ("1", field.Get(0));
   EXPECT_EQ("1", field[0]);
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  EXPECT_EQ(field.MutableString(0), field[0]->underlying());
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   EXPECT_EQ(field.Mutable(0), &field[0]);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
   const RepeatedPtrField<std::string>& const_field = field;
-  EXPECT_EQ(*field.data(), &const_field[0]);
+  EXPECT_EQ((*field.data())->ToStringPtr(), &const_field[0]);
 }
 
 TEST(RepeatedPtrField, ExtractSubrange) {
@@ -2077,9 +2085,9 @@ TEST(RepeatedPtrField, ExtractSubrange) {
 
           // Does the resulting array contain the right values?
           for (int i = 0; i < start; ++i)
-            EXPECT_EQ(field.Mutable(i), subject[i]);
+            EXPECT_EQ(field.MutableString(i), subject[i]);
           for (int i = start; i < field.size(); ++i)
-            EXPECT_EQ(field.Mutable(i), subject[i + num]);
+            EXPECT_EQ(field.MutableString(i), subject[i + num]);
 
           // Reinstate the cleared elements.
           EXPECT_EQ(field.ClearedCount(), extra);
@@ -2091,7 +2099,7 @@ TEST(RepeatedPtrField, ExtractSubrange) {
           for (int i = sz; i < sz + extra; ++i) {
             int count = 0;
             for (int j = sz; j < sz + extra; ++j) {
-              if (field.Mutable(j - num) == subject[i]) count += 1;
+              if (field.MutableString(j - num) == subject[i]) count += 1;
             }
             EXPECT_EQ(count, 1);
           }
@@ -2704,8 +2712,8 @@ TEST_F(RepeatedFieldInsertionIteratorsTest,
     *new_data = absl::StrCat("name-", i);
     data.push_back(new_data);
 
-    new_data = goldenproto.add_repeated_string();
-    *new_data = absl::StrCat("name-", i);
+    auto new_data2 = goldenproto.add_repeated_string();
+    *new_data2 = absl::StrCat("name-", i);
   }
   TestAllTypes testproto;
   std::copy(data.begin(), data.end(),
@@ -2733,13 +2741,13 @@ TEST_F(RepeatedFieldInsertionIteratorsTest,
 
 TEST_F(RepeatedFieldInsertionIteratorsTest,
        UnsafeArenaAllocatedRepeatedPtrFieldWithString) {
-  std::vector<std::string*> data;
+  std::vector<internal::StringHandlerType*> data;
   Arena arena;
   auto* goldenproto = Arena::CreateMessage<TestAllTypes>(&arena);
   for (int i = 0; i < 10; ++i) {
-    auto* new_data = goldenproto->add_repeated_string();
+    auto new_data = goldenproto->add_repeated_string();
     *new_data = absl::StrCat("name-", i);
-    data.push_back(new_data);
+    data.push_back(internal::StringHandlerType::ToUnTagged(new_data));
   }
   auto* testproto = Arena::CreateMessage<TestAllTypes>(&arena);
   std::copy(data.begin(), data.end(),
diff --git a/src/google/protobuf/repeated_ptr_field.cc b/src/google/protobuf/repeated_ptr_field.cc
index 19b4ca59c..38c93d7b2 100644
--- a/src/google/protobuf/repeated_ptr_field.cc
+++ b/src/google/protobuf/repeated_ptr_field.cc
@@ -184,24 +184,39 @@ memswap<ArenaOffsetHelper<RepeatedPtrFieldBase>::value>(
     char* PROTOBUF_RESTRICT, char* PROTOBUF_RESTRICT);
 
 template <>
-void RepeatedPtrFieldBase::MergeFrom<std::string>(
+void RepeatedPtrFieldBase::MergeFrom<GenericTypeHandler<std::string>::Type>(
     const RepeatedPtrFieldBase& from) {
+  using TypeHandler = GenericTypeHandler<std::string>;
   ABSL_DCHECK_NE(&from, this);
   int new_size = current_size_ + from.current_size_;
-  auto dst = reinterpret_cast<std::string**>(InternalReserve(new_size));
-  auto src = reinterpret_cast<std::string* const*>(from.elements());
+  auto dst = reinterpret_cast<TypeHandler::Type**>(InternalReserve(new_size));
+  auto src = reinterpret_cast<TypeHandler::Type* const*>(from.elements());
   auto end = src + from.current_size_;
   auto end_assign = src + std::min(ClearedCount(), from.current_size_);
-  for (; src < end_assign; ++dst, ++src) {
-    (*dst)->assign(**src);
-  }
+
   if (Arena* const arena = arena_) {
+    for (; src < end_assign; ++dst, ++src) {
+      if ((*dst)->IsTagged()) {
+        ArenaStringAccessor(arena, (*dst)->ToStringPtr())
+            .assign(*(*src)->ToStringPtr());
+      } else {
+        (*dst)->UnTaggedToStringPtr()
+            ->assign(*(*src)->ToStringPtr());
+      }
+    }
     for (; src < end; ++dst, ++src) {
-      *dst = Arena::Create<std::string>(arena, **src);
+      auto accessor = ArenaStringAccessor::create(
+          arena, *(*src)->ToStringPtr());
+      *dst = StringHandlerType::ToTagged(accessor.underlying());
     }
   } else {
+    for (; src < end_assign; ++dst, ++src) {
+      (*dst)->UnTaggedToStringPtr()
+          ->assign(*(*src)->ToStringPtr());
+    }
     for (; src < end; ++dst, ++src) {
-      *dst = new std::string(**src);
+      *dst = StringHandlerType::ToUnTagged(
+          new std::string(*(*src)->ToStringPtr()));
     }
   }
   ExchangeCurrentSize(new_size);
@@ -210,6 +225,17 @@ void RepeatedPtrFieldBase::MergeFrom<std::string>(
   }
 }
 
+template <>
+void RepeatedPtrFieldBase::AddAllocatedSlowWithCopy<GenericTypeHandler<std::string>>(
+      StringHandlerType* value,
+      Arena* value_arena, Arena* my_arena) {
+  using TypeHandler = GenericTypeHandler<std::string>;
+  if (my_arena != nullptr) {
+    my_arena->Own(value->UnTaggedToStringPtr());
+  }
+
+  UnsafeArenaAddAllocated<TypeHandler>(value);
+}
 
 int RepeatedPtrFieldBase::MergeIntoClearedMessages(
     const RepeatedPtrFieldBase& from) {
diff --git a/src/google/protobuf/repeated_ptr_field.h b/src/google/protobuf/repeated_ptr_field.h
index d38232462..9d5966593 100644
--- a/src/google/protobuf/repeated_ptr_field.h
+++ b/src/google/protobuf/repeated_ptr_field.h
@@ -34,6 +34,7 @@
 #include "absl/base/attributes.h"
 #include "absl/log/absl_check.h"
 #include "google/protobuf/arena.h"
+#include "google/protobuf/arenastring.h"
 #include "google/protobuf/internal_visibility.h"
 #include "google/protobuf/message_lite.h"
 #include "google/protobuf/port.h"
@@ -72,6 +73,36 @@ class RepeatedPtrOverPtrsIterator;
 
 namespace internal {
 
+// 使用string第二位表示donated状态的TaggedPtr
+struct StringHandlerType {
+  inline std::string* ToStringPtr() noexcept {
+    return reinterpret_cast<std::string*>(
+        reinterpret_cast<uintptr_t>(this) & ~2);
+  }
+  inline const std::string* ToStringPtr() const noexcept {
+    return reinterpret_cast<const std::string*>(
+        reinterpret_cast<uintptr_t>(this) & ~2);
+  }
+  inline std::string* UnTaggedToStringPtr() noexcept {
+    return reinterpret_cast<std::string*>(this);
+  }
+  inline const std::string* UnTaggedToStringPtr() const noexcept {
+    return reinterpret_cast<const std::string*>(this);
+  }
+  inline bool IsTagged() const noexcept {
+    return reinterpret_cast<uintptr_t>(this) & 2;
+  }
+  inline static StringHandlerType* ToTagged(
+      std::string* string) noexcept {
+    return reinterpret_cast<StringHandlerType*>(
+        reinterpret_cast<uintptr_t>(string) | 2);
+  }
+  inline static StringHandlerType* ToUnTagged(
+      std::string* string) noexcept {
+    return reinterpret_cast<StringHandlerType*>(string);
+  }
+};
+
 template <typename Element>
 inline void* NewT(Arena* a) {
   return GenericTypeHandler<Element>::New(a);
@@ -122,8 +153,9 @@ struct TypeImplementsMergeBehavior
     : TypeImplementsMergeBehaviorProbeForMergeFrom<T> {};
 
 
+// 由于引入了TaggedPtr，模板特化要做对应调整
 template <>
-struct TypeImplementsMergeBehavior<std::string> {
+struct TypeImplementsMergeBehavior<StringHandlerType> {
   typedef std::true_type type;
 };
 
@@ -857,12 +889,12 @@ inline void RepeatedPtrFieldBase::MergeFrom<Message>(
   return MergeFrom<MessageLite>(from);
 }
 
+// 由于引入了TaggedPtr，模板特化要做对应调整
 // Appends all `std::string` values from `from` to this instance.
 template <>
-void RepeatedPtrFieldBase::MergeFrom<std::string>(
+void RepeatedPtrFieldBase::MergeFrom<StringHandlerType>(
     const RepeatedPtrFieldBase& from);
 
-
 PROTOBUF_EXPORT void InternalOutOfLineDeleteMessageLite(MessageLite* message);
 
 template <typename GenericType>
@@ -931,14 +963,6 @@ template <>
 PROTOBUF_EXPORT void GenericTypeHandler<MessageLite>::Merge(
     const MessageLite& from, MessageLite* to);
 
-template <>
-inline void GenericTypeHandler<std::string>::Clear(std::string* value) {
-  value->clear();
-}
-template <>
-void GenericTypeHandler<std::string>::Merge(const std::string& from,
-                                            std::string* to);
-
 // Message specialization bodies defined in message.cc. This split is necessary
 // to allow proto2-lite (which includes this header) to be independent of
 // Message.
@@ -948,36 +972,56 @@ PROTOBUF_EXPORT Message* GenericTypeHandler<Message>::NewFromPrototype(
 template <>
 PROTOBUF_EXPORT Arena* GenericTypeHandler<Message>::GetArena(Message* value);
 
-class StringTypeHandler {
+// 对string的GenericTypeHandler进行全特化启用TaggedPtr
+template <>
+class GenericTypeHandler<std::string> {
  public:
-  typedef std::string Type;
-  using Movable = IsMovable<Type>;
+  using Type = StringHandlerType;
+  using Movable = IsMovable<std::string>;
 
-  static PROTOBUF_NOINLINE std::string* New(Arena* arena) {
-    return Arena::Create<std::string>(arena);
-  }
-  static PROTOBUF_NOINLINE std::string* New(Arena* arena, std::string&& value) {
-    return Arena::Create<std::string>(arena, std::move(value));
+  static PROTOBUF_NOINLINE Type* New(Arena* arena) {
+    if (arena != nullptr) {
+      return Type::ToTagged(
+          ArenaStringAccessor::create(arena).underlying());
+    } else {
+      return Type::ToUnTagged(new std::string());
+    }
   }
-  static inline std::string* NewFromPrototype(const std::string*,
-                                              Arena* arena) {
+  static inline Type* NewFromPrototype(const Type*,
+                                       Arena* arena) {
     return New(arena);
   }
-  static inline Arena* GetArena(std::string*) { return nullptr; }
-  static inline void Delete(std::string* value, Arena* arena) {
+  static inline Arena* GetArena(Type*) { return nullptr; }
+  static inline void Delete(Type* value, Arena* arena) {
     if (arena == nullptr) {
-      delete value;
+      delete value->UnTaggedToStringPtr();
     }
   }
-  static inline void Clear(std::string* value) { value->clear(); }
-  static inline void Merge(const std::string& from, std::string* to) {
-    *to = from;
+  static inline void Clear(Type* value) {
+    MaybeArenaStringAccessor::clear(value->ToStringPtr());
   }
-  static size_t SpaceUsedLong(const std::string& value) {
-    return sizeof(value) + StringSpaceUsedExcludingSelfLong(value);
+  static inline void Merge(const Type& from, Type* to) {
+    *to->UnTaggedToStringPtr() = *from.UnTaggedToStringPtr();
+  }
+  static size_t SpaceUsedLong(const Type& value) {
+    return sizeof(std::string) +
+        StringSpaceUsedExcludingSelfLong(*value.ToStringPtr());
   }
 };
 
+// 部分实现假定了GenericTypeHandler<T>::Type == T
+// 于是存在GenericTypeHandler<Type>替换GenericTypeHandler<T>的情况
+// 在string的情况下采用继承方式打平两者
+template <>
+class GenericTypeHandler<StringHandlerType>
+    : public GenericTypeHandler<std::string> {};
+
+// 大部分特化可以在RepeatedPtrField层完成，但是还是存在一些需要在
+// RepeatedPtrFieldBase层进行特化的函数
+template <>
+void RepeatedPtrFieldBase::AddAllocatedSlowWithCopy<GenericTypeHandler<std::string>>(
+    StringHandlerType* value, Arena* value_arena, Arena* my_arena);
+
 }  // namespace internal
 
 // RepeatedPtrField is like RepeatedField, but used for repeated strings or
@@ -1000,6 +1044,10 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
         "We only support string and Message types in RepeatedPtrField.");
   }
 
+  // 由于需要在函数声明中使用，这个定义前置上来
+  using TypeHandler = internal::GenericTypeHandler<Element>;
+  using StorageType = typename TypeHandler::Type;
+
  public:
   using value_type = Element;
   using size_type = int;
@@ -1052,13 +1100,47 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   int size() const;
 
   const_reference Get(int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  // 返回string*的接口改为使用宏定义切换的MutableStringType
+  // 同时增补明确的string*版本和MaybeArenaStringAccessor版本
+  template <typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
   pointer Mutable(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
-
+  template <typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
+  MutableStringType Mutable(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  pointer MutableString(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  MaybeArenaStringAccessor MutableAccessor(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
+
+  // 返回string*的接口改为使用宏定义切换的MutableStringType
+  // 同时增补明确的string*版本和MaybeArenaStringAccessor版本
   // Unlike std::vector, adding an element to a RepeatedPtrField doesn't always
   // make a new element; it might re-use an element left over from when the
   // field was Clear()'d or resize()'d smaller.  For this reason, Add() is the
   // fastest API for adding a new element.
+  template <typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
   pointer Add() ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  template <typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
+  MutableStringType Add();
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  Element* AddString();
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  MaybeArenaStringAccessor AddAccessor();
 
   // `Add(std::move(value));` is equivalent to `*Add() = std::move(value);`
   // It will either move-construct to the end of this field, or swap value
@@ -1075,20 +1157,37 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   // If you must add an existing value, call `*Add() = value;`
   void Add(const Element& value) = delete;
 
+  // string版本增加特化接口
   // Append elements in the range [begin, end) after reserving
   // the appropriate number of elements.
-  template <typename Iter>
+  template <typename Iter, typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
+  void Add(Iter begin, Iter end);
+  template <typename Iter, typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
   void Add(Iter begin, Iter end);
 
   const_reference operator[](int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
     return Get(index);
   }
-  reference operator[](int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  typename std::conditional<::std::is_same<Element, std::string>::value,
+                            MutableStringReferenceType, reference>::type
+  operator[](int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
     return *Mutable(index);
   }
 
   const_reference at(int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  // 返回string&的接口改为使用宏定义切换的MutableStringReferenceType
+  template <typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
   reference at(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  template <typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
+  MutableStringReferenceType at(int index) ABSL_ATTRIBUTE_LIFETIME_BOUND;
 
   // Removes the last element in the array.
   // Ownership of the element is retained by the array.
@@ -1114,11 +1213,12 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
 
   int Capacity() const;
 
+  // 直接操作底层数据时对string要该用TaggedPtr
   // Gets the underlying array.  This pointer is possibly invalidated by
   // any add or remove operation.
-  Element**
+  StorageType**
   mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND;
-  const Element* const* data() const ABSL_ATTRIBUTE_LIFETIME_BOUND;
+  const StorageType* const* data() const ABSL_ATTRIBUTE_LIFETIME_BOUND;
 
   // Swaps entire contents with "other". If they are on separate arenas, then
   // copies data.
@@ -1191,6 +1291,7 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   // UnsafeArenaReleaseLast() if this behavior is undesired.
   PROTOBUF_NODISCARD Element* ReleaseLast();
 
+  // 直接操作底层数据时对string要该用TaggedPtr
   // Adds an already-allocated object, skipping arena-ownership checks. The user
   // must guarantee that the given object is in the same arena as this
   // RepeatedPtrField.
@@ -1203,13 +1304,14 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   // If you put temp_field on the arena this fails, because the ownership
   // transfers to the arena at the "AddAllocated" call and is not released
   // anymore, causing a double delete. UnsafeArenaAddAllocated prevents this.
-  void UnsafeArenaAddAllocated(Element* value);
+  void UnsafeArenaAddAllocated(StorageType* value);
 
+  // 直接操作底层数据时对string要该用TaggedPtr
   // Removes and returns the last element.  Unlike ReleaseLast, the returned
   // pointer is always to the original object.  This may be in an arena, in
   // which case it would have the arena's lifetime.
   // Requires: current_size_ > 0
-  pointer UnsafeArenaReleaseLast();
+  StorageType* UnsafeArenaReleaseLast();
 
   // Extracts elements with indices in the range "[start .. start+num-1]".
   // The caller assumes ownership of the extracted elements and is responsible
@@ -1228,11 +1330,12 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   // UnsafeArenaExtractSubrange().
   void ExtractSubrange(int start, int num, Element** elements);
 
+  // 直接操作底层数据时对string要该用TaggedPtr
   // Identical to ExtractSubrange() described above, except that no object
   // copies are ever performed. Instead, the raw object pointers are returned.
   // Thus, if on an arena, the returned objects must not be freed, because they
   // will not be heap-allocated objects.
-  void UnsafeArenaExtractSubrange(int start, int num, Element** elements);
+  void UnsafeArenaExtractSubrange(int start, int num, StorageType** elements);
 
   // When elements are removed by calls to RemoveLast() or Clear(), they
   // are not actually freed.  Instead, they are cleared and kept so that
@@ -1310,9 +1413,6 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   template <typename T>
   friend struct WeakRepeatedPtrField;
 
-  // Note:  RepeatedPtrField SHOULD NOT be subclassed by users.
-  class TypeHandler;
-
   RepeatedPtrField(Arena* arena, const RepeatedPtrField& rhs);
 
   // Internal version of GetArena().
@@ -1328,21 +1428,14 @@ class RepeatedPtrField final : private internal::RepeatedPtrFieldBase {
   void ExtractSubrangeInternal(int start, int num, Element** elements,
                                std::false_type);
 
-  void AddAllocatedForParse(Element* p) {
+  // 直接操作底层数据时对string要该用TaggedPtr
+  void AddAllocatedForParse(StorageType* p) {
     return RepeatedPtrFieldBase::AddAllocatedForParse<TypeHandler>(p);
   }
 };
 
 // -------------------------------------------------------------------
 
-template <typename Element>
-class RepeatedPtrField<Element>::TypeHandler
-    : public internal::GenericTypeHandler<Element> {};
-
-template <>
-class RepeatedPtrField<std::string>::TypeHandler
-    : public internal::StringTypeHandler {};
-
 template <typename Element>
 constexpr RepeatedPtrField<Element>::RepeatedPtrField()
     : RepeatedPtrFieldBase() {
@@ -1446,38 +1539,149 @@ inline const Element& RepeatedPtrField<Element>::Get(int index) const
   return RepeatedPtrFieldBase::Get<TypeHandler>(index);
 }
 
+template <>
+inline const std::string& RepeatedPtrField<std::string>::Get(int index) const
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  return *RepeatedPtrFieldBase::Get<TypeHandler>(index).ToStringPtr();
+}
+
 template <typename Element>
 inline const Element& RepeatedPtrField<Element>::at(int index) const
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return RepeatedPtrFieldBase::at<TypeHandler>(index);
+  return Get(index);
 }
 
 template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              !std::is_same<T, std::string>::value, int>::type>
 inline Element& RepeatedPtrField<Element>::at(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::at<TypeHandler>(index);
 }
 
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              std::is_same<T, std::string>::value, int>::type>
+inline MutableStringReferenceType RepeatedPtrField<Element>::at(int index) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(index);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return *MutableString(index);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
 
 template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              !std::is_same<T, std::string>::value, int>::type>
 inline Element* RepeatedPtrField<Element>::Mutable(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::Mutable<TypeHandler>(index);
 }
 
 template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              std::is_same<T, std::string>::value, int>::type>
+inline MutableStringType RepeatedPtrField<Element>::Mutable(int index)
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(index);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableString(index);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+template <typename Element>
+template <typename T, typename>
+inline Element* RepeatedPtrField<Element>::MutableString(int index)
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  auto value = RepeatedPtrFieldBase::Mutable<TypeHandler>(index);
+  if (value->IsTagged()) {
+    auto string = Arena::Create<std::string>(
+        GetArena(), *value->ToStringPtr());
+    raw_mutable_data()[index] = string;
+    return string;
+  }
+  return value->UnTaggedToStringPtr();
+}
+
+template <typename Element>
+template <typename T, typename>
+inline MaybeArenaStringAccessor
+RepeatedPtrField<Element>::MutableAccessor(int index)
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  auto value = RepeatedPtrFieldBase::Mutable<TypeHandler>(index);
+  if (value->IsTagged()) {
+    return MaybeArenaStringAccessor(
+        GetArena(), value->ToStringPtr());
+  }
+  return MaybeArenaStringAccessor(nullptr, value->UnTaggedToStringPtr());
+}
+
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              !std::is_same<T, std::string>::value, int>::type>
 PROTOBUF_NOINLINE Element* RepeatedPtrField<Element>::Add()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::Add<TypeHandler>();
 }
 
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              std::is_same<T, std::string>::value, int>::type>
+inline MutableStringType RepeatedPtrField<Element>::Add()
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return AddAccessor();
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return AddString();
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+template <typename Element>
+template <typename T, typename>
+inline Element* RepeatedPtrField<Element>::AddString()
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  auto value = RepeatedPtrFieldBase::Add<TypeHandler>();
+  if (value->IsTagged()) {
+    auto string = Arena::Create<std::string>(
+        GetArena(), *value->ToStringPtr());
+    raw_mutable_data()[size() - 1] = string;
+    return string;
+  }
+  return value->UnTaggedToStringPtr();
+}
+
+template <typename Element>
+template <typename T, typename>
+inline MaybeArenaStringAccessor RepeatedPtrField<Element>::AddAccessor()
+    ABSL_ATTRIBUTE_LIFETIME_BOUND {
+  auto value = RepeatedPtrFieldBase::Add<TypeHandler>();
+  if (value->IsTagged()) {
+    return MaybeArenaStringAccessor(GetArena(), value->ToStringPtr());
+  }
+  return MaybeArenaStringAccessor(nullptr, value->UnTaggedToStringPtr());
+}
+
 template <typename Element>
 inline void RepeatedPtrField<Element>::Add(Element&& value) {
   RepeatedPtrFieldBase::Add<TypeHandler>(std::move(value));
 }
 
+template <>
+inline void RepeatedPtrField<std::string>::Add(std::string&& value) {
+  AddAccessor() = std::move(value);
+}
+
 template <typename Element>
-template <typename Iter>
+template <typename Iter, typename T,
+          typename std::enable_if<
+              !std::is_same<T, std::string>::value, int>::type>
 inline void RepeatedPtrField<Element>::Add(Iter begin, Iter end) {
   if (std::is_base_of<
           std::forward_iterator_tag,
@@ -1490,6 +1694,22 @@ inline void RepeatedPtrField<Element>::Add(Iter begin, Iter end) {
   }
 }
 
+template <typename Element>
+template <typename Iter, typename T,
+          typename std::enable_if<
+              std::is_same<T, std::string>::value, int>::type>
+inline void RepeatedPtrField<Element>::Add(Iter begin, Iter end) {
+  if (std::is_base_of<
+          std::forward_iterator_tag,
+          typename std::iterator_traits<Iter>::iterator_category>::value) {
+    int reserve = static_cast<int>(std::distance(begin, end));
+    Reserve(size() + reserve);
+  }
+  for (; begin != end; ++begin) {
+    AddAccessor() = *begin;
+  }
+}
+
 template <typename Element>
 inline void RepeatedPtrField<Element>::RemoveLast() {
   RepeatedPtrFieldBase::RemoveLast<TypeHandler>();
@@ -1504,7 +1724,7 @@ inline void RepeatedPtrField<Element>::DeleteSubrange(int start, int num) {
   Arena* arena = GetArena();
   for (int i = 0; i < num; ++i) {
     using H = CommonHandler<TypeHandler>;
-    H::Delete(static_cast<Element*>(subrange[i]), arena);
+    H::Delete(static_cast<StorageType*>(subrange[i]), arena);
   }
   UnsafeArenaExtractSubrange(start, num, nullptr);
 }
@@ -1549,7 +1769,8 @@ inline void RepeatedPtrField<Element>::ExtractSubrangeInternal(
     // returned elements are heap-allocated. Otherwise, just forward it.
     if (arena != nullptr) {
       for (int i = 0; i < num; ++i) {
-        elements[i] = copy<TypeHandler>(extracted[i]);
+        elements[i] = reinterpret_cast<Element*>(
+            copy<TypeHandler>(extracted[i]));
       }
     } else {
       memcpy(elements, extracted, num * sizeof(Element*));
@@ -1576,7 +1797,7 @@ inline void RepeatedPtrField<Element>::ExtractSubrangeInternal(
 
 template <typename Element>
 inline void RepeatedPtrField<Element>::UnsafeArenaExtractSubrange(
-    int start, int num, Element** elements) {
+    int start, int num, StorageType** elements) {
   ABSL_DCHECK_GE(start, 0);
   ABSL_DCHECK_GE(num, 0);
   ABSL_DCHECK_LE(start + num, size());
@@ -1599,7 +1820,7 @@ template <typename Element>
 inline void RepeatedPtrField<Element>::MergeFrom(
     const RepeatedPtrField& other) {
   if (other.empty()) return;
-  RepeatedPtrFieldBase::MergeFrom<Element>(other);
+  RepeatedPtrFieldBase::MergeFrom<StorageType>(other);
 }
 
 template <typename Element>
@@ -1632,17 +1853,26 @@ RepeatedPtrField<Element>::erase(const_iterator first, const_iterator last)
 }
 
 template <typename Element>
-inline Element** RepeatedPtrField<Element>::mutable_data()
+inline typename RepeatedPtrField<Element>::StorageType**
+RepeatedPtrField<Element>::mutable_data()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::mutable_data<TypeHandler>();
 }
 
 template <typename Element>
-inline const Element* const* RepeatedPtrField<Element>::data() const
+inline const typename RepeatedPtrField<Element>::StorageType* const*
+RepeatedPtrField<Element>::data() const
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   return RepeatedPtrFieldBase::data<TypeHandler>();
 }
 
+//template <>
+//inline const ::std::string* const*
+//RepeatedPtrField<::std::string>::data() const {
+//  return reinterpret_cast<const ::std::string* const*>(
+//      RepeatedPtrFieldBase::data<TypeHandler>());
+//}
+
 template <typename Element>
 inline void RepeatedPtrField<Element>::Swap(RepeatedPtrField* other) {
   if (this == other) return;
@@ -1695,8 +1925,15 @@ inline void RepeatedPtrField<Element>::AddAllocated(Element* value) {
   RepeatedPtrFieldBase::AddAllocated<TypeHandler>(value);
 }
 
+template <>
+inline void RepeatedPtrField<std::string>::AddAllocated(std::string* value) {
+  RepeatedPtrFieldBase::AddAllocated<TypeHandler>(
+      internal::StringHandlerType::ToUnTagged(value));
+}
+
 template <typename Element>
-inline void RepeatedPtrField<Element>::UnsafeArenaAddAllocated(Element* value) {
+inline void RepeatedPtrField<Element>::UnsafeArenaAddAllocated(
+      StorageType* value) {
   RepeatedPtrFieldBase::UnsafeArenaAddAllocated<TypeHandler>(value);
 }
 
@@ -1705,8 +1942,20 @@ inline Element* RepeatedPtrField<Element>::ReleaseLast() {
   return RepeatedPtrFieldBase::ReleaseLast<TypeHandler>();
 }
 
+template <>
+inline std::string* RepeatedPtrField<std::string>::ReleaseLast() {
+  auto value = RepeatedPtrFieldBase::UnsafeArenaReleaseLast<TypeHandler>();
+  if (value->IsTagged()) {
+    return new std::string(*value->ToStringPtr());
+  } else if (GetArena() != nullptr) {
+    return new std::string(::std::move(*value->UnTaggedToStringPtr()));
+  }
+  return value->UnTaggedToStringPtr();
+}
+
 template <typename Element>
-inline Element* RepeatedPtrField<Element>::UnsafeArenaReleaseLast() {
+inline typename RepeatedPtrField<Element>::StorageType*
+RepeatedPtrField<Element>::UnsafeArenaReleaseLast() {
   return RepeatedPtrFieldBase::UnsafeArenaReleaseLast<TypeHandler>();
 }
 
@@ -1721,10 +1970,21 @@ inline void RepeatedPtrField<Element>::AddCleared(Element* value) {
   return RepeatedPtrFieldBase::AddCleared<TypeHandler>(value);
 }
 
+template <>
+inline void RepeatedPtrField<std::string>::AddCleared(std::string* value) {
+  return RepeatedPtrFieldBase::AddCleared<TypeHandler>(
+      TypeHandler::Type::ToUnTagged(value));
+}
+
 template <typename Element>
 inline Element* RepeatedPtrField<Element>::ReleaseCleared() {
   return RepeatedPtrFieldBase::ReleaseCleared<TypeHandler>();
 }
+
+template <>
+inline std::string* RepeatedPtrField<std::string>::ReleaseCleared() {
+  return RepeatedPtrFieldBase::ReleaseCleared<TypeHandler>()->UnTaggedToStringPtr();
+}
 #endif  // !PROTOBUF_FUTURE_REMOVE_CLEARED_API
 
 template <typename Element>
@@ -1759,11 +2019,17 @@ class RepeatedPtrIterator {
   using iterator_category = std::random_access_iterator_tag;
   using value_type = typename std::remove_const<Element>::type;
   using difference_type = std::ptrdiff_t;
-  using pointer = Element*;
-  using reference = Element&;
-
-  RepeatedPtrIterator() : it_(nullptr) {}
-  explicit RepeatedPtrIterator(void* const* it) : it_(it) {}
+  using pointer = typename std::conditional<
+      std::is_same<std::string, Element>::value,
+      MutableStringType, Element*>::type;
+  using reference = typename std::conditional<
+      std::is_same<std::string, Element>::value,
+      MutableStringReferenceType, Element&>::type;
+  using TypeHandler = GenericTypeHandler<std::string>;
+
+  RepeatedPtrIterator() : it_(nullptr), arena_(nullptr) {}
+  RepeatedPtrIterator(void* const* it, Arena* arena)
+      : it_(it), arena_(arena) {}
 
   // Allows "upcasting" from RepeatedPtrIterator<T**> to
   // RepeatedPtrIterator<const T*const*>.
@@ -1771,7 +2037,7 @@ class RepeatedPtrIterator {
             typename std::enable_if<std::is_convertible<
                 OtherElement*, pointer>::value>::type* = nullptr>
   RepeatedPtrIterator(const RepeatedPtrIterator<OtherElement>& other)
-      : it_(other.it_) {}
+      : it_(other.it_), arena_(other.arena_) {}
 
   // dereferenceable
   reference operator*() const { return *reinterpret_cast<Element*>(*it_); }
@@ -1782,12 +2048,12 @@ class RepeatedPtrIterator {
     ++it_;
     return *this;
   }
-  iterator operator++(int) { return iterator(it_++); }
+  iterator operator++(int) { return iterator(it_++, arena_); }
   iterator& operator--() {
     --it_;
     return *this;
   }
-  iterator operator--(int) { return iterator(it_--); }
+  iterator operator--(int) { return iterator(it_--, arena_); }
 
   // equality_comparable
   friend bool operator==(const iterator& x, const iterator& y) {
@@ -1847,8 +2113,47 @@ class RepeatedPtrIterator {
 
   // The internal iterator.
   void* const* it_;
+  Arena* arena_;
 };
 
+template <>
+inline const std::string&
+RepeatedPtrIterator<const std::string>::operator*() const {
+  auto value = reinterpret_cast<const TypeHandler::Type*>(*it_);
+  return *value->ToStringPtr();
+}
+
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+template <>
+inline MaybeArenaStringAccessor
+RepeatedPtrIterator<std::string>::operator*() const {
+  auto value = reinterpret_cast<TypeHandler::Type*>(*it_);
+  if (value->IsTagged()) {
+    return MaybeArenaStringAccessor(
+        arena_, value->ToStringPtr());
+  }
+  return MaybeArenaStringAccessor(
+      nullptr, value->UnTaggedToStringPtr());
+}
+template <>
+inline MaybeArenaStringAccessor
+RepeatedPtrIterator<std::string>::operator->() const {
+  return operator*();
+}
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+template <>
+inline std::string& RepeatedPtrIterator<std::string>::operator*() const {
+  auto value = reinterpret_cast<TypeHandler::Type*>(*it_);
+  if (value->IsTagged()) {
+    auto string = Arena::Create<std::string>(
+        arena_, *value->ToStringPtr());
+    *const_cast<void**>(it_) = string;
+    return *string;
+  }
+  return *value->UnTaggedToStringPtr();
+}
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+
 // Provides an iterator that operates on pointers to the underlying objects
 // rather than the objects themselves as RepeatedPtrIterator does.
 // Consider using this when working with stl algorithms that change
@@ -1961,12 +2266,12 @@ class RepeatedPtrOverPtrsIterator {
 template <typename Element>
 inline typename RepeatedPtrField<Element>::iterator
 RepeatedPtrField<Element>::begin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return iterator(raw_data());
+  return iterator(raw_data(), GetArena());
 }
 template <typename Element>
 inline typename RepeatedPtrField<Element>::const_iterator
 RepeatedPtrField<Element>::begin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return iterator(raw_data());
+  return iterator(raw_data(), nullptr);
 }
 template <typename Element>
 inline typename RepeatedPtrField<Element>::const_iterator
@@ -1976,12 +2281,12 @@ RepeatedPtrField<Element>::cbegin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
 template <typename Element>
 inline typename RepeatedPtrField<Element>::iterator
 RepeatedPtrField<Element>::end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return iterator(raw_data() + size());
+  return iterator(raw_data() + size(), GetArena());
 }
 template <typename Element>
 inline typename RepeatedPtrField<Element>::const_iterator
 RepeatedPtrField<Element>::end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  return iterator(raw_data() + size());
+  return iterator(raw_data() + size(), nullptr);
 }
 template <typename Element>
 inline typename RepeatedPtrField<Element>::const_iterator
@@ -2056,6 +2361,27 @@ class RepeatedPtrFieldBackInsertIterator {
  private:
   RepeatedPtrField<T>* field_;
 };
+template <>
+inline RepeatedPtrFieldBackInsertIterator<std::string>&
+RepeatedPtrFieldBackInsertIterator<std::string>::operator=(
+    const std::string& value) {
+  *field_->AddAccessor() = value;
+  return *this;
+}
+template <>
+inline RepeatedPtrFieldBackInsertIterator<std::string>&
+RepeatedPtrFieldBackInsertIterator<std::string>::operator=(
+    const std::string* const ptr_to_value) {
+  *field_->AddAccessor() = *ptr_to_value;
+  return *this;
+}
+template <>
+inline RepeatedPtrFieldBackInsertIterator<std::string>&
+RepeatedPtrFieldBackInsertIterator<std::string>::operator=(
+    std::string&& value) {
+  *field_->AddAccessor() = ::std::move(value);
+  return *this;
+}
 
 // A back inserter for RepeatedPtrFields that inserts by transferring ownership
 // of a pointer.
@@ -2091,8 +2417,9 @@ class AllocatedRepeatedPtrFieldBackInsertIterator {
 template <typename T>
 class UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator {
  public:
+  using TypeHandler = GenericTypeHandler<T>;
   using iterator_category = std::output_iterator_tag;
-  using value_type = T;
+  using value_type = typename TypeHandler::Type;
   using pointer = void;
   using reference = void;
   using difference_type = std::ptrdiff_t;
@@ -2101,8 +2428,9 @@ class UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator {
       RepeatedPtrField<T>* const mutable_field)
       : field_(mutable_field) {}
   UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator<T>& operator=(
-      T const* const ptr_to_value) {
-    field_->UnsafeArenaAddAllocated(const_cast<T*>(ptr_to_value));
+      value_type const* const ptr_to_value) {
+    field_->UnsafeArenaAddAllocated(
+        const_cast<value_type*>(ptr_to_value));
     return *this;
   }
   UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator<T>& operator*() {
diff --git a/src/google/protobuf/source_context.pb.h b/src/google/protobuf/source_context.pb.h
index 54819ee9d..68a0d9c4c 100644
--- a/src/google/protobuf/source_context.pb.h
+++ b/src/google/protobuf/source_context.pb.h
@@ -219,6 +219,7 @@ class PROTOBUF_EXPORT SourceContext final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
       const std::string& value);
   std::string* _internal_mutable_file_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_file_name_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.SourceContext)
@@ -287,7 +288,7 @@ inline PROTOBUF_ALWAYS_INLINE void SourceContext::set_file_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.SourceContext.file_name)
 }
 inline std::string* SourceContext::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_file_name();
+  auto _s = _internal_mutable_file_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.SourceContext.file_name)
   return _s;
 }
@@ -305,10 +306,19 @@ inline std::string* SourceContext::_internal_mutable_file_name() {
   ;
   return _impl_.file_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor SourceContext::_internal_mutable_file_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.file_name_.MutableAccessor( GetArena());
+}
 inline std::string* SourceContext::release_file_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.SourceContext.file_name)
-  return _impl_.file_name_.Release();
+  auto* released = _impl_.file_name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.file_name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void SourceContext::set_allocated_file_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
diff --git a/src/google/protobuf/struct.pb.h b/src/google/protobuf/struct.pb.h
index adf918230..604cf2b0c 100644
--- a/src/google/protobuf/struct.pb.h
+++ b/src/google/protobuf/struct.pb.h
@@ -697,6 +697,7 @@ class PROTOBUF_EXPORT Value final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
       const std::string& value);
   std::string* _internal_mutable_string_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_string_value_accessor();
 
   public:
   // bool bool_value = 4;
@@ -956,7 +957,7 @@ inline PROTOBUF_ALWAYS_INLINE void Value::set_string_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Value.string_value)
 }
 inline std::string* Value::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_string_value();
+  auto _s = _internal_mutable_string_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Value.string_value)
   return _s;
 }
@@ -987,6 +988,16 @@ inline std::string* Value::_internal_mutable_string_value() {
   }
   return _impl_.kind_.string_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Value::_internal_mutable_string_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  if (kind_case() != kStringValue) {
+    clear_kind();
+
+    set_has_string_value();
+    _impl_.kind_.string_value_.InitDefault();
+  }
+  return _impl_.kind_.string_value_.MutableAccessor( GetArena());
+}
 inline std::string* Value::release_string_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Value.string_value)
diff --git a/src/google/protobuf/type.pb.h b/src/google/protobuf/type.pb.h
index b79ba6ef1..ae0689d63 100644
--- a/src/google/protobuf/type.pb.h
+++ b/src/google/protobuf/type.pb.h
@@ -354,6 +354,7 @@ class PROTOBUF_EXPORT Option final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // .google.protobuf.Any value = 2;
@@ -638,6 +639,7 @@ class PROTOBUF_EXPORT Field final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string type_url = 6;
@@ -654,6 +656,7 @@ class PROTOBUF_EXPORT Field final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_url(
       const std::string& value);
   std::string* _internal_mutable_type_url();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_type_url_accessor();
 
   public:
   // string json_name = 10;
@@ -670,6 +673,7 @@ class PROTOBUF_EXPORT Field final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_json_name(
       const std::string& value);
   std::string* _internal_mutable_json_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_json_name_accessor();
 
   public:
   // string default_value = 11;
@@ -686,6 +690,7 @@ class PROTOBUF_EXPORT Field final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(
       const std::string& value);
   std::string* _internal_mutable_default_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_default_value_accessor();
 
   public:
   // .google.protobuf.Field.Kind kind = 1;
@@ -946,6 +951,7 @@ class PROTOBUF_EXPORT EnumValue final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // int32 number = 2;
@@ -1209,6 +1215,7 @@ class PROTOBUF_EXPORT Type final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string edition = 7;
@@ -1225,6 +1232,7 @@ class PROTOBUF_EXPORT Type final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_edition(
       const std::string& value);
   std::string* _internal_mutable_edition();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_edition_accessor();
 
   public:
   // .google.protobuf.SourceContext source_context = 5;
@@ -1479,6 +1487,7 @@ class PROTOBUF_EXPORT Enum final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
       const std::string& value);
   std::string* _internal_mutable_name();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_name_accessor();
 
   public:
   // string edition = 6;
@@ -1495,6 +1504,7 @@ class PROTOBUF_EXPORT Enum final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_edition(
       const std::string& value);
   std::string* _internal_mutable_edition();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_edition_accessor();
 
   public:
   // .google.protobuf.SourceContext source_context = 4;
@@ -1594,7 +1604,7 @@ inline PROTOBUF_ALWAYS_INLINE void Type::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Type.name)
 }
 inline std::string* Type::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Type.name)
   return _s;
 }
@@ -1612,10 +1622,19 @@ inline std::string* Type::_internal_mutable_name() {
   ;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Type::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Type::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Type.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Type::set_allocated_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -1691,7 +1710,7 @@ inline void Type::clear_oneofs() {
 inline std::string* Type::add_oneofs()
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  std::string* _s = _internal_mutable_oneofs()->Add();
+  auto _s = _internal_mutable_oneofs()->AddString();
   // @@protoc_insertion_point(field_add_mutable:google.protobuf.Type.oneofs)
   return _s;
 }
@@ -1703,35 +1722,36 @@ inline const std::string& Type::oneofs(int index) const
 inline std::string* Type::mutable_oneofs(int index)
     ABSL_ATTRIBUTE_LIFETIME_BOUND {
   // @@protoc_insertion_point(field_mutable:google.protobuf.Type.oneofs)
-  return _internal_mutable_oneofs()->Mutable(index);
+  return _internal_mutable_oneofs()->MutableString(index);
 }
 inline void Type::set_oneofs(int index, const std::string& value) {
-  _internal_mutable_oneofs()->Mutable(index)->assign(value);
+  _internal_mutable_oneofs()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set:google.protobuf.Type.oneofs)
 }
 inline void Type::set_oneofs(int index, std::string&& value) {
-  _internal_mutable_oneofs()->Mutable(index)->assign(std::move(value));
+  _internal_mutable_oneofs()->MutableAccessor(index)->assign(
+      std::move(value));
   // @@protoc_insertion_point(field_set:google.protobuf.Type.oneofs)
 }
 inline void Type::set_oneofs(int index, const char* value) {
   ABSL_DCHECK(value != nullptr);
-  _internal_mutable_oneofs()->Mutable(index)->assign(value);
+  _internal_mutable_oneofs()->MutableAccessor(index)->assign(value);
   // @@protoc_insertion_point(field_set_char:google.protobuf.Type.oneofs)
 }
 inline void Type::set_oneofs(int index, const char* value,
                               std::size_t size) {
-  _internal_mutable_oneofs()->Mutable(index)->assign(
+  _internal_mutable_oneofs()->MutableAccessor(index)->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_set_pointer:google.protobuf.Type.oneofs)
 }
 inline void Type::set_oneofs(int index, absl::string_view value) {
-  _internal_mutable_oneofs()->Mutable(index)->assign(value.data(),
-                                                     value.size());
+  _internal_mutable_oneofs()->MutableAccessor(index)->assign(
+      value.data(), value.size());
   // @@protoc_insertion_point(field_set_string_piece:google.protobuf.Type.oneofs)
 }
 inline void Type::add_oneofs(const std::string& value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_oneofs()->Add()->assign(value);
+  _internal_mutable_oneofs()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add:google.protobuf.Type.oneofs)
 }
 inline void Type::add_oneofs(std::string&& value) {
@@ -1742,18 +1762,18 @@ inline void Type::add_oneofs(std::string&& value) {
 inline void Type::add_oneofs(const char* value) {
   ABSL_DCHECK(value != nullptr);
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_oneofs()->Add()->assign(value);
+  _internal_mutable_oneofs()->AddAccessor()->assign(value);
   // @@protoc_insertion_point(field_add_char:google.protobuf.Type.oneofs)
 }
 inline void Type::add_oneofs(const char* value, std::size_t size) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_oneofs()->Add()->assign(
+  _internal_mutable_oneofs()->AddAccessor()->assign(
       reinterpret_cast<const char*>(value), size);
   // @@protoc_insertion_point(field_add_pointer:google.protobuf.Type.oneofs)
 }
 inline void Type::add_oneofs(absl::string_view value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
-  _internal_mutable_oneofs()->Add()->assign(value.data(), value.size());
+  _internal_mutable_oneofs()->AddAccessor()->assign(value.data(), value.size());
   // @@protoc_insertion_point(field_add_string_piece:google.protobuf.Type.oneofs)
 }
 inline const ::google::protobuf::RepeatedPtrField<std::string>&
@@ -1960,7 +1980,7 @@ inline PROTOBUF_ALWAYS_INLINE void Type::set_edition(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Type.edition)
 }
 inline std::string* Type::mutable_edition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_edition();
+  auto _s = _internal_mutable_edition();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Type.edition)
   return _s;
 }
@@ -1978,10 +1998,19 @@ inline std::string* Type::_internal_mutable_edition() {
   ;
   return _impl_.edition_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Type::_internal_mutable_edition_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.edition_.MutableAccessor( GetArena());
+}
 inline std::string* Type::release_edition() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Type.edition)
-  return _impl_.edition_.Release();
+  auto* released = _impl_.edition_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.edition_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Type::set_allocated_edition(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -2086,7 +2115,7 @@ inline PROTOBUF_ALWAYS_INLINE void Field::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Field.name)
 }
 inline std::string* Field::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Field.name)
   return _s;
 }
@@ -2104,10 +2133,19 @@ inline std::string* Field::_internal_mutable_name() {
   ;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Field::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Field::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Field.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Field::set_allocated_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -2139,7 +2177,7 @@ inline PROTOBUF_ALWAYS_INLINE void Field::set_type_url(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Field.type_url)
 }
 inline std::string* Field::mutable_type_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_type_url();
+  auto _s = _internal_mutable_type_url();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Field.type_url)
   return _s;
 }
@@ -2157,10 +2195,19 @@ inline std::string* Field::_internal_mutable_type_url() {
   ;
   return _impl_.type_url_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Field::_internal_mutable_type_url_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.type_url_.MutableAccessor( GetArena());
+}
 inline std::string* Field::release_type_url() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Field.type_url)
-  return _impl_.type_url_.Release();
+  auto* released = _impl_.type_url_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.type_url_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Field::set_allocated_type_url(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -2287,7 +2334,7 @@ inline PROTOBUF_ALWAYS_INLINE void Field::set_json_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Field.json_name)
 }
 inline std::string* Field::mutable_json_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_json_name();
+  auto _s = _internal_mutable_json_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Field.json_name)
   return _s;
 }
@@ -2305,10 +2352,19 @@ inline std::string* Field::_internal_mutable_json_name() {
   ;
   return _impl_.json_name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Field::_internal_mutable_json_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.json_name_.MutableAccessor( GetArena());
+}
 inline std::string* Field::release_json_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Field.json_name)
-  return _impl_.json_name_.Release();
+  auto* released = _impl_.json_name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.json_name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Field::set_allocated_json_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -2340,7 +2396,7 @@ inline PROTOBUF_ALWAYS_INLINE void Field::set_default_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Field.default_value)
 }
 inline std::string* Field::mutable_default_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_default_value();
+  auto _s = _internal_mutable_default_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Field.default_value)
   return _s;
 }
@@ -2358,10 +2414,19 @@ inline std::string* Field::_internal_mutable_default_value() {
   ;
   return _impl_.default_value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Field::_internal_mutable_default_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.default_value_.MutableAccessor( GetArena());
+}
 inline std::string* Field::release_default_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Field.default_value)
-  return _impl_.default_value_.Release();
+  auto* released = _impl_.default_value_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.default_value_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Field::set_allocated_default_value(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -2397,7 +2462,7 @@ inline PROTOBUF_ALWAYS_INLINE void Enum::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Enum.name)
 }
 inline std::string* Enum::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Enum.name)
   return _s;
 }
@@ -2415,10 +2480,19 @@ inline std::string* Enum::_internal_mutable_name() {
   ;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Enum::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Enum::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Enum.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Enum::set_allocated_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -2662,7 +2736,7 @@ inline PROTOBUF_ALWAYS_INLINE void Enum::set_edition(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Enum.edition)
 }
 inline std::string* Enum::mutable_edition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_edition();
+  auto _s = _internal_mutable_edition();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Enum.edition)
   return _s;
 }
@@ -2680,10 +2754,19 @@ inline std::string* Enum::_internal_mutable_edition() {
   ;
   return _impl_.edition_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Enum::_internal_mutable_edition_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.edition_.MutableAccessor( GetArena());
+}
 inline std::string* Enum::release_edition() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Enum.edition)
-  return _impl_.edition_.Release();
+  auto* released = _impl_.edition_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.edition_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Enum::set_allocated_edition(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -2719,7 +2802,7 @@ inline PROTOBUF_ALWAYS_INLINE void EnumValue::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.EnumValue.name)
 }
 inline std::string* EnumValue::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.EnumValue.name)
   return _s;
 }
@@ -2737,10 +2820,19 @@ inline std::string* EnumValue::_internal_mutable_name() {
   ;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor EnumValue::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* EnumValue::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.EnumValue.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void EnumValue::set_allocated_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -2848,7 +2940,7 @@ inline PROTOBUF_ALWAYS_INLINE void Option::set_name(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.Option.name)
 }
 inline std::string* Option::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_name();
+  auto _s = _internal_mutable_name();
   // @@protoc_insertion_point(field_mutable:google.protobuf.Option.name)
   return _s;
 }
@@ -2866,10 +2958,19 @@ inline std::string* Option::_internal_mutable_name() {
   ;
   return _impl_.name_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor Option::_internal_mutable_name_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.name_.MutableAccessor( GetArena());
+}
 inline std::string* Option::release_name() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.Option.name)
-  return _impl_.name_.Release();
+  auto* released = _impl_.name_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.name_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void Option::set_allocated_name(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
diff --git a/src/google/protobuf/wrappers.pb.h b/src/google/protobuf/wrappers.pb.h
index e26fc80ed..e2ba2ae7b 100644
--- a/src/google/protobuf/wrappers.pb.h
+++ b/src/google/protobuf/wrappers.pb.h
@@ -593,6 +593,7 @@ class PROTOBUF_EXPORT StringValue final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
       const std::string& value);
   std::string* _internal_mutable_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_value_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.StringValue)
@@ -1474,6 +1475,7 @@ class PROTOBUF_EXPORT BytesValue final :
   inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
       const std::string& value);
   std::string* _internal_mutable_value();
+  ::google::protobuf::MaybeArenaStringAccessor _internal_mutable_value_accessor();
 
   public:
   // @@protoc_insertion_point(class_scope:google.protobuf.BytesValue)
@@ -1906,7 +1908,7 @@ inline PROTOBUF_ALWAYS_INLINE void StringValue::set_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.StringValue.value)
 }
 inline std::string* StringValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_value();
+  auto _s = _internal_mutable_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.StringValue.value)
   return _s;
 }
@@ -1924,10 +1926,19 @@ inline std::string* StringValue::_internal_mutable_value() {
   ;
   return _impl_.value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor StringValue::_internal_mutable_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.value_.MutableAccessor( GetArena());
+}
 inline std::string* StringValue::release_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.StringValue.value)
-  return _impl_.value_.Release();
+  auto* released = _impl_.value_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.value_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void StringValue::set_allocated_value(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
@@ -1963,7 +1974,7 @@ inline PROTOBUF_ALWAYS_INLINE void BytesValue::set_value(Arg_&& arg,
   // @@protoc_insertion_point(field_set:google.protobuf.BytesValue.value)
 }
 inline std::string* BytesValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
-  std::string* _s = _internal_mutable_value();
+  auto _s = _internal_mutable_value();
   // @@protoc_insertion_point(field_mutable:google.protobuf.BytesValue.value)
   return _s;
 }
@@ -1981,10 +1992,19 @@ inline std::string* BytesValue::_internal_mutable_value() {
   ;
   return _impl_.value_.Mutable( GetArena());
 }
+inline ::google::protobuf::MaybeArenaStringAccessor BytesValue::_internal_mutable_value_accessor() {
+  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
+  ;
+  return _impl_.value_.MutableAccessor( GetArena());
+}
 inline std::string* BytesValue::release_value() {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
   // @@protoc_insertion_point(field_release:google.protobuf.BytesValue.value)
-  return _impl_.value_.Release();
+  auto* released = _impl_.value_.Release();
+  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  _impl_.value_.Set("", GetArena());
+  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
+  return released;
 }
 inline void BytesValue::set_allocated_value(std::string* value) {
   PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
diff --git a/test/test_arena_string.cpp b/test/test_arena_string.cpp
new file mode 100644
index 000000000..f620bd28c
--- /dev/null
+++ b/test/test_arena_string.cpp
@@ -0,0 +1,1464 @@
+#include <google/protobuf/arena.h>
+#include <google/protobuf/descriptor.pb.h>
+#include <google/protobuf/arenastring_impl.h>
+#include <google/protobuf/reflection.h>
+#include <test_arena_string_arena_pb2.pb.h>
+#include <test_arena_string_arena_pb3.pb.h>
+#include <test_arena_string_pb2.pb.h>
+#include <test_arena_string_pb3.pb.h>
+
+#include <gtest/gtest.h>
+
+using ::google::protobuf::Arena;
+using ::google::protobuf::ArenaOptions;
+using ::google::protobuf::MaybeArenaStringAccessor;
+using ::google::protobuf::RepeatedPtrField;
+
+using ::google::protobuf::test_arena_string::Proto2;
+using ::google::protobuf::test_arena_string::Proto2Extension;
+using ::google::protobuf::test_arena_string::Proto3;
+using ::google::protobuf::test_arena_string::ArenaProto2;
+using ::google::protobuf::test_arena_string::ArenaProto2Extension;
+using ::google::protobuf::test_arena_string::ArenaProto3;
+
+class ArenaStringTest : public ::testing::Test {
+public:
+    virtual void SetUp() {
+        ArenaOptions options;
+        options.initial_block = buffer;
+        options.initial_block_size = sizeof(buffer);
+        arena = new Arena(options);
+    }
+
+    virtual void TearDown() {
+        delete arena;
+    }
+
+    void assert_address_on_arena(const void* address, bool on) {
+        if (on) {
+            ASSERT_GE(address, buffer);
+            ASSERT_LT(address, buffer + sizeof(buffer));
+        } else {
+            ASSERT_TRUE(address < buffer || address >= buffer + sizeof(buffer));
+        }
+    }
+
+    void assert_on_arena(const ::std::string& string, bool on, bool content_on) {
+        assert_address_on_arena(&string, on);
+        if (string.capacity() > 0) {
+            assert_address_on_arena(string.c_str(), content_on);
+            assert_address_on_arena(string.c_str() + string.capacity() - 1, content_on);
+        }
+    }
+
+    void assert_on_arena(const ::std::string& string, bool on) {
+        assert_on_arena(string, on, on);
+    }
+
+    char buffer[1L << 20];
+    Arena* arena;
+};
+
+::std::string tiny_string = ::std::string(::std::string().capacity(), 'x');
+::std::string short_string = ::std::string(::std::string().capacity() + 1, 'y');
+::std::string long_string = ::std::string(::std::string().capacity() + 64, 'z');
+
+template <typename T>
+static void create_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    {
+        auto accessor = MaybeArenaStringAccessor::create(arena);
+        ASSERT_TRUE(accessor.empty());
+        assert_on_arena(accessor);
+        accessor.destroy();
+    }
+    {
+        auto accessor = MaybeArenaStringAccessor::create(arena, tiny_string);
+        ASSERT_EQ(tiny_string, accessor);
+        ASSERT_EQ(tiny_string, accessor.c_str());
+        assert_on_arena(accessor);
+        accessor.destroy();
+    }
+    {
+        auto accessor = MaybeArenaStringAccessor::create(arena, short_string);
+        ASSERT_EQ(short_string, accessor);
+        ASSERT_EQ(short_string, accessor.c_str());
+        assert_on_arena(accessor);
+        accessor.destroy();
+    }
+    {
+        auto accessor = MaybeArenaStringAccessor::create(arena, long_string);
+        ASSERT_EQ(long_string, accessor);
+        ASSERT_EQ(long_string, accessor.c_str());
+        assert_on_arena(accessor);
+        accessor.destroy();
+    }
+}
+TEST_F(ArenaStringTest, create_on_arena) {
+    create_on_arena(*this, arena);
+    create_on_arena(*this, nullptr);
+}
+
+template <typename T>
+static void correct_data_size_and_capacity(T& t, Arena* arena) {
+    for (size_t i = 0; i < long_string.size(); ++i) {
+        auto accessor = MaybeArenaStringAccessor::create(arena);
+        accessor.assign(long_string.c_str(), i);
+        ASSERT_EQ(i, ::strlen(accessor.c_str()));
+        ASSERT_EQ(0, ::memcmp(long_string.c_str(), accessor.c_str(), i));
+        ASSERT_EQ(i, accessor.size());
+        ASSERT_LE(i, accessor.capacity());
+        accessor.destroy();
+    }
+}
+TEST_F(ArenaStringTest, correct_data_size_and_capacity) {
+    correct_data_size_and_capacity(*this, arena);
+    correct_data_size_and_capacity(*this, nullptr);
+}
+
+template <typename T>
+static void assign_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto accessor = MaybeArenaStringAccessor::create(arena);
+    accessor = tiny_string;
+    ASSERT_EQ(tiny_string, accessor);
+    ASSERT_STREQ(tiny_string.c_str(), accessor.c_str());
+    assert_on_arena(accessor);
+    accessor = short_string;
+    ASSERT_EQ(short_string, accessor);
+    ASSERT_STREQ(short_string.c_str(), accessor.c_str());
+    assert_on_arena(accessor);
+    accessor = long_string;
+    ASSERT_EQ(long_string, accessor);
+    ASSERT_STREQ(long_string.c_str(), accessor.c_str());
+    assert_on_arena(accessor);
+    accessor = short_string;
+    ASSERT_EQ(short_string, accessor);
+    ASSERT_STREQ(short_string.c_str(), accessor.c_str());
+    assert_on_arena(accessor);
+    accessor.destroy();
+}
+TEST_F(ArenaStringTest, assign_on_arena) {
+    assign_on_arena(*this, arena);
+    assign_on_arena(*this, nullptr);
+}
+
+template <typename T>
+static void reserve_keep_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto accessor = MaybeArenaStringAccessor::create(arena);
+    accessor = tiny_string;
+    accessor.reserve(short_string.size());
+    ASSERT_EQ(tiny_string, accessor);
+    ASSERT_STREQ(tiny_string.c_str(), accessor.c_str());
+    ASSERT_LE(short_string.size(), accessor.capacity());
+    assert_on_arena(accessor);
+    accessor.reserve(long_string.size());
+    ASSERT_EQ(tiny_string, accessor);
+    ASSERT_STREQ(tiny_string.c_str(), accessor.c_str());
+    ASSERT_LE(long_string.size(), accessor.capacity());
+    assert_on_arena(accessor);
+    accessor.destroy();
+}
+TEST_F(ArenaStringTest, reserve_keep_on_arena) {
+    reserve_keep_on_arena(*this, arena);
+    reserve_keep_on_arena(*this, nullptr);
+}
+
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+TEST_F(ArenaStringTest, do_not_copy_on_write) {
+    auto std_string = new ::std::string();
+    auto half_arena_string = Arena::Create<::std::string>(arena);
+    auto accessor = MaybeArenaStringAccessor::create(arena);
+    auto* arena_string = &(const ::std::string&)accessor;
+    ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+    ASSERT_EQ(::std::string(*half_arena_string).c_str(), half_arena_string->c_str());
+    ASSERT_EQ(::std::string(*arena_string).c_str(), arena_string->c_str());
+    std_string->assign(long_string);
+    half_arena_string->assign(long_string);
+    accessor->assign(long_string);
+    ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+    ASSERT_EQ(::std::string(*half_arena_string).c_str(), half_arena_string->c_str());
+    ASSERT_NE(::std::string(*arena_string).c_str(), arena_string->c_str());
+    std_string->clear();
+    half_arena_string->clear();
+    accessor->clear();
+    ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+    ASSERT_EQ(::std::string(*half_arena_string).c_str(), half_arena_string->c_str());
+    ASSERT_NE(::std::string(*arena_string).c_str(), arena_string->c_str());
+    std_string->assign(short_string);
+    half_arena_string->assign(short_string);
+    accessor->assign(short_string);
+    ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+    ASSERT_EQ(::std::string(*half_arena_string).c_str(), half_arena_string->c_str());
+    ASSERT_NE(::std::string(*arena_string).c_str(), arena_string->c_str());
+    std_string->append(long_string);
+    half_arena_string->append(long_string);
+    accessor->append(long_string);
+    ASSERT_EQ(::std::string(*std_string).c_str(), std_string->c_str());
+    ASSERT_EQ(::std::string(*half_arena_string).c_str(), half_arena_string->c_str());
+    ASSERT_NE(::std::string(*arena_string).c_str(), arena_string->c_str());
+    delete std_string;
+}
+#endif // __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+
+TEST_F(ArenaStringTest, support_resize) {
+    auto accessor = MaybeArenaStringAccessor::create(arena, "10086");
+    accessor.resize(4);
+    auto data = &accessor[0];
+    ASSERT_EQ(4, accessor.size());
+    ASSERT_EQ("1008", accessor);
+    ASSERT_EQ(data, accessor.data());
+    accessor.resize(2);
+    data = &accessor[0];
+    ASSERT_EQ(2, accessor.size());
+    ASSERT_EQ("10", accessor);
+    ASSERT_EQ(data, accessor.data());
+    accessor.resize(4);
+    data = &accessor[0];
+    ASSERT_EQ(4, accessor.size());
+    ASSERT_EQ(::absl::string_view("10\0\0", 4), accessor);
+    ASSERT_EQ(data, accessor.data());
+    accessor.destroy();
+}
+
+TEST_F(ArenaStringTest, support_resize_uninitialized) {
+    auto accessor = MaybeArenaStringAccessor::create(arena, "10086");
+    ::absl::strings_internal::STLStringResizeUninitialized(&accessor, 4);
+    auto data = &accessor[0];
+    ASSERT_EQ(4, accessor.size());
+    ASSERT_EQ("1008", accessor);
+    ASSERT_EQ(data, accessor.data());
+    ::absl::strings_internal::STLStringResizeUninitialized(&accessor, 2);
+    data = &accessor[0];
+    ASSERT_EQ(2, accessor.size());
+    ASSERT_EQ("10", accessor);
+    ASSERT_EQ(data, accessor.data());
+    ::absl::strings_internal::STLStringResizeUninitialized(&accessor, 4);
+    data = &accessor[0];
+    ASSERT_EQ(4, accessor.size());
+    ASSERT_EQ(::absl::string_view("10\08", 4), accessor);
+    ASSERT_EQ(data, accessor.data());
+    accessor.destroy();
+}
+
+template <typename T>
+static void alter_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto accessor = MaybeArenaStringAccessor::create(arena);
+    accessor.push_back('x');
+    assert_on_arena(accessor);
+    accessor.clear();
+    assert_on_arena(accessor);
+    accessor.append(tiny_string);
+    assert_on_arena(accessor);
+    accessor.append(short_string);
+    assert_on_arena(accessor);
+    ::std::string tmp_string(long_string.c_str());
+    auto tmp_ptr = tmp_string.c_str();
+    accessor = ::std::move(tmp_string);
+    ASSERT_EQ(long_string, accessor);
+    if (arena != nullptr)
+        ASSERT_NE(tmp_ptr, accessor.c_str());
+    else {
+        ASSERT_EQ(tmp_ptr, accessor.c_str());
+    }
+    accessor.destroy();
+}
+TEST_F(ArenaStringTest, alter_on_arena) {
+    alter_on_arena(*this, arena);
+    alter_on_arena(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void direct_set_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->set_s(short_string);
+    ASSERT_EQ(short_string, m->s());
+    assert_on_arena(m->s());
+    m->set_b(long_string.c_str(), long_string.size());
+    ASSERT_EQ(long_string, m->b());
+    assert_on_arena(m->b());
+    m->set_os(long_string);
+    ASSERT_EQ(long_string, m->os());
+    assert_on_arena(m->os());
+    m->set_ob(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->ob());
+    assert_on_arena(m->ob());
+    m->add_rs(short_string);
+    ASSERT_EQ(short_string, m->rs(0));
+    assert_on_arena(m->rs(0));
+    m->add_rs(long_string);
+    ASSERT_EQ(long_string, m->rs(1));
+    assert_on_arena(m->rs(1));
+    m->add_rb(long_string.c_str(), long_string.size());
+    ASSERT_EQ(long_string, m->rb(0));
+    assert_on_arena(m->rb(0));
+    m->add_rb(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->rb(1));
+    assert_on_arena(m->rb(1));
+    m->set_ons(short_string);
+    ASSERT_EQ(short_string, m->ons());
+    assert_on_arena(m->ons());
+    m->set_onb(long_string.c_str(), long_string.size());
+    ASSERT_FALSE(m->has_ons());
+    ASSERT_TRUE(m->ons().empty());
+    ASSERT_EQ(long_string, m->onb());
+    assert_on_arena(m->onb());
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, direct_set_on_arena) {
+    direct_set_on_arena<Proto3>(*this, arena);
+    direct_set_on_arena<Proto3>(*this, nullptr);
+    direct_set_on_arena<ArenaProto3>(*this, arena);
+    direct_set_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void direct_set_on_arena_pb2(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->set_s(short_string);
+    ASSERT_EQ(short_string, m->s());
+    assert_on_arena(m->s());
+    m->set_b(long_string.c_str(), long_string.size());
+    ASSERT_EQ(long_string, m->b());
+    assert_on_arena(m->b());
+    m->set_qs(long_string);
+    ASSERT_EQ(long_string, m->qs());
+    assert_on_arena(m->qs());
+    m->set_qb(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->qb());
+    assert_on_arena(m->qb());
+    m->set_ds(short_string);
+    ASSERT_EQ(short_string, m->ds());
+    assert_on_arena(m->ds());
+    m->set_db(long_string.c_str(), long_string.size());
+    ASSERT_EQ(long_string, m->db());
+    assert_on_arena(m->db());
+    m->add_rs(long_string);
+    ASSERT_EQ(long_string, m->rs(0));
+    assert_on_arena(m->rs(0));
+    m->add_rs(short_string);
+    ASSERT_EQ(short_string, m->rs(1));
+    assert_on_arena(m->rs(1));
+    m->add_rb(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->rb(0));
+    assert_on_arena(m->rb(0));
+    m->add_rb(long_string.c_str(), long_string.size());
+    ASSERT_EQ(long_string, m->rb(1));
+    assert_on_arena(m->rb(1));
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, direct_set_on_arena_pb2) {
+    direct_set_on_arena_pb2<Proto2>(*this, arena);
+    direct_set_on_arena_pb2<Proto2>(*this, nullptr);
+    direct_set_on_arena_pb2<ArenaProto2>(*this, arena);
+    direct_set_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void set_again_keep_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->set_s(short_string);
+    m->set_s(long_string);
+    ASSERT_EQ(long_string, m->s());
+    assert_on_arena(m->s());
+    m->set_b(long_string.c_str(), long_string.size());
+    m->set_b(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->b());
+    assert_on_arena(m->b());
+    m->set_os(short_string);
+    m->set_os(long_string);
+    ASSERT_EQ(long_string, m->os());
+    assert_on_arena(m->os());
+    m->set_ob(long_string.c_str(), long_string.size());
+    m->set_ob(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->ob());
+    assert_on_arena(m->ob());
+    m->set_ons(short_string);
+    m->set_ons(long_string);
+    ASSERT_EQ(long_string, m->ons());
+    assert_on_arena(m->ons());
+    m->set_onb(long_string.c_str(), long_string.size());
+    m->set_onb(short_string.c_str(), short_string.size());
+    ASSERT_FALSE(m->has_ons());
+    ASSERT_TRUE(m->ons().empty());
+    ASSERT_EQ(short_string, m->onb());
+    assert_on_arena(m->onb());
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, set_again_keep_on_arena) {
+    set_again_keep_on_arena<Proto3>(*this, arena);
+    set_again_keep_on_arena<Proto3>(*this, nullptr);
+    set_again_keep_on_arena<ArenaProto3>(*this, arena);
+    set_again_keep_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void set_again_keep_on_arena_pb2(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->set_s(short_string);
+    m->set_s(long_string);
+    ASSERT_EQ(long_string, m->s());
+    assert_on_arena(m->s());
+    m->set_b(long_string.c_str(), long_string.size());
+    m->set_b(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->b());
+    assert_on_arena(m->b());
+    m->set_qs(short_string);
+    m->set_qs(long_string);
+    ASSERT_EQ(long_string, m->qs());
+    assert_on_arena(m->qs());
+    m->set_qb(long_string.c_str(), long_string.size());
+    m->set_qb(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->qb());
+    assert_on_arena(m->qb());
+    m->set_ds(short_string);
+    m->set_ds(long_string);
+    ASSERT_EQ(long_string, m->ds());
+    assert_on_arena(m->ds());
+    m->set_db(long_string.c_str(), long_string.size());
+    m->set_db(short_string.c_str(), short_string.size());
+    ASSERT_EQ(short_string, m->db());
+    assert_on_arena(m->db());
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, set_again_keep_on_arena_pb2) {
+    set_again_keep_on_arena_pb2<Proto2>(*this, arena);
+    set_again_keep_on_arena_pb2<Proto2>(*this, nullptr);
+    set_again_keep_on_arena_pb2<ArenaProto2>(*this, arena);
+    set_again_keep_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void clear_keep_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->set_s(short_string);
+    auto* ps = &m->s();
+    m->set_b(long_string);
+    auto* pb = &m->b();
+    m->add_rs(short_string);
+    auto* prs = &m->rs(0);
+    m->add_rb(long_string);
+    auto* prb = &m->rb(0);
+    m->set_ons(short_string);
+    m->set_onb(long_string);
+    m->Clear();
+    m->set_s(long_string);
+    assert_on_arena(m->s());
+    ASSERT_EQ(ps, &m->s());
+    m->set_b(short_string);
+    assert_on_arena(m->b());
+    ASSERT_EQ(pb, &m->b());
+    m->add_rs(long_string);
+    assert_on_arena(m->rs(0));
+    ASSERT_EQ(prs, &m->rs(0));
+    m->add_rb(short_string);
+    assert_on_arena(m->rb(0));
+    ASSERT_EQ(prb, &m->rb(0));
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, clear_keep_on_arena) {
+    clear_keep_on_arena<Proto2>(*this, arena);
+    clear_keep_on_arena<Proto2>(*this, nullptr);
+    clear_keep_on_arena<ArenaProto2>(*this, arena);
+    clear_keep_on_arena<ArenaProto2>(*this, nullptr);
+    clear_keep_on_arena<Proto3>(*this, arena);
+    clear_keep_on_arena<Proto3>(*this, nullptr);
+    clear_keep_on_arena<ArenaProto3>(*this, arena);
+    clear_keep_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void clear_keep_on_arena_pb2(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena);
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->set_ds(short_string);
+    auto* pds = &m->ds();
+    m->set_db(long_string);
+    auto* pdb = &m->db();
+    m->set_qs(short_string);
+    auto* pqs = &m->qs();
+    m->set_qb(long_string);
+    auto* pqb = &m->qb();
+    m->Clear();
+    m->set_ds(long_string);
+    assert_on_arena(m->ds());
+    ASSERT_EQ(pds, &m->ds());
+    m->set_db(short_string);
+    assert_on_arena(m->db());
+    ASSERT_EQ(pdb, &m->db());
+    m->set_qs(long_string);
+    assert_on_arena(m->qs());
+    ASSERT_EQ(pqs, &m->qs());
+    m->set_qb(short_string);
+    assert_on_arena(m->qb());
+    ASSERT_EQ(pqb, &m->qb());
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, clear_keep_on_arena_pb2) {
+    clear_keep_on_arena_pb2<Proto2>(*this, arena);
+    clear_keep_on_arena_pb2<Proto2>(*this, nullptr);
+    clear_keep_on_arena_pb2<ArenaProto2>(*this, arena);
+    clear_keep_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void parse_and_merge_on_arena(T& t, Arena* farena, Arena* tarena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, tarena, tarena);
+    };
+    auto assert_mutable_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, tarena, tarena &&
+                M().GetDescriptor()->file()->options().cc_mutable_donated_string());
+    };
+    ::std::string string;
+    auto* fm = Arena::CreateMessage<M>(farena);
+    auto* tm = Arena::CreateMessage<M>(tarena);
+    fm->set_s(short_string);
+    fm->set_b(long_string);
+    fm->set_os(short_string);
+    fm->set_ob(long_string);
+    fm->set_ons(short_string);
+    fm->set_onb(long_string);
+    fm->add_rs(short_string);
+    fm->add_rs(long_string);
+    fm->add_rb(long_string);
+    fm->add_rb(short_string);
+    fm->SerializeToString(&string);
+    ASSERT_TRUE(fm->SerializeToString(&string));
+    ASSERT_TRUE(tm->ParseFromString(string));
+    ASSERT_EQ(short_string, tm->s());
+    assert_on_arena(tm->s());
+    ASSERT_EQ(long_string, tm->b());
+    assert_on_arena(tm->b());
+    ASSERT_EQ(short_string, tm->os());
+    assert_on_arena(tm->os());
+    ASSERT_EQ(long_string, tm->ob());
+    assert_on_arena(tm->ob());
+    ASSERT_EQ(long_string, tm->onb());
+    assert_on_arena(tm->onb());
+    ASSERT_EQ(short_string, tm->rs(0));
+    assert_on_arena(tm->rs(0));
+    ASSERT_EQ(long_string, tm->rs(1));
+    assert_on_arena(tm->rs(1));
+    ASSERT_EQ(long_string, tm->rb(0));
+    assert_on_arena(tm->rb(0));
+    ASSERT_EQ(short_string, tm->rb(1));
+    assert_on_arena(tm->rb(1));
+    tm->mutable_s()->assign(short_string);
+    assert_mutable_on_arena(tm->s());
+    tm->mutable_rs(0)->assign(long_string);
+    tm->mutable_rb(1)->assign(long_string);
+    ASSERT_TRUE(tm->ParseFromString(string));
+    ASSERT_EQ(short_string, tm->s());
+    assert_mutable_on_arena(tm->s());
+    ASSERT_EQ(long_string, tm->b());
+    assert_on_arena(tm->b());
+    ASSERT_EQ(long_string, tm->onb());
+    assert_on_arena(tm->onb());
+    ASSERT_EQ(short_string, tm->rs(0));
+    assert_mutable_on_arena(tm->rs(0));
+    ASSERT_EQ(long_string, tm->rs(1));
+    assert_on_arena(tm->rs(1));
+    ASSERT_EQ(long_string, tm->rb(0));
+    assert_on_arena(tm->rb(0));
+    ASSERT_EQ(short_string, tm->rb(1));
+    assert_mutable_on_arena(tm->rb(1));
+    tm->CopyFrom(*fm);
+    ASSERT_EQ(short_string, tm->s());
+    assert_mutable_on_arena(tm->s());
+    ASSERT_EQ(long_string, tm->b());
+    assert_on_arena(tm->b());
+    ASSERT_EQ(long_string, tm->onb());
+    assert_on_arena(tm->onb());
+    ASSERT_EQ(short_string, tm->rs(0));
+    assert_mutable_on_arena(tm->rs(0));
+    ASSERT_EQ(long_string, tm->rs(1));
+    assert_on_arena(tm->rs(1));
+    ASSERT_EQ(long_string, tm->rb(0));
+    assert_on_arena(tm->rb(0));
+    ASSERT_EQ(short_string, tm->rb(1));
+    assert_mutable_on_arena(tm->rb(1));
+    if (!tarena) {
+        delete tm;
+    }
+    if (!farena) {
+        delete fm;
+    }
+}
+TEST_F(ArenaStringTest, parse_and_merge_on_arena) {
+    parse_and_merge_on_arena<Proto3>(*this, arena, arena);
+    parse_and_merge_on_arena<Proto3>(*this, arena, nullptr);
+    parse_and_merge_on_arena<Proto3>(*this, nullptr, arena);
+    parse_and_merge_on_arena<Proto3>(*this, nullptr, nullptr);
+    parse_and_merge_on_arena<ArenaProto3>(*this, arena, arena);
+    parse_and_merge_on_arena<ArenaProto3>(*this, arena, nullptr);
+    parse_and_merge_on_arena<ArenaProto3>(*this, nullptr, arena);
+    parse_and_merge_on_arena<ArenaProto3>(*this, nullptr, nullptr);
+}
+
+template <typename M, typename T>
+static void swap_on_arena(T& t, Arena* farena, Arena* tarena) {
+    auto assert_nn_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, tarena, tarena);
+    };
+    auto assert_nm_on_arena = [&] (const ::std::string& s) {
+        if (tarena != farena) {
+            t.assert_on_arena(s, tarena, tarena);
+        } else {
+            t.assert_on_arena(s, tarena, tarena &&
+                    M().GetDescriptor()->file()->options().cc_mutable_donated_string());
+        }
+    };
+    auto assert_mn_on_arena = [&] (const ::std::string& s) {
+        if (tarena != farena) {
+            t.assert_on_arena(s, tarena, tarena);
+        } else {
+            t.assert_on_arena(s, tarena, tarena);
+        }
+    };
+    auto assert_mm_on_arena = [&] (const ::std::string& s) {
+        if (tarena != farena) {
+            t.assert_on_arena(s, tarena, tarena);
+        } else {
+            t.assert_on_arena(s, tarena, tarena &&
+                    M().GetDescriptor()->file()->options().cc_mutable_donated_string());
+        }
+    };
+    auto* fm = Arena::CreateMessage<M>(farena);
+    auto* tm = Arena::CreateMessage<M>(tarena);
+    fm->set_s(short_string);
+    fm->mutable_b()->assign(long_string);
+    fm->mutable_ons()->assign(short_string);
+    fm->add_rs(short_string);
+    fm->add_rs()->assign(long_string);
+    fm->add_rb(long_string);
+    fm->add_rb()->assign(short_string);
+
+    tm->set_s(long_string);
+    tm->set_b(short_string);
+    tm->set_onb(long_string);
+    tm->add_rs(long_string);
+    tm->add_rs(short_string);
+    tm->add_rb()->assign(short_string);
+    tm->add_rb()->assign(long_string);
+
+    tm->Swap(fm);
+    ASSERT_EQ(short_string, tm->s());
+    assert_nn_on_arena(tm->s());
+    ASSERT_EQ(long_string, tm->b());
+    assert_nm_on_arena(tm->b());
+    ASSERT_EQ(short_string, tm->ons());
+    assert_nm_on_arena(tm->ons());
+    ASSERT_EQ(short_string, tm->rs(0));
+    assert_nn_on_arena(tm->rs(0));
+    ASSERT_EQ(long_string, tm->rs(1));
+    assert_nm_on_arena(tm->rs(1));
+    ASSERT_EQ(long_string, tm->rb(0));
+    assert_mn_on_arena(tm->rb(0));
+    ASSERT_EQ(short_string, tm->rb(1));
+    assert_mm_on_arena(tm->rb(1));
+    if (!tarena) {
+        delete tm;
+    }
+    if (!farena) {
+        delete fm;
+    }
+    fm = Arena::CreateMessage<M>(farena);
+    tm = Arena::CreateMessage<M>(tarena);
+    fm->mutable_s()->assign(short_string);
+    fm->set_b(long_string);
+    tm->mutable_s()->assign(long_string);
+    tm->mutable_b()->assign(short_string);
+
+    tm->Swap(fm);
+    ASSERT_EQ(short_string, tm->s());
+    assert_mm_on_arena(tm->s());
+    ASSERT_EQ(long_string, tm->b());
+    assert_mn_on_arena(tm->b());
+    if (!tarena) {
+        delete tm;
+    }
+    if (!farena) {
+        delete fm;
+    }
+}
+TEST_F(ArenaStringTest, swap_on_arena) {
+    swap_on_arena<Proto3>(*this, arena, arena);
+    swap_on_arena<Proto3>(*this, arena, nullptr);
+    swap_on_arena<Proto3>(*this, nullptr, arena);
+    swap_on_arena<Proto3>(*this, nullptr, nullptr);
+    swap_on_arena<ArenaProto3>(*this, arena, arena);
+    swap_on_arena<ArenaProto3>(*this, arena, nullptr);
+    swap_on_arena<ArenaProto3>(*this, nullptr, arena);
+    swap_on_arena<ArenaProto3>(*this, nullptr, nullptr);
+    swap_on_arena<Proto2>(*this, arena, arena);
+    swap_on_arena<Proto2>(*this, arena, nullptr);
+    swap_on_arena<Proto2>(*this, nullptr, arena);
+    swap_on_arena<Proto2>(*this, nullptr, nullptr);
+    swap_on_arena<ArenaProto2>(*this, arena, arena);
+    swap_on_arena<ArenaProto2>(*this, arena, nullptr);
+    swap_on_arena<ArenaProto2>(*this, nullptr, arena);
+    swap_on_arena<ArenaProto2>(*this, nullptr, nullptr);
+}
+
+template <typename M, typename T>
+static void set_allocated_on_arena(T& t, Arena* arena) {
+    auto cc_mutable_donated_string = M().GetDescriptor()->file()->options().cc_mutable_donated_string();
+    auto m = Arena::CreateMessage<M>(arena);
+    {
+        auto s = new ::std::string {short_string};
+        auto c = s->c_str();
+        m->set_allocated_s(s);
+        ASSERT_NE(s, &m->s());
+        ASSERT_EQ(c, m->s().c_str());
+        t.assert_on_arena(m->s(), arena && cc_mutable_donated_string, false);
+        auto cs = &m->s();
+        c = cs->c_str();
+        m->mutable_s()->assign(long_string);
+        ASSERT_EQ(cs, &m->s());
+        ASSERT_NE(c, m->s().c_str());
+        t.assert_on_arena(m->s(), arena && cc_mutable_donated_string, false);
+    }
+    {
+        auto s = new ::std::string {short_string};
+        auto c = s->c_str();
+        m->set_b(long_string);
+        m->set_allocated_b(s);
+        ASSERT_NE(s, &m->b());
+        ASSERT_EQ(c, m->b().c_str());
+        t.assert_on_arena(m->b(), arena && cc_mutable_donated_string, false);
+    }
+    {
+        auto s = new ::std::string {long_string};
+        auto c = s->c_str();
+        m->mutable_ons()->assign(short_string);
+        m->set_allocated_ons(s);
+        ASSERT_EQ(s, &m->ons());
+        ASSERT_EQ(c, m->ons().c_str());
+        t.assert_on_arena(m->ons(), false, false);
+    }
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, set_allocated_on_arena) {
+    set_allocated_on_arena<Proto3>(*this, arena);
+    set_allocated_on_arena<Proto3>(*this, nullptr);
+    set_allocated_on_arena<ArenaProto3>(*this, arena);
+    set_allocated_on_arena<ArenaProto3>(*this, nullptr);
+    set_allocated_on_arena<Proto2>(*this, arena);
+    set_allocated_on_arena<Proto2>(*this, nullptr);
+    set_allocated_on_arena<ArenaProto2>(*this, arena);
+    set_allocated_on_arena<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void release_on_arena(T& t, Arena* arena) {
+    auto cc_mutable_donated_string = M().GetDescriptor()->file()->options().cc_mutable_donated_string();
+    auto m = Arena::CreateMessage<M>(arena);
+    {
+        m->set_s(long_string);
+        auto s = &m->s();
+        auto c = s->c_str();
+        auto r = m->release_s();
+        if (arena || cc_mutable_donated_string) {
+            ASSERT_NE(s, r);
+        } else {
+            ASSERT_EQ(s, r);
+        }
+        if (arena) {
+            ASSERT_NE(c, r->c_str());
+        } else {
+            ASSERT_EQ(c, r->c_str());
+        }
+        ASSERT_EQ(long_string, *r);
+        delete r;
+    }
+    {
+        m->set_os(short_string);
+        auto s = &m->os();
+        auto c = s->c_str();
+        auto r = m->release_os();
+        if (arena || cc_mutable_donated_string) {
+            ASSERT_NE(s, r);
+        } else {
+            ASSERT_EQ(s, r);
+        }
+        if (arena) {
+            ASSERT_NE(c, r->c_str());
+        } else {
+            ASSERT_EQ(c, r->c_str());
+        }
+        ASSERT_EQ(short_string, *r);
+        delete r;
+    }
+    {
+        m->set_ons(long_string);
+        auto s = &m->ons();
+        auto c = s->c_str();
+        auto r = m->release_ons();
+        if (arena) {
+            ASSERT_NE(s, r);
+        } else {
+            ASSERT_EQ(s, r);
+        }
+        if (arena) {
+            ASSERT_NE(c, r->c_str());
+        } else {
+            ASSERT_EQ(c, r->c_str());
+        }
+        ASSERT_EQ(long_string, *r);
+        delete r;
+    }
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, release_on_arena) {
+    release_on_arena<Proto3>(*this, arena);
+    release_on_arena<Proto3>(*this, nullptr);
+    release_on_arena<ArenaProto3>(*this, arena);
+    release_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void release_on_arena_pb2(T& t, Arena* arena) {
+    auto cc_mutable_donated_string = M().GetDescriptor()->file()->options().cc_mutable_donated_string();
+    auto m = Arena::CreateMessage<M>(arena);
+    {
+        m->set_s(long_string);
+        auto s = &m->s();
+        auto c = s->c_str();
+        auto r = m->release_s();
+        if (arena || cc_mutable_donated_string) {
+            ASSERT_NE(s, r);
+        } else {
+            ASSERT_EQ(s, r);
+        }
+        if (arena) {
+            ASSERT_NE(c, r->c_str());
+        } else {
+            ASSERT_EQ(c, r->c_str());
+        }
+        ASSERT_EQ(long_string, *r);
+        delete r;
+    }
+    {
+        m->set_qs(short_string);
+        auto s = &m->qs();
+        auto c = s->c_str();
+        auto r = m->release_qs();
+        if (arena || cc_mutable_donated_string) {
+            ASSERT_NE(s, r);
+        } else {
+            ASSERT_EQ(s, r);
+        }
+        if (arena) {
+            ASSERT_NE(c, r->c_str());
+        } else {
+            ASSERT_EQ(c, r->c_str());
+        }
+        ASSERT_EQ(short_string, *r);
+        delete r;
+    }
+    {
+        m->set_ds(long_string);
+        auto s = &m->ds();
+        auto c = s->c_str();
+        auto r = m->release_ds();
+        if (arena) {
+            ASSERT_NE(s, r);
+        } else {
+            ASSERT_EQ(s, r);
+        }
+        if (arena) {
+            ASSERT_NE(c, r->c_str());
+        } else {
+            ASSERT_EQ(c, r->c_str());
+        }
+        ASSERT_EQ(long_string, *r);
+        delete r;
+    }
+    {
+        m->set_ons(short_string);
+        auto s = &m->ons();
+        auto c = s->c_str();
+        auto r = m->release_ons();
+        if (arena) {
+            ASSERT_NE(s, r);
+        } else {
+            ASSERT_EQ(s, r);
+        }
+        if (arena) {
+            ASSERT_NE(c, r->c_str());
+        } else {
+            ASSERT_EQ(c, r->c_str());
+        }
+        ASSERT_EQ(short_string, *r);
+        delete r;
+    }
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, release_on_arena_pb2) {
+    release_on_arena_pb2<Proto2>(*this, arena);
+    release_on_arena_pb2<Proto2>(*this, nullptr);
+    release_on_arena_pb2<ArenaProto2>(*this, arena);
+    release_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void reflect_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena, arena);
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    auto* r = m->GetReflection();
+    auto* d = m->GetDescriptor();
+    r->SetString(m, d->FindFieldByName("s"), long_string);
+    assert_on_arena(m->s());
+    assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("s"), nullptr));
+    r->SetString(m, d->FindFieldByName("os"), long_string);
+    assert_on_arena(m->os());
+    assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("os"), nullptr));
+    r->AddString(m, d->FindFieldByName("rs"), long_string);
+    assert_on_arena(m->rs(0));
+    assert_on_arena(r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 0, nullptr));
+    r->SetRepeatedString(m, d->FindFieldByName("rs"), 0, long_string + long_string);
+    assert_on_arena(m->rs(0));
+    assert_on_arena(r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 0, nullptr));
+    r->template GetMutableRepeatedFieldRef<::std::string>(m, d->FindFieldByName("rs")).Add(long_string);
+    assert_on_arena(m->rs(1));
+    assert_on_arena(r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 1, nullptr));
+    r->template GetMutableRepeatedFieldRef<::std::string>(m, d->FindFieldByName("rs")).Set(1, long_string + long_string);
+    assert_on_arena(m->rs(1));
+    assert_on_arena(r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 1, nullptr));
+    r->SetString(m, d->FindFieldByName("ons"), long_string);
+    assert_on_arena(m->ons());
+    assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("ons"), nullptr));
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, reflect_on_arena) {
+    reflect_on_arena<Proto3>(*this, arena);
+    reflect_on_arena<Proto3>(*this, nullptr);
+    reflect_on_arena<ArenaProto3>(*this, arena);
+    reflect_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void reflect_on_arena_pb2(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena, arena);
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    auto* r = m->GetReflection();
+    auto* d = m->GetDescriptor();
+    r->SetString(m, d->FindFieldByName("s"), long_string);
+    assert_on_arena(m->s());
+    assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("s"), nullptr));
+    r->SetString(m, d->FindFieldByName("qs"), long_string);
+    assert_on_arena(m->qs());
+    assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("qs"), nullptr));
+    r->SetString(m, d->FindFieldByName("ds"), long_string);
+    assert_on_arena(m->ds());
+    assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("ds"), nullptr));
+    r->AddString(m, d->FindFieldByName("rs"), long_string);
+    assert_on_arena(m->rs(0));
+    assert_on_arena(r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 0, nullptr));
+    r->SetRepeatedString(m, d->FindFieldByName("rs"), 0, long_string + long_string);
+    assert_on_arena(m->rs(0));
+    assert_on_arena(r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 0, nullptr));
+    r->template GetMutableRepeatedFieldRef<::std::string>(m, d->FindFieldByName("rs")).Add(long_string);
+    assert_on_arena(m->rs(1));
+    assert_on_arena(r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 1, nullptr));
+    r->template GetMutableRepeatedFieldRef<::std::string>(m, d->FindFieldByName("rs")).Set(1, long_string + long_string);
+    assert_on_arena(m->rs(1));
+    assert_on_arena(r->GetRepeatedStringReference(*m, d->FindFieldByName("rs"), 1, nullptr));
+    r->SetString(m, d->FindFieldByName("ons"), long_string);
+    assert_on_arena(m->ons());
+    assert_on_arena(r->GetStringReference(*m, d->FindFieldByName("ons"), nullptr));
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, reflect_on_arena_pb2) {
+    reflect_on_arena_pb2<Proto2>(*this, arena);
+    reflect_on_arena_pb2<Proto2>(*this, nullptr);
+    reflect_on_arena_pb2<ArenaProto2>(*this, arena);
+    reflect_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void repeated_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena, arena);
+    };
+    auto assert_mutable_on_arena = [&] (const ::std::string& s) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+        t.assert_on_arena(s, arena, arena);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+        t.assert_on_arena(s, arena, false);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    };
+    auto m = Arena::CreateMessage<M>(arena);
+    auto rs = m->mutable_rs();
+    rs->Add(::std::string(short_string));
+    ASSERT_EQ(short_string, rs->Get(0));
+    assert_on_arena(rs->Get(0));
+    rs->RemoveLast();
+    rs->Add(::std::string(long_string));
+    ASSERT_EQ(long_string, rs->Get(0));
+    assert_on_arena(rs->Get(0));
+    for (auto iter = m->rs().begin(); iter != m->rs().end(); ++iter) {
+        ASSERT_EQ(long_string, *iter);
+        assert_on_arena(*iter);
+    }
+    for (auto iter = rs->begin(); iter != rs->end(); ++iter) {
+        ASSERT_EQ(long_string, *iter);
+        assert_mutable_on_arena(*iter);
+    }
+    rs->Add(::std::string(short_string));
+    ASSERT_EQ(short_string, rs->Get(1));
+    assert_on_arena(rs->Get(1));
+    rs->Mutable(1)->assign(long_string);
+    ASSERT_EQ(long_string, rs->Get(1));
+    assert_mutable_on_arena(rs->Get(1));
+    rs->Add()->assign(long_string);
+    ASSERT_EQ(long_string, rs->Get(2));
+    assert_mutable_on_arena(rs->Get(2));
+    rs->Add(::std::string(long_string));
+    ASSERT_EQ(long_string, m->rs()[3]);
+    assert_on_arena(m->rs()[3]);
+    (*rs)[3].assign(long_string + long_string);
+    ASSERT_EQ(long_string + long_string, rs->Get(3));
+    assert_mutable_on_arena(rs->Get(3));
+    rs->Add(::std::string(long_string));
+    ASSERT_EQ(long_string, m->rs().at(4));
+    assert_on_arena(m->rs().at(4));
+    rs->at(4).assign(long_string + long_string);
+    ASSERT_EQ(long_string + long_string, rs->Get(4));
+    assert_mutable_on_arena(rs->Get(4));
+    rs->Add(::std::string(short_string));
+    ASSERT_EQ(short_string, rs->Get(5));
+    assert_on_arena(rs->Get(5));
+    rs->DeleteSubrange(1, 4);
+    ASSERT_EQ(2, rs->size());
+    if (!arena) {
+        delete m;
+    }
+    m = Arena::CreateMessage<M>(arena);
+    rs = m->mutable_rs();
+    M fm;
+    fm.add_rs(short_string);
+    fm.add_rs(long_string);
+    m->MergeFrom(fm);
+    ASSERT_EQ(short_string, rs->Get(0));
+    assert_on_arena(rs->Get(0));
+    ASSERT_EQ(long_string, rs->Get(1));
+    assert_on_arena(rs->Get(1));
+    {
+        ::std::string strs[2] = {short_string, long_string};
+        rs->Add(strs, strs + 2);
+        ASSERT_EQ(short_string, rs->Get(2));
+        assert_on_arena(rs->Get(2));
+        ASSERT_EQ(long_string, rs->Get(3));
+        assert_on_arena(rs->Get(3));
+    }
+    {
+        ::std::string strs[2] = {long_string, short_string};
+        rs->Assign(strs, strs + 2);
+        ASSERT_EQ(long_string, rs->Get(0));
+        assert_on_arena(rs->Get(0));
+        ASSERT_EQ(short_string, rs->Get(1));
+        assert_on_arena(rs->Get(1));
+    }
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, repeated_on_arena) {
+    repeated_on_arena<Proto2>(*this, arena);
+    repeated_on_arena<Proto2>(*this, nullptr);
+    repeated_on_arena<ArenaProto2>(*this, arena);
+    repeated_on_arena<ArenaProto2>(*this, nullptr);
+    repeated_on_arena<Proto3>(*this, arena);
+    repeated_on_arena<Proto3>(*this, nullptr);
+    repeated_on_arena<ArenaProto3>(*this, arena);
+    repeated_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void repeated_add_allocated_and_release_on_arena(T& t, Arena* arena) {
+    auto m = Arena::CreateMessage<M>(arena);
+    auto rs = m->mutable_rs();
+    {
+        auto s = new ::std::string(long_string);
+        auto c = s->c_str();
+        rs->AddAllocated(s);
+        ASSERT_EQ(s, &rs->Get(0));
+        ASSERT_EQ(c, rs->Get(0).c_str());
+        t.assert_on_arena(rs->Get(0), false, false);
+        s = new ::std::string(long_string);
+        c = s->c_str();
+        rs->AddAllocated(s);
+        ASSERT_EQ(s, &rs->Get(1));
+        ASSERT_EQ(c, rs->Get(1).c_str());
+        t.assert_on_arena(rs->Get(1), false, false);
+        rs->MutableAccessor(1)->assign(long_string + long_string);
+        ASSERT_EQ(s, &rs->Get(1));
+        ASSERT_NE(c, rs->Get(1).c_str());
+        t.assert_on_arena(rs->Get(1), false, false);
+        m->add_rs(long_string);
+    }
+    {
+        auto s = &m->rs(m->rs_size() - 1);
+        auto c = s->c_str();
+        auto r = rs->ReleaseLast();
+        ASSERT_EQ(long_string, *r);
+        if (arena) {
+            ASSERT_NE(s, r);
+            ASSERT_NE(c, r->c_str());
+        } else {
+            ASSERT_EQ(s, r);
+            ASSERT_EQ(c, r->c_str());
+        }
+        t.assert_on_arena(*r, false, false);
+        delete r;
+        s = &m->rs(m->rs_size() - 1);
+        c = s->c_str();
+        r = rs->ReleaseLast();
+        ASSERT_EQ(long_string + long_string, *r);
+        if (arena) {
+            ASSERT_NE(s, r);
+            ASSERT_EQ(c, r->c_str());
+        } else {
+            ASSERT_EQ(s, r);
+            ASSERT_EQ(c, r->c_str());
+        }
+        t.assert_on_arena(*r, false, false);
+        delete r;
+        s = &m->rs(m->rs_size() - 1);
+        c = s->c_str();
+        r = rs->ReleaseLast();
+        ASSERT_EQ(long_string, *r);
+        if (arena) {
+            ASSERT_NE(s, r);
+            ASSERT_EQ(c, r->c_str());
+        } else {
+            ASSERT_EQ(s, r);
+            ASSERT_EQ(c, r->c_str());
+        }
+        t.assert_on_arena(*r, false, false);
+        delete r;
+    }
+    {
+        auto mm = Arena::CreateMessage<M>(arena);
+        mm->mutable_rs()->AddString()->assign(long_string);
+        mm->mutable_rs()->AddAccessor()->assign(long_string);
+        auto s = &mm->rs(mm->rs_size() - 1);
+        auto c = s->c_str();
+        rs->UnsafeArenaAddAllocated(
+                mm->mutable_rs()->UnsafeArenaReleaseLast());
+        auto ss = &m->rs(m->rs_size() - 1);
+        auto cc = ss->c_str();
+        ASSERT_EQ(*s, *ss);
+        ASSERT_EQ(s, ss);
+        ASSERT_EQ(c, cc);
+        t.assert_on_arena(*s, arena, arena);
+        s = &mm->rs(mm->rs_size() - 1);
+        c = s->c_str();
+        rs->UnsafeArenaAddAllocated(
+                mm->mutable_rs()->UnsafeArenaReleaseLast());
+        ss = &m->rs(m->rs_size() - 1);
+        cc = ss->c_str();
+        ASSERT_EQ(*s, *ss);
+        ASSERT_EQ(s, ss);
+        ASSERT_EQ(c, cc);
+        t.assert_on_arena(*s, arena, false);
+        if (!arena) {
+            delete mm;
+        }
+    }
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, repeated_add_allocated_and_release_on_arena) {
+    repeated_add_allocated_and_release_on_arena<Proto2>(*this, arena);
+    repeated_add_allocated_and_release_on_arena<Proto2>(*this, nullptr);
+    repeated_add_allocated_and_release_on_arena<ArenaProto2>(*this, arena);
+    repeated_add_allocated_and_release_on_arena<ArenaProto2>(*this, nullptr);
+    repeated_add_allocated_and_release_on_arena<Proto3>(*this, arena);
+    repeated_add_allocated_and_release_on_arena<Proto3>(*this, nullptr);
+    repeated_add_allocated_and_release_on_arena<ArenaProto3>(*this, arena);
+    repeated_add_allocated_and_release_on_arena<ArenaProto3>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void mutable_string_on_arena(T& t, Arena* arena) {
+    auto assert_mutable_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena, arena &&
+                M().GetDescriptor()->file()->options().cc_mutable_donated_string());
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->set_s(short_string);
+    m->mutable_s()->assign(long_string);
+    ASSERT_EQ(long_string, m->s());
+    assert_mutable_on_arena(m->s());
+    m->mutable_s()->assign(short_string);
+    ASSERT_EQ(short_string, m->s());
+    assert_mutable_on_arena(m->s());
+    m->mutable_s()->clear();
+    m->mutable_s()->push_back('x');
+    m->mutable_s()->append("10086");
+    ASSERT_EQ("x10086", m->s());
+    assert_mutable_on_arena(m->s());
+    m->set_ons(short_string);
+    m->mutable_ons()->assign(long_string);
+    ASSERT_EQ(long_string, m->ons());
+    assert_mutable_on_arena(m->ons());
+    m->mutable_ons()->assign(short_string);
+    ASSERT_EQ(short_string, m->ons());
+    assert_mutable_on_arena(m->ons());
+    m->mutable_ons()->clear();
+    m->mutable_ons()->push_back('x');
+    m->mutable_ons()->append("10086");
+    ASSERT_EQ("x10086", m->ons());
+    assert_mutable_on_arena(m->ons());
+    m->add_rs(short_string);
+    m->mutable_rs(0)->assign(long_string);
+    ASSERT_EQ(long_string, m->rs(0));
+    assert_mutable_on_arena(m->rs(0));
+    m->mutable_rs(0)->assign(short_string);
+    ASSERT_EQ(short_string, m->rs(0));
+    assert_mutable_on_arena(m->rs(0));
+    m->mutable_rs(0)->clear();
+    m->mutable_rs(0)->push_back('x');
+    m->mutable_rs(0)->append("10086");
+    ASSERT_EQ("x10086", m->rs(0));
+    assert_mutable_on_arena(m->rs(0));
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, mutable_string_on_arena) {
+    mutable_string_on_arena<Proto3>(*this, arena);
+    mutable_string_on_arena<Proto3>(*this, nullptr);
+    mutable_string_on_arena<ArenaProto3>(*this, arena);
+    mutable_string_on_arena<ArenaProto3>(*this, nullptr);
+    mutable_string_on_arena<Proto2>(*this, arena);
+    mutable_string_on_arena<Proto2>(*this, nullptr);
+    mutable_string_on_arena<ArenaProto2>(*this, arena);
+    mutable_string_on_arena<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename T>
+static void mutable_string_on_arena_pb2(T& t, Arena* arena) {
+    auto assert_mutable_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena, arena &&
+                M().GetDescriptor()->file()->options().cc_mutable_donated_string());
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->set_ds(short_string);
+    m->mutable_ds()->assign(long_string);
+    ASSERT_EQ(long_string, m->ds());
+    assert_mutable_on_arena(m->ds());
+    m->mutable_ds()->assign(short_string);
+    ASSERT_EQ(short_string, m->ds());
+    assert_mutable_on_arena(m->ds());
+    m->mutable_ds()->clear();
+    m->mutable_ds()->push_back('x');
+    m->mutable_ds()->append("10086");
+    ASSERT_EQ("x10086", m->ds());
+    assert_mutable_on_arena(m->ds());
+    m->set_qs(short_string);
+    m->mutable_qs()->assign(long_string);
+    ASSERT_EQ(long_string, m->qs());
+    assert_mutable_on_arena(m->qs());
+    m->mutable_qs()->assign(short_string);
+    ASSERT_EQ(short_string, m->qs());
+    assert_mutable_on_arena(m->qs());
+    m->mutable_qs()->clear();
+    m->mutable_qs()->push_back('x');
+    m->mutable_qs()->append("10086");
+    ASSERT_EQ("x10086", m->qs());
+    assert_mutable_on_arena(m->qs());
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, mutable_string_on_arena_pb2) {
+    mutable_string_on_arena_pb2<Proto2>(*this, arena);
+    mutable_string_on_arena_pb2<Proto2>(*this, nullptr);
+    mutable_string_on_arena_pb2<ArenaProto2>(*this, arena);
+    mutable_string_on_arena_pb2<ArenaProto2>(*this, nullptr);
+}
+
+template <typename M, typename E, typename T>
+static void extension_on_arena(T& t, Arena* arena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, arena, arena);
+    };
+    auto assert_mutable_on_arena = [&] (const ::std::string& s) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+        t.assert_on_arena(s, arena, arena);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+        t.assert_on_arena(s, arena, false);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    };
+    auto* m = Arena::CreateMessage<M>(arena);
+    m->SetExtension(E::es, short_string);
+    ASSERT_EQ(short_string, m->GetExtension(E::es));
+    assert_on_arena(m->GetExtension(E::es));
+    m->ClearExtension(E::es);
+    m->SetExtension(E::es, long_string);
+    ASSERT_EQ(long_string, m->GetExtension(E::es));
+    assert_on_arena(m->GetExtension(E::es));
+    m->MutableExtension(E::es)->append(long_string);
+    ASSERT_EQ(long_string + long_string, m->GetExtension(E::es));
+    assert_mutable_on_arena(m->GetExtension(E::es));
+    m->ClearExtension(E::es);
+    m->MutableExtension(E::es)->assign(long_string.c_str());
+    ASSERT_EQ(long_string, m->GetExtension(E::es));
+    ASSERT_LE(long_string.size() * 2, m->GetExtension(E::es).capacity());
+    assert_mutable_on_arena(m->GetExtension(E::es));
+    m->AddExtension(E::ers, long_string);
+    ASSERT_EQ(long_string, m->GetExtension(E::ers, 0));
+    assert_on_arena(m->GetExtension(E::ers, 0));
+    m->MutableExtension(E::ers, 0)->append(long_string);
+    ASSERT_EQ(long_string + long_string, m->GetExtension(E::ers, 0));
+    assert_mutable_on_arena(m->GetExtension(E::ers, 0));
+    if (!arena) {
+        delete m;
+    }
+}
+TEST_F(ArenaStringTest, extension_on_arena) {
+    extension_on_arena<Proto2, Proto2Extension>(*this, arena);
+    extension_on_arena<Proto2, Proto2Extension>(*this, nullptr);
+    extension_on_arena<ArenaProto2, ArenaProto2Extension>(*this, arena);
+    extension_on_arena<ArenaProto2, ArenaProto2Extension>(*this, nullptr);
+}
+
+template <typename M, typename E, typename T>
+static void extension_parse_and_merge_on_arena(T& t, Arena* farena, Arena* tarena) {
+    auto assert_on_arena = [&] (const ::std::string& s) {
+        t.assert_on_arena(s, tarena, tarena);
+    };
+    auto assert_mutable_on_arena = [&] (const ::std::string& s) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+        t.assert_on_arena(s, tarena, tarena);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+        t.assert_on_arena(s, tarena, false);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+    };
+    ::std::string string;
+    auto* fm = Arena::CreateMessage<M>(farena);
+    auto* tm = Arena::CreateMessage<M>(tarena);
+    tm->AddExtension(E::ers, short_string);
+    fm->SetExtension(E::es, short_string);
+    fm->set_qs(long_string);
+    fm->set_qb(long_string);
+    fm->set_qc(long_string);
+    fm->AddExtension(E::ers, long_string);
+    fm->AddExtension(E::ers, long_string);
+    ASSERT_TRUE(fm->SerializeToString(&string));
+    ASSERT_TRUE(tm->ParseFromString(string));
+    ASSERT_EQ(short_string, tm->GetExtension(E::es));
+    assert_on_arena(tm->GetExtension(E::es));
+    ASSERT_EQ(long_string, tm->GetExtension(E::ers, 0));
+    assert_on_arena(tm->GetExtension(E::ers, 0));
+    ASSERT_EQ(long_string, tm->GetExtension(E::ers, 1));
+    assert_on_arena(tm->GetExtension(E::ers, 1));
+    tm->MutableExtension(E::es)->assign(long_string.c_str());
+    tm->MutableExtension(E::ers, 0)->append(long_string);
+    ASSERT_TRUE(tm->ParseFromString(string));
+    ASSERT_EQ(short_string, tm->GetExtension(E::es));
+    assert_mutable_on_arena(tm->GetExtension(E::es));
+    ASSERT_EQ(long_string, tm->GetExtension(E::ers, 0));
+    assert_mutable_on_arena(tm->GetExtension(E::ers, 0));
+    ASSERT_EQ(long_string, tm->GetExtension(E::ers, 1));
+    assert_on_arena(tm->GetExtension(E::ers, 1));
+    if (!tarena) {
+        delete tm;
+    }
+    tm = Arena::CreateMessage<M>(tarena);
+    tm->MergeFrom(*fm);
+    ASSERT_EQ(short_string, tm->GetExtension(E::es));
+    assert_on_arena(tm->GetExtension(E::es));
+    ASSERT_EQ(long_string, tm->GetExtension(E::ers, 0));
+    assert_on_arena(tm->GetExtension(E::ers, 0));
+    ASSERT_EQ(long_string, tm->GetExtension(E::ers, 1));
+    assert_on_arena(tm->GetExtension(E::ers, 1));
+    tm->MutableExtension(E::es)->assign(long_string.c_str());
+    tm->MutableExtension(E::ers, 0)->append(long_string);
+    tm->CopyFrom(*fm);
+    ASSERT_EQ(short_string, tm->GetExtension(E::es));
+    assert_mutable_on_arena(tm->GetExtension(E::es));
+    ASSERT_EQ(long_string, tm->GetExtension(E::ers, 0));
+    assert_mutable_on_arena(tm->GetExtension(E::ers, 0));
+    ASSERT_EQ(long_string, tm->GetExtension(E::ers, 1));
+    assert_on_arena(tm->GetExtension(E::ers, 1));
+    if (!farena) {
+        delete fm;
+    }
+    if (!tarena) {
+        delete tm;
+    }
+}
+TEST_F(ArenaStringTest, extension_parse_and_merge_on_arena) {
+    extension_parse_and_merge_on_arena<Proto2, Proto2Extension>(*this, arena, arena);
+    extension_parse_and_merge_on_arena<Proto2, Proto2Extension>(*this, arena, nullptr);
+    extension_parse_and_merge_on_arena<Proto2, Proto2Extension>(*this, nullptr, arena);
+    extension_parse_and_merge_on_arena<Proto2, Proto2Extension>(*this, nullptr, nullptr);
+    extension_parse_and_merge_on_arena<ArenaProto2, ArenaProto2Extension>(*this, arena, arena);
+    extension_parse_and_merge_on_arena<ArenaProto2, ArenaProto2Extension>(*this, arena, nullptr);
+    extension_parse_and_merge_on_arena<ArenaProto2, ArenaProto2Extension>(*this, nullptr, arena);
+    extension_parse_and_merge_on_arena<ArenaProto2, ArenaProto2Extension>(*this, nullptr, nullptr);
+}
+
+int main(int argc, char** argv) {
+    ::testing::InitGoogleTest(&argc, argv);
+    return RUN_ALL_TESTS();
+}
diff --git a/test/test_arena_string_arena_pb2.proto b/test/test_arena_string_arena_pb2.proto
new file mode 100644
index 000000000..8177f0bda
--- /dev/null
+++ b/test/test_arena_string_arena_pb2.proto
@@ -0,0 +1,35 @@
+syntax = "proto2";
+
+package google.protobuf.test_arena_string;
+
+option cc_mutable_donated_string = true;
+
+message ArenaProto2 {
+    optional string s = 1;
+    optional bytes b = 2;
+    optional bytes c = 3 [ctype = CORD];
+    required string qs = 4;
+    required bytes qb = 5;
+    required bytes qc = 6 [ctype = CORD];
+    optional string ds = 7 [default = "10086"];
+    optional bytes db = 8 [default = "10010"];
+    optional bytes dc = 9 [default = "10010", ctype = CORD];
+    repeated string rs = 10;
+    repeated bytes rb = 11;
+    oneof o {
+        string ons = 12;
+        bytes onb = 13;
+        bytes onc = 14 [ctype = CORD];
+    }
+    map<string, string> ms = 15;
+    extensions 100 to 199;
+};
+
+message ArenaProto2Extension {
+    extend ArenaProto2 {
+        optional string es = 100;
+        optional bytes eb = 101;
+        repeated string ers = 102;
+        repeated bytes erb = 103;
+    };
+};
diff --git a/test/test_arena_string_arena_pb3.proto b/test/test_arena_string_arena_pb3.proto
new file mode 100644
index 000000000..345a1a598
--- /dev/null
+++ b/test/test_arena_string_arena_pb3.proto
@@ -0,0 +1,23 @@
+syntax = "proto3";
+
+package google.protobuf.test_arena_string;
+
+option cc_mutable_donated_string = true;
+
+message ArenaProto3 {
+    string s = 1;
+    bytes b = 2;
+    //bytes c = 3 [ctype = CORD];
+    optional string os = 4;
+    optional bytes ob = 5;
+    //optional bytes oc = 6 [ctype = CORD];
+    repeated string rs = 7;
+    repeated bytes rb = 8;
+    //repeated bytes rc = 9 [ctype = CORD];
+    oneof o {
+        string ons = 10;
+        bytes onb = 11;
+        //bytes onc = 12 [ctype = CORD];
+    }
+    map<string, string> ms = 13;
+};
diff --git a/test/test_arena_string_pb2.proto b/test/test_arena_string_pb2.proto
new file mode 100644
index 000000000..18dd81b14
--- /dev/null
+++ b/test/test_arena_string_pb2.proto
@@ -0,0 +1,35 @@
+syntax = "proto2";
+
+package google.protobuf.test_arena_string;
+
+option cc_mutable_donated_string = false;
+
+message Proto2 {
+    optional string s = 1;
+    optional bytes b = 2;
+    optional bytes c = 3 [ctype = CORD];
+    required string qs = 4;
+    required bytes qb = 5;
+    required bytes qc = 6 [ctype = CORD];
+    optional string ds = 7 [default = "10086"];
+    optional bytes db = 8 [default = "10010"];
+    optional bytes dc = 9 [default = "10010", ctype = CORD];
+    repeated string rs = 10;
+    repeated bytes rb = 11;
+    oneof o {
+        string ons = 12;
+        bytes onb = 13;
+        bytes onc = 14 [ctype = CORD];
+    }
+    map<string, string> ms = 15;
+    extensions 100 to 199;
+};
+
+message Proto2Extension {
+    extend Proto2 {
+        optional string es = 100;
+        optional bytes eb = 101;
+        repeated string ers = 102;
+        repeated bytes erb = 103;
+    };
+};
diff --git a/test/test_arena_string_pb3.proto b/test/test_arena_string_pb3.proto
new file mode 100644
index 000000000..2b0fae3a5
--- /dev/null
+++ b/test/test_arena_string_pb3.proto
@@ -0,0 +1,23 @@
+syntax = "proto3";
+
+package google.protobuf.test_arena_string;
+
+option cc_mutable_donated_string = false;
+
+message Proto3 {
+    string s = 1;
+    bytes b = 2;
+    bytes c = 3 [ctype = CORD];
+    optional string os = 4;
+    optional bytes ob = 5;
+    optional bytes oc = 6 [ctype = CORD];
+    repeated string rs = 7;
+    repeated bytes rb = 8;
+    repeated bytes rc = 9 [ctype = CORD];
+    oneof o {
+        string ons = 10;
+        bytes onb = 11;
+        bytes onc = 12 [ctype = CORD];
+    }
+    map<string, string> ms = 13;
+};
